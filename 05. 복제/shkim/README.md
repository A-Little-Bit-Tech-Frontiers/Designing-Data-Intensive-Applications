# 복제(Replication)란?

복제란 네트워크로 연결된 여러 대의 컴퓨터에 동일한 데이터를 복사하여 저장하는 것을 의미합니다. 데이터를 복제하는 데에는 여러 가지 이유가 있습니다.

- 데이터를 사용자와 지리적으로 가까운 곳에 두어 **지연 시간(latency)을 줄이기 위해**
- 시스템의 일부가 고장나도 계속 동작할 수 있도록 하여 **가용성(availability)을 높이기 위해**
- 읽기 쿼리를 처리할 수 있는 머신의 수를 늘려 **읽기 처리량(read throughput)을 높이기 위해**

이 장에서는 데이터셋이 매우 작아서 각 머신이 전체 데이터를 모두 저장할 수 있다고 가정합니다. <br>
복제하는 데이터가 시간이 지나도 변하지 않는다면 복제는 쉽습니다. 데이터를 각 노드에 한 번씩만 복사하면 끝이기 때문입니다. <br>
복제의 모든 어려움은 변화하는 데이터를 어떻게 다룰 것인가에 있습니다. 이 장은 바로 그 점에 대해 다룹니다.

우리는 노드 간 변경사항을 복제하는 세 가지 대표적인 알고리즘, 즉 **싱글 리더(single-leader), 멀티 리더(multi-leader), 그리고 리더 없는(leaderless) 복제**에 대해 논의할 것입니다. <br>
거의 모든 분산 데이터베이스는 이 세 가지 방식 중 하나를 사용합니다. 각각의 장단점을 자세히 살펴볼 것입니다.



## 리더와 팔로워(Leaders and Followers)

<img width="607" height="228" alt="Image" src="https://github.com/user-attachments/assets/2ee4655c-5ca1-430a-9e85-3f2bbbeba4ee" />

데이터베이스 복사본을 저장하는 각 노드를 **복제본(replica)** 이라고 합니다. <br>
복제본이 여러 개 있을 때, 모든 데이터가 모든 복제본에 어떻게 도달하게 할 것인지가 문제입니다. <br>
데이터베이스에 대한 모든 쓰기 작업은 모든 복제본에서 처리되어야 하며, 그렇지 않으면 복제본 간 데이터가 달라지게 됩니다. <br>
가장 일반적인 해결책은 **리더 기반 복제(leader-based replication)** (다른 이름으로는 **active/passive** 또는 **master–slave replication**)입니다.

이 방식은 PostgreSQL(9.0 버전 이후), MySQL 등 많은 관계형 데이터베이스에 내장된 기능입니다. <br>
MongoDB와 같은 일부 비관계형 데이터베이스, 그리고 Kafka, RabbitMQ와 같은 분산 메시지 브로커도 이 방식을 사용합니다.



## 동기 복제와 비동기 복제(Synchronous Versus Asynchronous Replication)

<img width="592" height="284" alt="Image" src="https://github.com/user-attachments/assets/e1158660-9149-42eb-b346-e88d9441f49e" />

복제 시스템에서 중요한 세부사항 중 하나는 복제가 **동기적(synchronous)** 으로 일어나는지, 아니면 **비동기적(asynchronous)** 으로 일어나는지입니다. (관계형 데이터베이스에서는 이 옵션을 설정할 수 있고, 다른 시스템은 하드코딩되어 있는 경우가 많습니다.)

동기 복제의 장점은 팔로워가 항상 리더와 일치하는 최신 데이터를 갖고 있다는 점입니다. <br>
리더가 갑자기 장애가 나더라도, 팔로워에 데이터가 남아있음을 보장할 수 있습니다. 단점은, 동기 팔로워가 응답하지 않으면(예: 크래시, 네트워크 오류 등) 쓰기 작업이 처리되지 않습니다. <br>
리더는 동기 복제본이 다시 사용 가능해질 때까지 모든 쓰기 작업을 막고 대기해야 하므로, 모든 팔로워를 동기식으로 운영하는 것은 비현실적입니다.

대신, 대부분의 리더 기반 복제는 **완전 비동기**로 설정됩니다. 이 경우 리더가 장애로 복구 불가능하게 되면, 아직 팔로워에게 복제되지 않은 쓰기 작업은 유실됩니다. <br>
즉, 클라이언트에게 쓰기 성공을 알렸더라도 데이터의 내구성이 보장되지 않습니다. 하지만 완전 비동기 구성은 모든 팔로워가 뒤처져 있어도 리더가 계속해서 쓰기 작업을 처리할 수 있다는 장점이 있습니다.



## 새로운 팔로워 설정(Setting Up New Followers)

때때로 복제본의 수를 늘리거나, 장애가 난 노드를 교체하기 위해 새로운 팔로워를 추가해야 할 때가 있습니다. 시스템 다운타임 없이 새로운 팔로워를 설정하는 단계는 다음과 같습니다.

1. 리더 데이터베이스의 일관된 스냅샷을 특정 시점에 생성합니다. (가능하다면 전체 데이터베이스 락 없이)
2. 스냅샷을 새로운 팔로워 노드로 복사합니다.
3. 팔로워가 리더에 연결해, 스냅샷 생성 이후 발생한 모든 데이터 변경사항을 요청합니다. (이때 스냅샷은 리더의 복제 로그 상 정확한 위치와 연결되어야 함)
4. 팔로워가 스냅샷 이후의 백로그를 모두 처리하면, 최신 상태에 도달한 것이며 이후 리더의 변경사항을 실시간으로 처리할 수 있습니다.



## 노드 장애 처리(Handling Node Outages)

시스템 내 어떤 노드도 예기치 않게(혹은 유지보수 등으로 계획적으로) 다운될 수 있습니다. <br>
개별 노드를 재부팅해도 시스템 전체가 중단되지 않게 하는 것이 중요합니다. 즉, 개별 노드 장애에도 시스템 전체가 계속 동작하도록 하고, 장애의 영향을 최소화하는 것이 목표입니다.

### 리더 기반 복제로 고가용성 달성 방법

**팔로워 장애: Catch-up 복구**

각 팔로워는 리더로부터 받은 데이터 변경 내역을 로컬 디스크에 로그로 저장합니다. <br>
팔로워가 크래시 후 재시작하거나, 리더와의 네트워크가 잠시 끊겼다가 복구된 경우, 팔로워는 마지막으로 처리한 트랜잭션을 알고 있습니다. <br>
따라서 리더에게 장애 기간 동안의 변경 내역을 요청해, 모두 반영하면 다시 최신 상태가 되어 정상적으로 데이터 변경 스트림을 받을 수 있습니다.

**리더 장애: Failover(장애 조치)**

리더 장애 처리는 더 복잡합니다. 팔로워 중 하나를 새로운 리더로 승격시키고, 클라이언트가 새로운 리더에 쓰기를 전송하도록 재구성해야 하며, 다른 팔로워들도 새로운 리더로부터 데이터 변경을 받아야 합니다. <br>
이 과정을 **장애 조치(failover)** 라고 합니다.

장애 조치는 수동(관리자가 리더 장애를 감지하고 직접 처리) 또는 자동으로 수행될 수 있습니다. 자동 장애 조치의 일반적인 단계는 다음과 같습니다.

1. 리더의 장애를 감지
2. 새로운 리더 선정
3. 시스템을 새로운 리더로 재구성

노드 장애, 네트워크 불안정, 일관성/내구성/가용성/지연 시간 간의 트레이드오프 등은 분산 시스템의 근본적인 문제입니다. <br>
쉬운 해결책은 없으며, 이런 이유로 일부 운영팀은 자동 장애 조치 기능이 있어도 수동으로 처리하기를 선호합니다.



## 복제 로그 구현 방식(Implementation of Replication Logs)

리더 기반 복제를 구현하는 다양한 방법이 있습니다.

### Statement-based 복제

가장 간단한 방법은 리더가 실행한 모든 쓰기 요청(Statement)을 로그로 남기고, 그 로그를 팔로워에게 전달하는 것입니다. <br>
하지만 NOW(), auto-increment, RAND() 등 비결정적 함수 호출 시 로그가 일관되지 않으므로, 이 방식은 여러 문제를 안고 있습니다. 따라서 다른 방식이 더 선호됩니다.

### Write-ahead log (WAL) shipping

로그는 데이터베이스의 모든 쓰기를 담은 append-only 바이트 시퀀스입니다. <br>
리더는 이 로그를 디스크에 쓰는 것과 동시에 네트워크를 통해 팔로워에게 전송할 수 있습니다. 팔로워는 이 로그를 처리해 리더와 동일한 데이터 구조를 만듭니다.

단점은 로그가 매우 저수준(어떤 디스크 블록의 어느 바이트가 바뀌었는지 등)으로 데이터를 기술하므로, 복제가 스토리지 엔진과 강하게 결합된다는 점입니다. 이는 운영상 큰 영향을 미칠 수 있습니다.

### Logical (row-based) log replication

복제와 스토리지 엔진에 서로 다른 로그 포맷을 사용하는 방법도 있습니다. <br>
이렇게 하면 복제 로그가 스토리지 엔진 내부와 분리되어 외부 시스템(예: 데이터 웨어하우스)에서 파싱하기 쉽고, 하위 호환성도 유지할 수 있습니다. <br>
이런 로그를 **논리적(logical) 로그**라고 하며, 보통 데이터베이스 테이블의 각 행 단위로 쓰기 작업을 기록합니다.

### Trigger-based 복제

지금까지 소개한 복제 방식은 데이터베이스 시스템이 자체적으로 처리합니다. 하지만 일부 도구는 데이터베이스 로그를 읽어 애플리케이션에 데이터 변경을 전달할 수 있습니다. <br>
또 다른 대안은 대부분의 관계형 데이터베이스에서 제공하는 **트리거(trigger)** 와 **스토어드 프로시저** 기능을 활용하는 것입니다.

트리거는 데이터 변경(쓰기 트랜잭션)이 발생할 때 자동으로 실행되는 커스텀 애플리케이션 코드를 등록할 수 있게 해줍니다. <br>
트리거는 이 변경을 별도의 테이블에 기록할 수 있고, 외부 프로세스가 이 테이블을 읽어 필요한 로직을 적용한 뒤, 다른 시스템에 복제할 수 있습니다.

트리거 기반 복제는 오버헤드가 크고, 내장 복제 방식보다 버그나 한계에 더 취약하지만, 그만큼 유연성이 높아 유용할 수 있습니다.



## 복제 지연(Replication Lag) 문제

복제는 노드 장애 대응뿐만 아니라 **확장성(더 많은 요청 처리)**, **지연 시간(사용자와 가까운 위치에 복제본 배치)** 에도 중요합니다.

읽기 확장 아키텍처에서는 팔로워를 추가해 읽기 전용 요청 처리 용량을 늘릴 수 있습니다. <br>
하지만 이 방식은 현실적으로 **비동기 복제**에서만 잘 동작합니다. <br>
**완전 동기식 구성**은 단일 노드 장애나 네트워크 장애가 발생하면 전체 시스템이 쓰기 불가 상태가 되기 때문에 신뢰성이 떨어집니다.

비동기 팔로워에서 읽는 경우, 팔로워가 리더보다 뒤처져 있다면 오래된 정보를 읽을 수 있고, 시간이 지나면서 리더와 일치하게 됩니다. 이를 **최종 일관성(eventual consistency)** 이라고 부릅니다.

“eventually(최종적으로)”라는 용어는 일부러 모호하게 쓰입니다. <br>
일반적으로 복제본이 얼마나 뒤처질지에 대한 한계가 없습니다. <br>
정상적으로 동작할 때는 리더에 쓰기가 발생한 뒤 팔로워에 반영되는 **복제 지연(replication lag)** 이 1초 미만일 수 있지만, 시스템이 최대 용량에 가깝게 동작하거나 네트워크에 문제가 생기면 몇 초~몇 분까지도 지연이 커질 수 있습니다.



## 자신이 쓴 데이터 읽기(Reading Your Own Writes)

<img width="741" height="302" alt="Image" src="https://github.com/user-attachments/assets/b5141568-0dcd-4b42-bc89-c02ef9622ef7" />

새로운 데이터를 입력하면 반드시 리더에 전달해야 하지만, 사용자가 데이터를 조회할 때는 팔로워에서 읽을 수 있습니다. <br>
이는 데이터는 자주 조회되고, 쓰기는 드물게 일어나는 경우에 적합합니다.

이 경우 **쓰기 후 읽기 일관성(read-after-write consistency, read-your-writes consistency)** 이 필요합니다. <br>
이는 사용자가 페이지를 새로고침할 때, 자신이 입력한 변경사항이 반드시 보인다는 보장입니다. 다른 사용자의 업데이트는 나중에 보일 수 있지만, 최소한 자신의 입력이 저장되었음을 확인할 수 있습니다.



## 단조 읽기(Monotonic Reads)

<img width="752" height="391" alt="Image" src="https://github.com/user-attachments/assets/a01020e0-0ed8-472f-ade3-308ee2ac8c3c" />

**단조 읽기(monotonic reads)** 는 이전보다 더 오래된 데이터를 읽는 일이 없음을 보장합니다. <br>
이는 강한 일관성보다는 약하지만, 최종 일관성보다는 강한 보장입니다. <br>
즉, 한 사용자가 연속해서 여러 번 읽을 때, 시간이 거꾸로 가지 않으며(더 오래된 값을 읽지 않음), 항상 이전에 읽은 값보다 같거나 최신 값을 읽게 됩니다.

이를 달성하는 한 가지 방법은 각 사용자가 항상 동일한 복제본에서 읽도록 하는 것입니다(사용자마다 다른 복제본을 읽어도 됨).



## 일관된 순서로 읽기(Consistent Prefix Reads)

<img width="618" height="411" alt="Image" src="https://github.com/user-attachments/assets/34946c0e-f242-4285-b995-181514a56807" />

**일관된 순서로 읽기(consistent prefix reads)** 는 일련의 쓰기 작업이 특정 순서로 발생하면, 그 쓰기 작업을 읽는 모든 사용자가 동일한 순서로 보게 됨을 보장합니다.

이 문제는 특히 **파티셔닝(샤딩)된 데이터베이스**에서 심각해집니다. <br>
데이터베이스가 항상 동일한 순서로 쓰기를 적용하면 이런 현상이 발생하지 않지만, 많은 분산 데이터베이스는 파티션마다 독립적으로 동작하므로 전역적인 쓰기 순서가 없습니다.

한 가지 해결책은 인과관계가 있는 쓰기를 반드시 같은 파티션에 기록하는 것이지만, 모든 애플리케이션에 효율적으로 적용되지는 않습니다.



## 복제 지연에 대한 해결책

애플리케이션 개발자가 복제의 미묘한 문제를 신경 쓰지 않아도 되고, 데이터베이스가 “알아서 잘 처리해주길” 바라는 것이 이상적입니다. <br>
이를 위해 **트랜잭션(transaction)** 이 존재합니다. 트랜잭션은 데이터베이스가 더 강력한 보장을 제공해 애플리케이션을 단순하게 만들어줍니다.

단일 노드 트랜잭션은 오래전부터 존재했지만, 분산(복제 및 파티셔닝) 데이터베이스로 옮겨가면서 많은 시스템이 성능 및 가용성 저하를 이유로 트랜잭션을 포기하고, 확장 가능한 시스템에서는 최종 일관성이 불가피하다고 주장합니다.



## 멀티 리더 복제(Multi-Leader Replication)

리더 기반 복제를 확장한 형태로, 여러 노드가 동시에 쓰기를 허용하는 방식이 있습니다. <br>
각 노드가 쓰기를 처리하면, 그 데이터 변경을 다른 모든 노드에 전달해야 합니다. 이를 **멀티 리더 구성(multi-leader configuration, master–master, active/active replication)** 이라고 부릅니다. <br>
이 설정에서는 각 리더가 동시에 다른 리더의 팔로워 역할도 수행합니다.



### 멀티 리더 복제의 사용 사례

단일 데이터센터 내에서 멀티 리더 구성을 사용하는 것은 드물고, 복잡성에 비해 이점이 크지 않습니다. 그러나 다음과 같은 상황에서는 유용할 수 있습니다.

#### 멀티 데이터센터 운영

<img width="600" height="362" alt="Image" src="https://github.com/user-attachments/assets/7ce97040-b12c-4b22-ac82-a849ce8344fe" />

멀티 리더 복제는 장점도 있지만, 동시에 여러 데이터센터에서 동일한 데이터가 변경될 수 있으므로 **쓰기 충돌(write conflict)**을 해결해야 한다는 단점도 있습니다.

#### 오프라인 클라이언트

멀티 리더 복제가 적합한 또 다른 상황은, 인터넷 연결이 끊겨도 애플리케이션이 동작해야 하는 경우입니다(예: 캘린더 앱). <br>
이 경우 각 기기가 로컬 데이터베이스를 리더로 사용하고, 모든 기기 간에 비동기 멀티 리더 복제(동기화)가 이루어집니다. 복제 지연은 인터넷 연결 가능 시점에 따라 몇 시간~며칠까지도 길어질 수 있습니다.

아키텍처적으로 보면, 각 기기가 하나의 “데이터센터” 역할을 하며, 그 사이의 네트워크 연결은 매우 불안정할 수 있습니다.

#### 협업 편집

실시간 협업 편집(예: Google Docs)처럼 여러 사람이 동시에 문서를 편집하는 애플리케이션도 멀티 리더 복제를 사용합니다. <br>
한 사용자가 문서를 편집하면, 그 변경사항이 즉시 로컬 복제본(브라우저 또는 클라이언트 앱)에 적용되고, 서버 및 다른 사용자에게 비동기적으로 복제됩니다.



### 쓰기 충돌 처리(Handling Write Conflicts)

<img width="607" height="375" alt="Image" src="https://github.com/user-attachments/assets/3a077e78-deb5-4734-9235-4afd347564c0" />

멀티 리더 복제의 가장 큰 문제는 **쓰기 충돌(write conflict)** 이 발생할 수 있다는 점이며, 따라서 **충돌 해결(conflict resolution)** 이 필요합니다. 

#### 동기/비동기 충돌 감지

충돌 감지를 동기식으로 처리할 수도 있습니다(즉, 모든 복제본에 쓰기가 복제될 때까지 사용자에게 성공을 알리지 않음). <br>
그러나 이렇게 하면 멀티 리더 복제의 가장 큰 장점(각 복제본이 독립적으로 쓰기를 허용)을 잃게 됩니다. 동기 충돌 감지가 필요하다면 싱글 리더 복제를 쓰는 편이 낫습니다.

#### 충돌 회피

가장 간단한 충돌 대처 전략은 **충돌을 회피**하는 것입니다. <br>
즉, 애플리케이션이 특정 레코드에 대한 모든 쓰기를 같은 리더를 통해 처리하도록 보장하면 충돌이 발생하지 않습니다. <br>
실제로 많은 멀티 리더 복제 구현체가 충돌 처리를 잘 하지 못하므로, 충돌 회피가 자주 권장됩니다. 사실상 한 사용자 관점에서는 싱글 리더 방식과 비슷합니다.

#### 일관된 상태로 수렴

싱글 리더 데이터베이스는 쓰기 작업을 순차적으로 적용하므로, 같은 필드에 여러 번 업데이트가 있으면 마지막 쓰기가 최종 값을 결정합니다. <br>
멀티 리더 구성에서는 쓰기 순서가 정해져 있지 않으므로, 최종 값이 무엇이 될지 명확하지 않습니다.

모든 복제 방식은 결국 모든 복제본의 데이터가 동일해지도록 해야 합니다. 즉, 충돌을 **수렴적(convergent)** 으로 해결해야 하며, 모든 변경이 복제된 후에는 모든 복제본이 동일한 최종 값에 도달해야 합니다. <br>
이를 위해 각 쓰기나 복제본마다 UUID를 생성하거나, 애플리케이션 코드에서 값을 병합하는 등의 방법을 사용할 수 있습니다.

#### 커스텀 충돌 해결 로직

가장 적합한 충돌 해결 방법은 애플리케이션에 따라 다르므로, 대부분의 멀티 리더 복제 도구는 커스텀 충돌 해결 로직을 애플리케이션 코드로 작성할 수 있도록 지원합니다. <br>
이 코드는 쓰기 시점이나 읽기 시점에 실행될 수 있습니다.

충돌 해결은 일반적으로 개별 행(row) 또는 문서(document) 단위로 적용되며, 전체 트랜잭션 단위로 적용되지는 않습니다. <br>
즉, 여러 개의 쓰기를 원자적으로 처리하는 트랜잭션이라도, 충돌 해결은 각각의 쓰기에 대해 별도로 처리됩니다.



## 멀티 리더 복제 토폴로지(Multi-Leader Replication Topologies)

<img width="649" height="227" alt="Image" src="https://github.com/user-attachments/assets/8b9d2785-bf10-4eea-9352-452d8509df93" />

복제 토폴로지란, 한 노드에서 다른 노드로 쓰기 작업이 전파되는 통신 경로를 의미합니다.



## 리더 없는 복제(Leaderless Replication)

일부 데이터 저장 시스템은 리더 개념을 아예 버리고, 모든 복제본이 클라이언트로부터 직접 쓰기 요청을 받을 수 있도록 합니다. <br>
아마존의 Dynamo 시스템이 대표적이며, Riak, Cassandra, Voldemort 등 오픈소스 데이터스토어도 Dynamo 스타일의 리더 없는 복제 모델을 따릅니다.



### 노드가 다운된 상태에서 데이터베이스에 쓰기

리더 기반 구성과 달리, 리더 없는 구성에서는 장애 조치(failover)라는 개념이 없습니다. <br>
이 문제를 해결하기 위해, 클라이언트가 데이터베이스에서 읽을 때는 한 복제본에만 요청을 보내지 않고, 여러 노드에 병렬로 요청을 보냅니다. 이때 각 노드에서 최신 값과 오래된 값이 섞여 반환될 수 있습니다.

#### 읽기 복구와 anti-entropy

복제 계획은 결국 모든 데이터가 모든 복제본에 복사되도록 보장해야 합니다. Dynamo 스타일 데이터스토어에서는 두 가지 메커니즘을 사용합니다.

- **Read repair:** 클라이언트가 여러 노드에 병렬로 읽기 요청을 보내면, 오래된 응답을 감지할 수 있습니다.
- **Anti-entropy 프로세스:** 일부 데이터스토어는 백그라운드에서 복제본 간 데이터 차이를 계속 찾아내고, 누락된 데이터를 서로 복사합니다.

#### 읽기/쓰기 쿼럼(Quorums for reading and writing)

<img width="584" height="286" alt="Image" src="https://github.com/user-attachments/assets/34181661-f0eb-460f-903f-c2a991f6d1f6" />

복제본이 n개일 때, 쓰기 작업은 w개 노드에서 성공해야 완료로 간주하고, 읽기 작업은 최소 r개 노드에서 질의해야 합니다. <br>
(예: n=3, w=2, r=2) w+r > n이면, 읽을 때 r개 노드 중 적어도 하나는 최신 값을 가지고 있으므로 최신 값을 얻을 수 있습니다. <br>
이런 r, w 값을 지키는 읽기/쓰기를 **쿼럼(quorum) 읽기/쓰기**라고 합니다.

필요한 w 또는 r 개수보다 적은 노드만 사용 가능하면, 쓰기/읽기 작업은 에러를 반환합니다. 어떤 종류의 장애인지 구분할 필요 없이, 성공/실패 여부만 중요합니다.

#### 다중 데이터 센터 운영

리더 없는 복제도 동시 쓰기 충돌, 네트워크 중단, 지연 시간 급증을 허용하기 때문에 다중 데이터 센터 운영에 적합합니다.

#### 동시 쓰기 감지

<img width="596" height="309" alt="Image" src="https://github.com/user-attachments/assets/201b1e0e-0bae-4e32-8cb1-aff101df4408" />

여러 클라이언트가 동시에 같은 키에 쓰기를 허용하기 때문에 충돌이 발생할 수 있습니다. <br>
최종적 일관성을 달성하기 위해 복제본들은 동일한 값이 되어야 합니다.

#### 최종 쓰기 승리

각 복제본이 가진 "이전" 값을 버리고 가장 "최신" 값으로 덮어쓰는 방법이 있습니다. <br>
쓰기에 타임스탬프를 붙여 가장 "최신"이라는 의미로 제일 큰 타임스탬프를 선택하고, 이전 타임스탬프를 가진 쓰기는 무시합니다. <br>
데이터 손실을 허용하지 않으신다면 LWW 방식은 충돌 해소에 적합하지 않습니다.

#### "이전 발생" 관계와 동시성

작업 B가 작업 A에 대해 알거나 A에 의존적이거나, 어떤 방식으로든 A를 기반으로 한다면 작업 A는 작업 B의 이전 발생(happens-before)가 됩니다. <br>
작업이 다른 작업보다 먼저 발생하지 않으면 동시 작업이라고 말합니다. <br>
작업이 동시에 발생했는지 어떻게 알 수 있을까요?

> #### happens-before 파악하기
> - 서버가 모든 키에 대한 버전 번호를 유지하고, 키를 기록할 때마다 버전 번호를 증가시킵니다.
> - 클라이언트가 키를 읽을 때 서버는 최신 버전뿐만 아니라 덮어쓰지 않은 모든 값을 반환합니다.
> - 클라이언트가 키를 기록할 때는 이전 읽기의 버전 번호를 포함해야 하며, 이전 읽기에서 받은 모든 값을 함께 합쳐야 합니다.
> - 서버가 특정 버전 번호를 가진 쓰기를 받을 때 해당 버전 이하의 모든 값을 덮어쓸 수 있습니다.
> - 쓰기가 이전 읽기의 버전 번호를 포함하면, 쓰기가 수행되기 이전 상태를 알 수 있습니다.
> - 버전 번호를 포함하지 않은 쓰기는 다른 쓰기와 동시에 수행된 것이므로 아무것도 덮어쓰지 않습니다.

#### 동시에 쓴 값 병합

여러 작업이 동시에 발생하면 클라이언트는 동시에 쓴 값을 합쳐 정리해야 합니다. <br>
형제 값 병합은 다중 리더 복제에서 충돌을 해소하는 문제와 본질적으로 동일합니다. <br>
형제를 병합할 때 삭제한 아이템이 합집합에서 재등장할 수 있기 때문에, 해당 버전 번호에 표시(툼스톤)를 남겨둡니다. <br>
애플리케이션 코드에서 형제 병합은 복잡하고 오류가 발생하기 쉽습니다. <br>
자동 병합을 수행할 수 있게 데이터 구조를 설계하려는 노력이 있습니다. 

#### 버전 벡터

다중 복제본의 동시 쓰기를 받아들이기 위해 복제본마다 버전 번호도 사용합니다. <br>
모든 복제본의 버전 번호 모음을 version vector라고 부릅니다. <br>
버전 벡터는 값을 읽을 때 데이터베이스 복제본에서 클라이언트로 보내고, 값을 기록할 때 데이터베이스로 다시 전송합니다. <br>
이 버전 벡터를 통해 데이터베이스는 덮어쓰기와 동시 쓰기를 구분할 수 있습니다.