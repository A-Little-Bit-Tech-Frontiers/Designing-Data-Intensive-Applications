# 5장. 복제

복제는 네트워크로 연결된 여러 장비(노드)에 **동일한 데이터 사본**을 유지하는 것. 목적은 크게 다음과 같다.

1. **지연 감소(지리적 근접성)**: 사용자 가까운 곳에서 읽어 응답시간을 줄임.
2. **가용성 향상**: 일부 장비나 데이터센터 장애에도 계속 서비스.
3. **읽기 처리량 확장**: 하나의 쓰기 사본을 여러 읽기 사본으로 확장(read scaling).

복제는 크게 **단일 리더**, **다중 리더**, **리더 없는** 세 모델로 구분된다.

## 1. 리더 기반 복제(Single-Leader Replication)

### 1-1. 기본 동작

- 시스템에는 정확히 **하나의 리더(마스터)** 가 존재. 모든 **쓰기**는 리더에 도착.
- 리더는 **복제 로그(replication log / change stream)** 를 로컬에 저장 후 팔로워(리드 레플리카)에 전파.
- 팔로워는 전달받은 로그를 **동일한 순서**로 재생하여 같은 결과 상태를 만든다.
- 읽기 요청은 보통 팔로워로 우회하여 처리량을 늘린다(읽기 전용 복제).

<img width="898" height="346" alt="image" src="https://github.com/user-attachments/assets/cd469e7b-0e47-4e5e-8384-558747fe26e1" />

### 1-2. 동기·비동기·반동기식 복제

- **동기식**: 리더는 적어도 하나(혹은 여러)의 팔로워가 **적용 완료**를 응답해야 쓰기를 성공 처리.
    - 장점: 강한 내구성(리더 장애 시에도 데이터가 팔로워에 존재함을 보장), 일관성(항상 최신 데이터 유지)
    - 단점: 지연 증가, 팔로워/네트워크 이상 시 **전체 쓰기 중단** 위험.
- **비동기**: 리더만 성공하면 완료. 지연↓/처리량↑, 대신 **리더 장애 시 최근 쓰기 유실** 가능.
- **반동기**: 최소 1개 팔로워만 동기, 나머지는 비동기. 동기식 팔로워가 사용할 수 없게 되는 경우 비동기식 팔로워 중 하나가 동기식 팔로워로 대체됨.

> 운영 팁: 멀티 데이터센터에서는 **완전 동기**를 강제하면 지연/가용성 비용이 매우 커지므로, 보통 데이터센터 내에서는 반동기, 센터 간에는 비동기를 섞는다.
> 

<img width="878" height="404" alt="image" src="https://github.com/user-attachments/assets/32922acf-1c0c-472a-9b93-42fa0db97a87" />

### 1-3. 팔로워 장애: 따라잡기 복구

- 시스템의 노드는 예기치 않게 종료될 수 있지만, 유지보수 등의 목적으로 의도적으로 중단되는 경우도 존재.
- 리더 기반 복제에서는 이런 상황을 대응할 수 있는 여러 방안이 있다.
- 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 저장한다.
- 팔로워는 장애가 발생하고 다시 실행하게 되면, 장애가 발생한 마지막 트랜잭션을 알아낸다.
- 팔로워는 리더에게 장애 이후 시점의 모든 데이터 변경을 요청한다.
- 이 변경이 적용되면 팔로워는 리더를 따라잡게 되고, 이전과 같이 데이터 스트림을 계속 받을 수 있다.

### 1-4. 리더 장애와 장애 복구(Failover)

복구 절차는 보통 자동화되지만 다음 네 단계를 포함한다.

1. **장애 판단**: 헬스체크/타임아웃으로 리더 불능 판단.
2. **새 리더 선출**: 선출 과정 또는 제어 노드에 의해 새로운 리더를 선출한다. 새로운 리더 후보는 대부분 이전 리더의 최신 데이터를 가진 복제 노드이다.
3. **클라이언트 재설정**: 쓰기/읽기 라우팅을 새 리더로 전환.
4. **로그 정합성 맞추기**: 이전 리더의 미커밋/미전파 변경 처리.

장애 복구 과정에서 주의해야 할 사항은 다음과 같다.

- **쓰기 유실**: 비동기 복제인 경우 새로운 리더가 이전 리더의 쓰기를 일부 수신하지 못할 수 있다. 만약, 이전 리더가 다시 살아나서 유실된 데이터를 써야하는 상황에서는 어떻게 해야할 것인가? → 일반적인 해결책으로는 이전 리더의 데이터를 폐기하는 방법이다.
- **스플릿 브레인**: 두 노드가 자신이 리더라고 믿는 경우. 두 리더의 쓰기 충돌 과정이 없다면 데이터가 유실되거나 오염될 수 있다. 일부 시스템에서는 안전 장치로 두 리더가 감지되면 한 노드를 종료시킨다.
- **순서 뒤틀림/중복 적용**: 재시도/복구 과정에서 로그 재생 순서가 달라지거나 두 번 적용되는 문제.

### 1-5. 복제 로그 전파 방식

1. **구문 기반 복제**
    - 리더가 실행한 SQL 구문 자체를 전파. (INSERT, UPDATE, DELETE)
    - 단점: **비결정적 함수(NOW, RAND)** 를 호출하는 구문은 각 복제 서버마다 데이터가 다르게 생성될 가능성 존재.
    - 단점: 자동 증가 컬럼이나 데이터베이스에 있는 데이터에 의존하는 구문이라면 정확히 같은 순서로 실행해야 한다. 아니면 데이터가 달라질 수 있다.
    - 단점: 부수 효과를 가진 구문(예: 트리거, 스토어드 프로시저, 사용자 정의 함수)는 부수 효과가 완벽하게 결정적이어야 한다.
    - 해결책: 리더는 구문을 기록할 때 비결정적 함수 호출을 고정 값을 반환하도록 대체한다.
    - MySQL 5.1 이전 버전에서 이 방식을 사용했다. → 현재는 로우 기반 복제 (row-based-replication)
2. **쓰기 전 로그 배송**
    - 저장엔진의 **바이너리 로그 블록**을 그대로 전파해 재생. 고성능·일관됨.
    - 단점: 엔진/버전 종속, 이기종 복제 어려움.
3. 논리적(로우 기반) 로그 복제
    - 복제와 저장소 엔진을 위해 다른 로그 형식을 사용하는 것. 이런 종류의 복제 로그를 저장소 엔진의 물리적 데이터 표현과 구별하기 위해 **논리적 로그(logical log)** 라고 부른다.
    - 관계형 데이터베이스용 논리적 로그는 보통 로우 단위로 테이블에 쓰기를 기술한 레코드 열이다.
    - “테이블 T, 키 K의 **이전→이후 값**” 같은 **로우 단위 변경 이벤트**를 전파.
    - 장점: 논리적 로그 형식은 외부 애플리케이션이 파싱하기 더 쉽다. 변경 데이터 캡처(change data capture)를 할 때 유용하다.
    - 관계형 DB는 **row-based** 가 기본 추세, WAL은 엔진 내부 복제에서 흔함.
4. 트리거 기반 복제
    - 지금까지 설명한 복제 접근 방식은 애플리케이션 코드 없이 데이터베이스 시스템에 의해 구현됨.
    - 조금 더 유연성이 필요한 경우 트리거 기반 복제 사용. 데이터의 서브셋만 복제, 이기종 DB 복제, 충돌 해소 로직 필요 → 복제를 애플리케이션 레이어에서 수행해야 한다.
    - 데이터 변경 → 트리거 → 외부 프로세스에서 read → 애플리케이션 로직 적용 → 다른 시스템으로 데이터 복제

### 1-6. 복제 지연

**비동기 팔로워**에서 데이터를 읽을 때 복제가 반영되지 않았다면 지난 정보(out-dated)를 볼 수도 있다.

일시적으로 리더와 팔로워의 데이터가 불일치할 수 있지만, 결국에는 팔로워가 리더를 따라잡게 되어 리더와 데이터가 일치하게 되는데, 이를 가리켜 **최종적 일관성**이라고 한다.

정상적인 상황에서 리더에서의 쓰기 동작이 팔로워에게 반영되기까지는 아주 짧은 순간이지만, 시스템이 가용량 근처에서 동작하거나 네트워크 문제가 발생하면 복제 지연은 수 초에서 수 분으로 증가할 수 있다.

다음은 복제 지연이 있을 때 발생할 수 있는 세 가지 이상 현상 사례이다.

- **쓰기 후 읽기 일관성(Read-Your-Writes), 자신이 쓴 내용 읽기**
    - 새로운 데이터를 쓰는 작업은 리더에게 전송하지만, 데이터를 볼 때는 팔로워에서 읽는다. 만약 비동기 팔로워에 데이터가 아직 복제 되지 않은 상황이라면 사용자가 제출한 데이터가 유실된 것처럼 보일 수 있다.
        
        <img width="804" height="322" alt="image" src="https://github.com/user-attachments/assets/15b915c3-06b9-4dff-8127-6ee0dbe41de7" />
        
    - “내가 방금 쓴 건 즉시 보고 싶다.”
    - 사용자가 수정한 내용을 읽을 때는 리더에서 읽는다. 그 밖에는 팔로워에서 읽는다. 예) 자신의 프로필은 리더에서 읽고, 다른 사용자의 프로필은 팔로워에서 읽는 규칙 적용.
    - 마지막 갱신 시각을 찾아서 마지막 갱신 후 1분 동안은 리더에서 읽기를 수행하는 등의 규칙을 적용한다.
    - **기기 간 일관성**: 같은 사용자라도 모바일/웹 등 **다른 디바이스**에서 방금 쓴 내용을 보장하려면, 사용자 세션 토큰에 “최신 타임스탬프”를 담아 그보다 최신인 복제본에서만 읽게 하거나, **처음엔 리더**, 이후 캐시된 팔로워 전략을 사용.
- **단조 읽기(Monotonic Reads)**
    - 비동기식 팔로워에서 읽기를 수행할 때 발생할 수 있는 두 번째 이상 현상은 사용자가 **시간이 거꾸로 흐르는 현상**을 목격할 수 있다는 것이다.
    - 이 현상은 사용자가 각기 다른 복제 서버에서 여러 읽기를 수행할 때 발생할 수 있다.
    
    <img width="807" height="395" alt="image" src="https://github.com/user-attachments/assets/4ebca069-767a-4ac8-a187-188b82b11ad5" />
    
    - 해결책: **한 사용자의 읽기**를 **항상 같은 복제서버**로 라우팅한다. 예를 들어 사용자ID의 해시를 기반으로 복제 서버를 선택한다.
    - 단조 읽기는 강한 일관성보다는 덜한 보장이지만, 최종적 일관성보다는 더 강한 보장이다. 사용자가 데이터를 여러 번 읽어도 시간이 되돌아가는 현상을 보지 않는다.
- **일관된 순서로 읽기(Consistent Prefix)**
    - 세 번째 복제 지연 이상 현상은 인과성의 위반 우려다.
    
    <img width="634" height="432" alt="image" src="https://github.com/user-attachments/assets/2d5469f6-b64f-482a-bf6d-c5c296badcb4" />
    
    - 원인→결과의 **메시지 순서로 읽기를** 보장해야 한다. (예: 댓글 스레드에서 질문이 답보다 항상 먼저 나타나야 함)
    - 이 문제는 파티셔닝된(샤딩된) 데이터베이스에서 발생하는 특징적인 문제이다. 분산 데이터베이스에서 서로 다른 파티션은 독립적으로 동작하므로 쓰기의 순서는 보장되지 않는다.
    - 파티션이 여려 개라면 각 파티션의 이벤트를 **같은 순서로 합쳐 보여주기** 위한 별도 계층(타임라인 정렬)이 필요. 또는 서로 인과성 있는 데이터 쓰기 작업은 동일한 파티션에서 이루어지도록 하는 방법 사용.

## 2. 다중 리더(Multi-Leader) 복제

리더가 하나만 존재한다면 리더에 문제가 발생했을 때 데이터베이스에 쓰기를 할 수 없다. → 다중 리더 복제 필요성

But, 다중 리더 복제는 충돌 해소 과정이 필요해서 복잡하다.

### 2-1. 다중 리더 복제의 사용 사례

- **다중 데이터 센터 운영:** 내결함성 또는 지리적 문제로 인한 지연시간 감소를 위해 각 데이터 센터마다 리더가 있을 수 있다. 각 데이터 센터 내에서는 단일 리더 복제처럼 동작하고, 데이터 센터 간에는 서로의 리더 간 복제가 이루어진다.

<img width="1304" height="740" alt="image" src="https://github.com/user-attachments/assets/bebd8c93-8fa7-4e12-94b6-e97a3353319a" />

- **오프라인작업을 하는 클라이언트** 오프라인 시 로컬 DB에 쓰기 작업 후, 모든 디바이스에 다중 리더 복제를 비동기 방식으로 수행한다. 클라이언트가 지역 리더(로컬DB)에 쓰고 온라인 시 동기화(모든 디바이스)
- **협업 편집** 한 사용자가 문서를 편집할 때 변경 내용(웹 브라우저나 클라이언트 애플리케이션의 문서 상태)을 로컬 복제 서버에 적용하고 나서 동일한 문서를 편집하는 다른 사용자와 서버에 비동기 방식으로 복제한다.

### 2-2. 쓰기 충돌 다루기

다중 리더 복제에서 제일 큰 문제는 쓰기 충돌이 발생한다는 점이다. 즉, 충돌 해소 과정이 필요하다.

두 리더가 동일 레코드/필드를 동시에 갱신하면 충돌. 다중 리더의 핵심은 **“충돌을 어떻게 다룰 것인가”**.

<img width="625" height="375" alt="image" src="https://github.com/user-attachments/assets/e56f433c-982b-461b-919e-30e982899793" />

### 동기 대 비동기 충돌 감지

- 단일 리더 데이터베이스에서 첫 번째 쓰기가 완료될 때 까지 두 번째 쓰기를 기다리게 하거나 트랜잭션을 중단해 사용자가 쓰기를 재시도하게 한다.
- 반면, 다중 리더 데이터베이스에서는 두 개의 쓰기 요청이 모두 성공하며 충돌은 이후 특정 시점에서 비동기로만 감지한다. 감지 시점에 충돌이 발생할 가능성이 있다.
- 이론적으로 다중 리더 데이터베이스도 동기방식으로 충돌을 감지할 수 있다. 쓰기가 성공하려면 사용자에게 성공 응답을 하기 전에 모든 복제 서버가 쓰기를 복제하기를 기다린다. 하지만 이렇게 하면 각 복제 서버가 독립적으로 쓰기를 허용한다는 다중 리더 복제의 장점을 잃는다.

### 충돌 회피

- 특정 레코드의 모든 쓰기가 동일한 리더만 거치도록 애플리케이션이 보장하면 충돌은 발생하지 않는다. (충돌 회피) 많은 다중 리더 복제 구현 사례에서 충돌을 잘 처리하지 못하기 때문에 충돌을 피하는 것이 자주 권장된다.
- 사용자/레코드/파티션 **소유 리더**를 정해 해당 리더로만 쓰기 라우팅(세션 고정, 문서 잠금).
- 장점: 단순/직관적. 단점: 이동/교대/장애 시 라우팅 어려움, 유연성↓.

### 일관된 상태 수렴

- 단일 리더 데이터베이스는 순차적인 순서로 쓰기를 적용한다. 동일한 필드를 여러 번 갱신한다면 마지막 쓰기가 필드의 최종값으로 결정된다. But, 다중 리더 데이터베이스에서는 쓰기 순서가 정해지지 않아 최종 값이 무엇인지 명확하지 않다.
- 모든 복제는 최종적으로 동일하다는 사실을 보장해야 하기 때문에 데이터베이스는 수렴(convergent) 방식으로 충돌을 해소해야 한다.
- **최종 쓰기 승리 LWW(Last-Write-Wins)**: 타임스탬프 또는 고유ID가 가장 최신인 쓰기를 선택한다. 가장 대중적이지만 데이터 유실 위험이 있다. (둘 중 하나는 삭제된다.)
- **병합 적용**: 카운터는 합, 집합은 합집합/차집합, 문자열은 도메인 규칙으로 병합 등으로 어떻게든 값을 병합한다.
- **애플리케이션 로직**: 명시적 데이터 구조에 충돌을 기록해 모든 정보를 보존한다. 나중에 충동을 해소하는 애플리케이션 코드를 작성한다.

### 사용자 정의 충돌 해소 로직

- 충돌을 해소하는 가장 적합한 방법은 애플리케이션에 따라 다르기 때문에 대부분의 다중 리더 복제는 애플리케이션 코드를 사용해 충돌 해소 로직을 작성한다.
- **충돌 감지 시점**
    - **쓰기 중 감지**: 복제된 변경 사항 로그에서 데이터베이스 시스템이 충돌을 감지하자마자 충돌 핸들러를 호출한다. 핸들러는 일반적으로 사용자에게 충돌 내용을 표시하지 않으며, 백그라운드에서 실행된다.
    - **읽기 중 감지**: 충돌을 감지하면 모든 충돌 쓰기를 저장한다. 나중에 데이터를 읽을 때 여러 버전의 충돌 데이터가 애플리케이션에 반환된다. 애플리케이션은 충돌을 해소하고 결과를 데이터베이스에 기록한다.
    - **사후 정리**: 백그라운드 잡으로 일관된 상태로 병합

> 다중 리더 데이터베이스는 “충돌이 일어날 수밖에 없는” 모델이므로, **도메인에 맞는 병합 규칙이 명시돼 있을 때** 사용해야 적절하다.
> 

### 2-3. 토폴로지

- **전체 연결(all-to-all)**: 모든 리더가 서로 전파.
- **링(circular)**: 간단/구현 용이, 그러나 한 고리 문제 시 전파 지연/중단.
- **허브/스타**: 중앙 허브를 통해 간선 수를 줄임(허브 SPOF 주의).

<img width="668" height="241" alt="image" src="https://github.com/user-attachments/assets/de1a75d0-9227-45a6-8c3f-e82f63c277ef" />

## 3. 리더 없는(Leaderless, Dynamo 계열)복제

일부 데이터 저장소 시스템은 리더의 개념을 버리고 모든 복제 서버가 클라이언트로부터 쓰기를 직접 받을 수 있게 허용하는 접근 방식을 사용한다.

리더 없는 복제는 아마존이 **다이나모(Dynamo)** 시스템에서 사용한 후 다시 데이터베이스용 아키텍처로 유행했다. 따라서 이런 종류의 데이터베이스를 **다이나모 스타일**이라 한다.

### 3-1. 쓰기/읽기 절차와 정족수

- 리더 기반 데이터베이스에서는 쓰기 노드가 사용할 수 없게 되면 장애 복구가 실행되어야 쓰기 작업을 할 수 있다. 반면 리더 없는 데이터베이스에서는 장애 복구 없이도 쓰기 작업을 할 수 있다.

<img width="686" height="365" alt="image" src="https://github.com/user-attachments/assets/330d540e-29bb-4d27-8dfe-36e98ae266f2" />

- **쓰기**: 최소 **w**개 노드가 성공 응답하면 완료.
- **읽기**: 최소 **r**개 노드에서 읽어 병합. 특정 노드가 오래된 데이터를 가지고 있을 수 있기 때문에 버전 숫자를 이용해 어떤 값이 최신인지 결정한다.
- 직관적 선택: **w + r > n**(서로 겹치는 노드가 있어 최신 값을 읽을 가능성↑). 일반적으로 n을 홀수(보통 3이나 5)로 하고 w =  r = (n + 1) / 2(반올림)로 설정한다.

<img width="630" height="315" alt="image" src="https://github.com/user-attachments/assets/d593e7d8-a060-422f-88f4-1580fb539139" />

### 3-2. 읽기 복구와 안티 엔트로피

- 데이터베이스는 최종적으로 모든 데이터가 모든 복제 서버에 복사된 것을 보장해야 한다. 다이나모 스타일 데이터 스토어에서 사용 불가능한 노드가 온라인 상태가 된 후 누락된 쓰기를 따라잡는 방법은 크게 두 가지가 있다.
- **읽기 복구** 클라이언트가 여러 노드에서 읽기를 수행하면 오래된 응답을 감지할 수 있다. 오래된 응답이 감지된 노드에 새로운 값을 다시 기록한다. 이 접근 방식은 값을 자주 읽는 상황에 적합하다.
- **안티 엔트로피 처리** 백그라운드 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된 데이터를 복제한다.

### 3-3. 정족수의 현실적 한계

- n개의 복제 서버가 있고 w + r > n이 되게끔 w와 r을 선택한다면 일반적으로 모든 읽기는 최신 값을 반환할 것을 기대한다. 이는 쓰기 노드 3개, 읽기 노드 3개가 겹치기 때문이다. 즉, 읽은 노드 중에는 최신 값을 가진 노드가 하나 이상 있어야 한다. (그림 5-11 참고)
- **But, 시계 오차/네트워크 지연/재시도** 등으로 인해 **w + r > n**이어도 오래된 값을 읽을 수 있다. 예를 들어, 쓰기와 읽기가 동시에 발생하면 쓰기는 일부 복제 서버에만 반영될 수 있다. 이 경우 읽기가 예전 값 또는 최신 값을 반환하는지 여부가 분명하지 않다.
- 일부 노드가 계속 느리거나 분할되면 “최신 보장”은 **확률적** 성질이 된다.

### 3-4. 동시 쓰기·장애 시나리오

<img width="669" height="479" alt="image" src="https://github.com/user-attachments/assets/b5aa73c4-2669-4409-b805-a573be11a8e4" />

- **노드 다운 동안의 쓰기**: 복구 후 뒤늦은 값이 도착 → 읽기 시 여러 버전을 받아 **병합**해야 한다.
- **동시 쓰기 감지**: 서로 인과관계가 없는 두 업데이트가 **서로 다른 값**을 낼 때 “형제(sibling)” 버전으로 공존.
- **최종 쓰기 승리(LWW)** 를 적용하면 쉬우나, **손실 쓰기** 우려. 특히 삭제/카운터/합계 등에는 부적절.

## 4. “이전 발생”과 버전 벡터 (Version Vector)

<img width="678" height="391" alt="image" src="https://github.com/user-attachments/assets/edbf39b4-5c10-40b1-ae0d-04d0ce887c93" />

### 4-1. 인과관계(happens-before)

- 작업 A의 결과를 토대로 작업 B가 이루어졌다면 A → B **인과**. (e.g. insert data → update data)
- 인과가 성립하면 **충돌이 아님**(순서만 보장하면 됨).
- 반대로 서로 독립이면 **진짜 충돌**이며 병합 필요.
- 만약 두 작업이 인과 관계가 없다면(= 두 작업이 서로를 알지 못하면) 단순히 동시 작업이라 말한다.

### 4-2. 버전 벡터의 아이디어

- 각 키(또는 레코드)는 복제본 별 **카운터**를 가진 벡터를 유지:
    
    예) {노드1: 3, 노드2: 5, 노드3: 0}
    
- 두 버전을 비교할 때
    - 한쪽 벡터가 다른 쪽 **모든 성분에서 ≤** 이면 **포함관계**(선후관계).
    - 어느 쪽도 포함되지 않으면 **동시성 충돌**(siblings).
- 실무에선 이벤트 추적 정확도를 높인 **점선 버전 벡터(dotted version vector)** 도 쓰인다(복제본/이벤트 단위 식별).

### 4-3. 실무 병합 전략

- **LWW는 최후의 수단**: 캐시/로그성 데이터를 제외하고 핵심 데이터에는 지양.
- **명령적/도메인 병합**: 상태가 아니라 **연산의 의미**를 병합(카운터 더하기, 집합 합치기 등).
- **CRDT/OT**: 수학적으로 병합 가능한 자료형을 적극 채택(협업 편집, 카운터, 세트, 맵 등).
- **UI 도움**: 충돌 버전을 사용자에게 **명시적으로 노출**해 선택/수정하게 하고, 서버는 **감춘 자동삭제 금지**

## 5. 5장 정리

- 복제의 핵심은 **동일 데이터의 여러 사본을 “같은 의미”로 유지**하는 것이다.
- **리더 기반**은 쓰기 순서를 하나의 축으로 모아 단순/예측 가능성을 얻는 대신, 복제 지연으로 인한 읽기 일관성 문제를 **라우팅/정책**으로 보완한다. (복제 지연 해결책 - 쓰기 후 읽기 일관성, 단조 읽기, 일관된 순서로 읽기)
- **다중 리더**는 지리 분산/오프라인/협업 편집처럼 여러 곳에서 동시 쓰기가 본질인 도메인에 맞다. 이 모델의 성패는 **충돌(언젠가 반드시 일어난다)** 을 **설명 가능하게** 다루는가에 달려 있다.
- **리더 없는(정족수)** 복제는 장애 내성과 수평 확장에 유리하지만, **w + r > n**이 곧 강한 최신성을 뜻하지는 않는다. 타임스탬프·네트워크 현실 때문에 **확률적 최신성**일 뿐이며, 읽기 복구/안티-엔트로피/버전 벡터 같은 도구로 **수렴**을 만들어야 한다.
- 맺음말: 복제 모델 선택은 **지연·가용성·정합성**의 **트레이드오프**를 고르는 일이다. 읽기 보장( RYW/Monotonic/Prefix ), 장애 시 행태, 충돌 처리의 **도메인 의미**까지 포함해 “어떤 잘못을 감수하고 무엇을 보장할지”를 팀 차원에서 문서화하면, 5장의 지침을 제대로 활용한 것이다.
