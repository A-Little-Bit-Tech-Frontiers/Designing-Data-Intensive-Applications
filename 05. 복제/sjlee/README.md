데이터 복제가 필요한 이유

- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게해 가용성을 높인다.
- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

(데이터셋이 작아 각 장비에 전체 데이터셋의 복사본을 보유할 수 있다고 가정)

복제에서 어려움은 변경된 데이터에 대한 처리다. 노드 간 변경을 복제하기 위한 세 가지 알고리즘을 책에서 소개함

- 단일 리더(single-leader)
- 다중 리더(multi-leader)
- 리더 없는 복제(leaderless)

복제에는 고려해야 할 많은 트레이드 오프가 있다. - 동기식 복제? 비동기식 복제? 잘못된 복제는 어떻게 처리?

# 1. 리더와 팔로워

복제 서버 중 하나를 리더로 지정한다. 클라이언트가 DB에 쓰기를 수행할 때, 이 DB는 리더여야 한다.

다른 복제 서버는 레플리카로, 리더가 데이터를 기록할 때마다 데이터 변경을 복제 로그나 변경 스트림의 일부로 팔로워에게 전송한다.

⇒ 각 레플리카는 로그를 받으면, 리더가 처리한 순서 그대로 쓰기 작업을 수행해서 싱크를 맞춤.

<img width="627" height="221" alt="image" src="https://github.com/user-attachments/assets/272d7fa5-e326-4937-8ef6-af0d7ffee17e" />


읽기는 레플리카에서만 허용.

## 1.1 동기식 vs 비동기식 복제

<img width="578" height="228" alt="image" src="https://github.com/user-attachments/assets/132b888d-48f4-4200-8bd8-04e9c09c58b2" />


위 그림의 팔로워 1의 복제는 동기식이다. 리더는 팔로워 1이 쓰기를 수신했는지 확인할 때까지 대기한다. 반면 팔로워 2의 복제는 비동기식이다. 

**동기식 복제**의 장점은 정합성이 깨지지 않는다는 것이다. 갑자기 리더가 동작하지 않아도 데이터는 팔로워에서 사용할 수 있음을 의미한다. 단점은 동기 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없다는 것이다. (⇒ 이래서 현실적으로 동기는 어려움)

**반동기식 복제**가 있다. 모든 팔로워를 동기 방식으로 처리하는건 비현실적이니, 팔로워 하나만 동기식으로 복제하고 나머지 팔로워들은 다 비동기식으로 구성하는 형식을 의미한다.

보통 리더 기반 복제는 **비동기식**으로 구성한다. 리더가 죽었을 때 쓰기 데이터가 유실될 수 있다. 하지만, 모든 팔로워가 죽더라도 리더가 쓰기 처리는 계속 유지할 수 있다는 장점도 존재한다.

## 1.2 새로운 팔로워 설정

장애 노드의 대체를 위해 새로운 팔로워를 설정해야 한다. **새로운 팔로워**가 리더의 데이터 복제본을 정확히 가지고 있음을 보장하는 방법은 아래와 같다. 중단시간 없이 수행할 수 있는 개념이다.

- 전체 데이터베이스를 잠그지 않고 **리더(leader) DB의 스냅샷**을 특정 시점에서 가져온다.
- 생성한 스냅샷을 **새로운 팔로워 노드**에 복사한다.
- 팔로워는 리더에 연결 후, 스냅샷 시점 이후 발생한 모든 데이터 변경을 요청한다.
- 팔로워가 스냅숏 이후의 **데이터 변경 내역(백로그)**을 모두 처리하면, 리더와 동기화 완료 상태인 것이다.
- 이후부터는 리더에서 발생하는 새로운 데이터 변경을 실시간으로 처리

## 1.3 노드 중단 처리

개별 노드의 장애에도 전체 시스템이 동작하게끔 유지하고 노드 중단의 영향을 최소화해야만 한다.

리더 기반 복제에서 어떻게 고가용성 달성?

### 1.3.1 팔로워 장애: Catch-up Recovery

- 각 팔로워는 **리더에게서 받은 데이터 변경 사항을 로컬 디스크의 로그에 기록한다.**
- 팔로워가 크래시나 네트워크 단절로 잠시 중단되었다가 다시 시작되면, 로그를 확인하여 **어디까지 동기화했는지**를 알 수 있음
- 그 후, 리더에게 연결하여 **끊겨 있던 동안의 변경 사항**을 요청한다.
- 이 변경 사항들을 모두 적용하면, 팔로워는 다시 리더와 같은 상태로 맞춰지고 이후에도 정상적으로 데이터를 계속 받을 수 있다.

⇒ 즉, 팔로워는 자체 로그 덕분에 비교적 쉽게 복구가 가능하다는 특징이 있음.

### 1.3.2 리더 장애: Failover

리더 장애는 팔로워보다 훨씬 복잡합니다. 장애 발생 시 **팔로워 중 하나를 새로운 리더로 승격**해야 하며, 시스템 전반의 재구성이 필요합니다. 

**Failover 절차**

1. **리더 장애 감지**
    - 장애 원인: 크래시, 전원 문제, 네트워크 오류 등.
    - 대부분의 시스템은 일정 시간(예: 30초) 동안 응답이 없으면 리더를 "죽었다"고 간주
2. **새로운 리더 선택**
    - 남은 팔로워들이 투표(election)를 통해 리더를 뽑거나, 미리 지정된 **컨트롤러 노드(controller node)** 가 새로운 리더를 임명함
    - 보통 가장 최신 데이터를 가지고 있는 팔로워가 새로운 리더 후보가 됨
    - 합의(consensus) 과정이 필요하므로 복잡
3. **시스템 재구성**
    - 클라이언트가 이제 새로운 리더에게 요청을 보내도록 재설정해야 한다.
    - 이전 리더가 다시 돌아와도, 자신이 리더라고 착각할 수 있으므로 반드시 **팔로워로 강등**시켜야 함.

**Failover 시 발생할 수 있는 문제들**

- **비동기 복제의 문제**
    
    새로운 리더가 되기 전에 리더가 받은 변경 사항이 반영되지 않았을 수 있음.
    
    → 해결책: 옛 리더의 미반영 데이터는 버려지지만, 이는 내구성(durability)을 해칠 수 있음.
    
- **키 충돌 문제**
    
    GitHub 사례처럼, 오래된 MySQL 팔로워가 리더로 승격되면서 **자동 증가 키** 충돌로 다른 시스템과 데이터 불일치 발생 가능. ⇒ 이 키를 레디스 저장에도 사용했다고 함. → redis - mysql 간 키 불일치가 일어났고, 잘못된 사용자에게 개인 데이터 제공된 사건이 있었다고 한다,,,
    
- **Split Brain**
    
    두 노드가 동시에 자신을 리더라고 생각하는 상황.
    
    → 둘 다 쓰기 요청을 받으면 데이터 손실이나 충돌 발생.
    
    → 안전장치: 일부 시스템은 **두 리더 중 하나를 강제 종료**하는 기능을 가짐.
    
- **타임아웃 설정 문제**
    - 타임아웃이 너무 길면 → 리더 장애 복구가 늦어짐.
    - 타임아웃이 너무 짧으면 → 불필요한 Failover가 자주 발생.

## 1.4 복제 로그 구현 (Implementation of Replication Logs)

리더 기반 복제는 내부적으로 어떻게 동작할까? 실제로 여러 가지 복제 방법이 사용된다.

### 1.4.1. 구문 기반 복제 (Statement-based replication)

가장 단순한 경우, 리더는 실행하는 모든 쓰기 요청(구문, statement)을 로그에 기록하고 이를 팔로워에게 전달한다.

관계형 데이터베이스에서는 **INSERT, UPDATE, DELETE** 문장이 팔로워에게 전송되며, 팔로워는 이 SQL 문장을 클라이언트로부터 받은 것처럼 해석하고 실행한다.

**한계점**

- **비결정적 함수**: `NOW()`(현재 시각), `RAND()`(랜덤 숫자) 등은 각 복제본에서 서로 다른 값을 생성할 수 있다.
- **자동 증가 컬럼 / 조건부 업데이트**: 예를 들어 `UPDATE … WHERE <조건>` 같은 문장은 모든 복제본에서 정확히 같은 순서로 실행되어야 한다. 그렇지 않으면 결과가 달라질 수 있다.
- **부수 효과(side effects)**: 트리거, 저장 프로시저, 사용자 정의 함수 등은 복제본마다 다른 효과를 낼 수 있다.

⇒ 따라서 문장 기반 복제는 단순하고 공간 효율적이지만, 이런 제약 때문에 현재는 잘 사용되지 않는다. MySQL도 5.1 버전 이후부터는 기본적으로 **row-based replication**을 사용한다.

### 1.4.2. Write-ahead log, WAL shipping

스토리지 엔진은 모든 쓰기를 로그에 먼저 기록한다.

- **Log-structured storage (SSTable, LSM-Tree)**: 로그 자체가 저장소 역할을 한다.
- **B-Tree 기반**: 변경은 먼저 WAL에 기록된 후 실제 블록에 반영된다.

이 로그는 **추가만 가능한(Append-only)** 바이트 시퀀스로, 리더는 이 로그를 팔로워에게 전송하여 동일한 데이터 구조를 재현하게 한다.

- PostgreSQL, Oracle 등에서 사용.
- 단점: 로그가 디스크 블록 수준의 매우 낮은 레벨 정보를 담으므로, 스토리지 엔진에 강하게 종속된다.
- DB 버전/스토리지 포맷이 바뀌면 서로 다른 버전을 동시에 운영하기 어렵다.
- 따라서 WAL 기반 복제는 **버전 업그레이드 시 다운타임**이 필요한 경우가 많다.

### 1.4.3. 논리적(행 기반) 로그 복제 (Logical / Row-based replication)

저장소 엔진의 물리적 포맷과 분리된 **논리 로그(logical log)**를 사용한다.

관계형 DB에서는 일반적으로 행 단위(row level)로 기록된다.

- **삽입된 행**: 모든 컬럼의 새로운 값 기록.
- **삭제된 행**: 삭제된 행을 고유하게 식별할 수 있는 정보 기록(보통 PK).
- **갱신된 행**: 변경된 컬럼의 새로운 값 기록.

이 방식은 MySQL의 **binlog(row-based replication)에서 사용**된다.

장점:

- 스토리지 엔진과 분리 → 리더와 팔로워가 다른 버전/다른 엔진을 써도 호환 가능.
- 외부 시스템(예: 데이터 웨어하우스, 캐시, 인덱스)에 데이터를 전달하기 쉬움.
- 흔히 **Change Data Capture(CDC)** 기법에 활용된다.

### 1.4.4. 트리거 기반 복제 (Trigger-based replication)

앞서 설명한 방식들은 DBMS 자체가 처리하는 반면, 트리거 기반 복제는 **애플리케이션 레벨**에서 복제를 수행한다.

- 예: **Oracle GoldenGate**, **Databus(Oracle)**, **Bucardo(Postgres)**.
- 데이터 변경 시 트리거가 실행되어 변경 내용을 별도 테이블에 기록 → 외부 프로세스가 이를 읽어 다른 DB에 반영.
- 장점:
    - 데이터의 일부만 선택적으로 복제 가능.
    - 서로 다른 종류의 DB 간 복제 가능.
    - 충돌 해결 로직(custom conflict resolution)을 넣을 수 있음.
- 단점:
    - 내장 복제보다 **성능 오버헤드 크고**, **버그 발생 가능성 높음**.
    - 하지만 유연성이 커서 특정 상황에서 유용하다.
