데이터 복제가 필요한 이유

- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게해 가용성을 높인다.
- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

(데이터셋이 작아 각 장비에 전체 데이터셋의 복사본을 보유할 수 있다고 가정)

복제에서 어려움은 변경된 데이터에 대한 처리다. 노드 간 변경을 복제하기 위한 세 가지 알고리즘을 책에서 소개함

- 단일 리더(single-leader)
- 다중 리더(multi-leader)
- 리더 없는 복제(leaderless)

복제에는 고려해야 할 많은 트레이드 오프가 있다. - 동기식 복제? 비동기식 복제? 잘못된 복제는 어떻게 처리?

# 1. 리더와 팔로워

복제 서버 중 하나를 리더로 지정한다. 클라이언트가 DB에 쓰기를 수행할 때, 이 DB는 리더여야 한다.

다른 복제 서버는 레플리카로, 리더가 데이터를 기록할 때마다 데이터 변경을 복제 로그나 변경 스트림의 일부로 팔로워에게 전송한다.

⇒ 각 레플리카는 로그를 받으면, 리더가 처리한 순서 그대로 쓰기 작업을 수행해서 싱크를 맞춤.

<img width="627" height="221" alt="image" src="https://github.com/user-attachments/assets/272d7fa5-e326-4937-8ef6-af0d7ffee17e" />


읽기는 레플리카에서만 허용.

## 1.1 동기식 vs 비동기식 복제

<img width="578" height="228" alt="image" src="https://github.com/user-attachments/assets/132b888d-48f4-4200-8bd8-04e9c09c58b2" />


위 그림의 팔로워 1의 복제는 동기식이다. 리더는 팔로워 1이 쓰기를 수신했는지 확인할 때까지 대기한다. 반면 팔로워 2의 복제는 비동기식이다. 

**동기식 복제**의 장점은 정합성이 깨지지 않는다는 것이다. 갑자기 리더가 동작하지 않아도 데이터는 팔로워에서 사용할 수 있음을 의미한다. 단점은 동기 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없다는 것이다. (⇒ 이래서 현실적으로 동기는 어려움)

**반동기식 복제**가 있다. 모든 팔로워를 동기 방식으로 처리하는건 비현실적이니, 팔로워 하나만 동기식으로 복제하고 나머지 팔로워들은 다 비동기식으로 구성하는 형식을 의미한다.

보통 리더 기반 복제는 **비동기식**으로 구성한다. 리더가 죽었을 때 쓰기 데이터가 유실될 수 있다. 하지만, 모든 팔로워가 죽더라도 리더가 쓰기 처리는 계속 유지할 수 있다는 장점도 존재한다.

## 1.2 새로운 팔로워 설정

장애 노드의 대체를 위해 새로운 팔로워를 설정해야 한다. **새로운 팔로워**가 리더의 데이터 복제본을 정확히 가지고 있음을 보장하는 방법은 아래와 같다. 중단시간 없이 수행할 수 있는 개념이다.

- 전체 데이터베이스를 잠그지 않고 **리더(leader) DB의 스냅샷**을 특정 시점에서 가져온다.
- 생성한 스냅샷을 **새로운 팔로워 노드**에 복사한다.
- 팔로워는 리더에 연결 후, 스냅샷 시점 이후 발생한 모든 데이터 변경을 요청한다.
- 팔로워가 스냅숏 이후의 **데이터 변경 내역(백로그)**을 모두 처리하면, 리더와 동기화 완료 상태인 것이다.
- 이후부터는 리더에서 발생하는 새로운 데이터 변경을 실시간으로 처리

## 1.3 노드 중단 처리

개별 노드의 장애에도 전체 시스템이 동작하게끔 유지하고 노드 중단의 영향을 최소화해야만 한다.

리더 기반 복제에서 어떻게 고가용성 달성?

### 1.3.1 팔로워 장애: Catch-up Recovery

- 각 팔로워는 **리더에게서 받은 데이터 변경 사항을 로컬 디스크의 로그에 기록한다.**
- 팔로워가 크래시나 네트워크 단절로 잠시 중단되었다가 다시 시작되면, 로그를 확인하여 **어디까지 동기화했는지**를 알 수 있음
- 그 후, 리더에게 연결하여 **끊겨 있던 동안의 변경 사항**을 요청한다.
- 이 변경 사항들을 모두 적용하면, 팔로워는 다시 리더와 같은 상태로 맞춰지고 이후에도 정상적으로 데이터를 계속 받을 수 있다.

⇒ 즉, 팔로워는 자체 로그 덕분에 비교적 쉽게 복구가 가능하다는 특징이 있음.

### 1.3.2 리더 장애: Failover

리더 장애는 팔로워보다 훨씬 복잡합니다. 장애 발생 시 **팔로워 중 하나를 새로운 리더로 승격**해야 하며, 시스템 전반의 재구성이 필요합니다. 

**Failover 절차**

1. **리더 장애 감지**
    - 장애 원인: 크래시, 전원 문제, 네트워크 오류 등.
    - 대부분의 시스템은 일정 시간(예: 30초) 동안 응답이 없으면 리더를 "죽었다"고 간주
2. **새로운 리더 선택**
    - 남은 팔로워들이 투표(election)를 통해 리더를 뽑거나, 미리 지정된 **컨트롤러 노드(controller node)** 가 새로운 리더를 임명함
    - 보통 가장 최신 데이터를 가지고 있는 팔로워가 새로운 리더 후보가 됨
    - 합의(consensus) 과정이 필요하므로 복잡
3. **시스템 재구성**
    - 클라이언트가 이제 새로운 리더에게 요청을 보내도록 재설정해야 한다.
    - 이전 리더가 다시 돌아와도, 자신이 리더라고 착각할 수 있으므로 반드시 **팔로워로 강등**시켜야 함.

**Failover 시 발생할 수 있는 문제들**

- **비동기 복제의 문제**
    
    새로운 리더가 되기 전에 리더가 받은 변경 사항이 반영되지 않았을 수 있음.
    
    → 해결책: 옛 리더의 미반영 데이터는 버려지지만, 이는 내구성(durability)을 해칠 수 있음.
    
- **키 충돌 문제**
    
    GitHub 사례처럼, 오래된 MySQL 팔로워가 리더로 승격되면서 **자동 증가 키** 충돌로 다른 시스템과 데이터 불일치 발생 가능. ⇒ 이 키를 레디스 저장에도 사용했다고 함. → redis - mysql 간 키 불일치가 일어났고, 잘못된 사용자에게 개인 데이터 제공된 사건이 있었다고 한다,,,
    
- **Split Brain**
    
    두 노드가 동시에 자신을 리더라고 생각하는 상황.
    
    → 둘 다 쓰기 요청을 받으면 데이터 손실이나 충돌 발생.
    
    → 안전장치: 일부 시스템은 **두 리더 중 하나를 강제 종료**하는 기능을 가짐.
    
- **타임아웃 설정 문제**
    - 타임아웃이 너무 길면 → 리더 장애 복구가 늦어짐.
    - 타임아웃이 너무 짧으면 → 불필요한 Failover가 자주 발생.

## 1.4 복제 로그 구현 (Implementation of Replication Logs)

리더 기반 복제는 내부적으로 어떻게 동작할까? 실제로 여러 가지 복제 방법이 사용된다.

### 1.4.1. 구문 기반 복제 (Statement-based replication)

가장 단순한 경우, 리더는 실행하는 모든 쓰기 요청(구문, statement)을 로그에 기록하고 이를 팔로워에게 전달한다.

관계형 데이터베이스에서는 **INSERT, UPDATE, DELETE** 문장이 팔로워에게 전송되며, 팔로워는 이 SQL 문장을 클라이언트로부터 받은 것처럼 해석하고 실행한다.

**한계점**

- **비결정적 함수**: `NOW()`(현재 시각), `RAND()`(랜덤 숫자) 등은 각 복제본에서 서로 다른 값을 생성할 수 있다.
- **자동 증가 컬럼 / 조건부 업데이트**: 예를 들어 `UPDATE … WHERE <조건>` 같은 문장은 모든 복제본에서 정확히 같은 순서로 실행되어야 한다. 그렇지 않으면 결과가 달라질 수 있다.
- **부수 효과(side effects)**: 트리거, 저장 프로시저, 사용자 정의 함수 등은 복제본마다 다른 효과를 낼 수 있다.

⇒ 따라서 문장 기반 복제는 단순하고 공간 효율적이지만, 이런 제약 때문에 현재는 잘 사용되지 않는다. MySQL도 5.1 버전 이후부터는 기본적으로 **row-based replication**을 사용한다.

### 1.4.2. Write-ahead log, WAL shipping

스토리지 엔진은 모든 쓰기를 로그에 먼저 기록한다.

- **Log-structured storage (SSTable, LSM-Tree)**: 로그 자체가 저장소 역할을 한다.
- **B-Tree 기반**: 변경은 먼저 WAL에 기록된 후 실제 블록에 반영된다.

이 로그는 **추가만 가능한(Append-only)** 바이트 시퀀스로, 리더는 이 로그를 팔로워에게 전송하여 동일한 데이터 구조를 재현하게 한다.

- PostgreSQL, Oracle 등에서 사용.
- 단점: 로그가 디스크 블록 수준의 매우 낮은 레벨 정보를 담으므로, 스토리지 엔진에 강하게 종속된다.
- DB 버전/스토리지 포맷이 바뀌면 서로 다른 버전을 동시에 운영하기 어렵다.
- 따라서 WAL 기반 복제는 **버전 업그레이드 시 다운타임**이 필요한 경우가 많다.

### 1.4.3. 논리적(행 기반) 로그 복제 (Logical / Row-based replication)

저장소 엔진의 물리적 포맷과 분리된 **논리 로그(logical log)**를 사용한다.

관계형 DB에서는 일반적으로 행 단위(row level)로 기록된다.

- **삽입된 행**: 모든 컬럼의 새로운 값 기록.
- **삭제된 행**: 삭제된 행을 고유하게 식별할 수 있는 정보 기록(보통 PK).
- **갱신된 행**: 변경된 컬럼의 새로운 값 기록.

이 방식은 MySQL의 **binlog(row-based replication)에서 사용**된다.

장점:

- 스토리지 엔진과 분리 → 리더와 팔로워가 다른 버전/다른 엔진을 써도 호환 가능.
- 외부 시스템(예: 데이터 웨어하우스, 캐시, 인덱스)에 데이터를 전달하기 쉬움.
- 흔히 **Change Data Capture(CDC)** 기법에 활용된다.

### 1.4.4. 트리거 기반 복제 (Trigger-based replication)

앞서 설명한 방식들은 DBMS 자체가 처리하는 반면, 트리거 기반 복제는 **애플리케이션 레벨**에서 복제를 수행한다.

- 예: **Oracle GoldenGate**, **Databus(Oracle)**, **Bucardo(Postgres)**.
- 데이터 변경 시 트리거가 실행되어 변경 내용을 별도 테이블에 기록 → 외부 프로세스가 이를 읽어 다른 DB에 반영.
- 장점:
    - 데이터의 일부만 선택적으로 복제 가능.
    - 서로 다른 종류의 DB 간 복제 가능.
    - 충돌 해결 로직(custom conflict resolution)을 넣을 수 있음.
- 단점:
    - 내장 복제보다 **성능 오버헤드 크고**, **버그 발생 가능성 높음**.
    - 하지만 유연성이 커서 특정 상황에서 유용하다.


## 1.5 복제 지연(Replication Lag)의 문제

노드 장애 허용 외에도 복제가 필요한 이유는 많다.

- **확장성**: 단일 서버가 처리할 수 있는 것보다 더 많은 요청을 처리하기 위함.
- **지연 시간 감소**: 사용자와 지리적으로 가까운 위치에 복제본을 두어 빠른 응답을 제공하기 위함.

**리더 기반 복제**에서는 **모든 쓰기가 반드시 리더를 거쳐야 하지만, 읽기는 어느 복제본에서든 가능**하다.

→ 읽기 비중이 높고 쓰기 비중이 낮은 워크로드에서는 많은 팔로워를 두어 읽기 요청을 분산시키는 것이 매력적임

**이런 구조를 읽기 확장(read-scaling)**이라고 한다. 하지만 이는 **비동기 복제(asynchronous replication)**일 때만 현실적이다.

- 만약 모든 팔로워에 동기식 복제를 강제한다면, 한 노드 장애나 네트워크 문제만으로도 전체 시스템이 쓰기 불가능해진다.

**비동기 복제의 문제**

비동기 팔로워에서 읽으면, 리더의 최신 쓰기 결과가 반영되지 않은 **오래된 데이터**를 볼 수 있다.

- 같은 시각에 리더와 팔로워에 동일한 쿼리를 실행하면 결과가 다를 수 있다.
- 시간이 지나 팔로워가 따라잡으면 결국 일치하게 된다 → **Eventual Consistency**

### **복제 지연으로 인한 실제 문제**

### 1.5.1 **내가 쓴 것을 읽기 (Read Your Own Writes)**

<img width="512" height="205" alt="image" src="https://github.com/user-attachments/assets/b80062e2-08c5-4a0f-81ff-5bf107be5f29" />


사용자가 데이터를 입력한 직후 다시 조회할 때 문제가 발생한다.

- 예: 댓글 작성 후 바로 새로고침했는데, 복제 지연 때문에 팔로워에는 반영되지 않아 댓글이 보이지 않음.
- 사용자 입장에서는 "내가 쓴 글이 사라졌다"라고 느끼므로 불만족.

해결책 → **쓰기 후 읽기 일관성(Read-after-write consistency)**

- 사용자가 **방금 수정했을 가능성이 있는 데이터는 반드시 리더에서 읽게 한다.**
- 예: 소셜 네트워크의 자기 프로필 정보는 항상 리더에서 읽고, 다른 사람 프로필은 팔로워에서 읽기.
- 타임스탬프 추적: 최근 업데이트 이후 일정 시간 동안은 리더에서 읽게 하는 방법.
- 다중 데이터센터 환경에서는 더 복잡해지며, 같은 사용자가 여러 기기에서 접근할 경우 **교차 기기 쓰기 후 읽기 일관성(cross-device read-after-write consistency)**도 필요하다.

### 1.5.2 **단조 읽기 (Monotonic Reads)**

<img width="492" height="260" alt="image" src="https://github.com/user-attachments/assets/4764803f-3d87-447e-9d01-6cffb3e787aa" />


비동기 팔로워에서 읽으면 **시간이 거꾸로 가는 현상**이 생길 수 있다.

- 예: 사용자 A가 댓글을 달고, 사용자 B가 두 번 조회했을 때
    - 첫 번째 조회: 최신 팔로워에서 A의 댓글이 보임
    - 두 번째 조회: 더 늦게 동기화된 팔로워에서 조회 → 댓글이 사라짐
- 사용자는 매우 혼란스러움…..

해결책 → **단조 읽기 보장(Monotonic Reads Guarantee)**

- **같은 사용자는 항상 같은 복제본에서 읽도록 보장.**
    - 예: 사용자 ID 해시 기반으로 항상 동일한 복제본에 연결.
- 단, 그 복제본이 장애나면 다른 복제본으로 라우팅해야 한다.

### 1.5.3 **일관된 접두사 읽기 (Consistent Prefix Reads)**

쓰기 순서가 뒤집혀 보이는 문제.

- 예: 대화에서 질문이 늦게 복제되고, 답변이 먼저 복제된 경우 → 사용자가 답변을 질문보다 먼저 보게 됨.
- 이는 **인과성(causality)** 위반이다.

해결책 → **일관된 접두사 보장**

- 쓰기 순서가 항상 동일하게 반영되도록 보장.
- 분할된 데이터베이스에서는 **파티션별로 독립적으로 동작하므로 이런 문제가 자주 발생.**

### 복제 지연 문제 해결책

- **eventual consistency** 시스템에서는 **복제 지연**이 수 초~수 분 이상 길어질 수 있음을 고려해야 한다.
- 사용자 경험에 악영향을 준다면, **반드시 더 강한 보장(예: read-after-write)을 제공**해야 한다.
- 그러나 이런 기능을 애플리케이션 코드에서 구현하기는 어렵고 복잡하다.
- 따라서 **트랜잭션(transactions)** 같은 메커니즘이 필요하다.
    - 데이터베이스가 애플리케이션 대신 일관성 보장을 제공.
    - 개발자가 세세한 복제 문제를 신경 쓰지 않고 DB를 신뢰할 수 있게 함.

# 2. 다중 리더 복제

앞에서는 리더가 하나인 복제 구조만 다루었지만, 그 외에도 흥미로운 대안이 있다.
리더 기반 복제의 단점은 **리더가 하나뿐이라 모든 쓰기가 그 리더를 거쳐야 한다는 점**이다.

→ 네트워크 장애 등으로 리더에 연결할 수 없으면 쓰기를 할 수 없다.

이를 확장한 모델이 **멀티 리더 복제**다. 여러 노드가 동시에 쓰기를 허용하고, 각 리더는 자신이 처리한 쓰기 변경 사항을 다른 리더들에게도 전달한다. (다른 말로는 **master–master replication, active/active replication**이라고도 한다.)

## 2.1 멀티 리더 복제의 사용 사례

**단일 데이터센터 내에서 멀티 리더를 쓰는 것은 복잡성에 비해 이점이 적다.** 그러나 일부 상황에서는 적절하다.

### 2.1.1 **멀티 데이터센터 운영**

- 여러 데이터센터에 복제본을 두는 경우, 리더 기반 복제에서는 반드시 하나의 데이터센터가 리더가 되어야 하며 모든 쓰기는 그곳을 거쳐야 한다.
- **멀티 리더 구성에서는 각 데이터센터마다 리더를 둘 수 있다.**
    - 데이터센터 내부에서는 일반적인 리더-팔로워 복제를 사용.
    - 데이터센터 간에는 각 리더가 서로에게 변경 사항을 비동기 복제.

2.1.1 내용을 기반으로 각각 장/단을 비교하면 아래와 같음.

- **성능**: 단일 리더에서는 모든 쓰기가 인터넷을 통해 리더 데이터센터로 가야 하지만, 멀티 리더는 로컬에서 처리하고 나중에 비동기로 전파.
- **데이터센터 장애 허용**: 단일 리더는 리더 데이터센터가 죽으면 장애 → 멀티 리더는 각 데이터센터가 독립적으로 계속 운영 가능.
- **네트워크 문제 내성**: 데이터센터 간 연결은 불안정할 수 있음. 단일 리더는 문제에 취약하지만, 멀티 리더는 비동기 복제로 어느 정도 견딜 수 있다.

## 2.2 쓰기 충돌 처리 (Handling Write Conflicts)

<img width="441" height="239" alt="image" src="https://github.com/user-attachments/assets/d1e5760f-e2a1-4825-a80c-533b5c2f615f" />


멀티 리더 복제의 가장 큰 문제는 **동일한 데이터가 동시에 수정될 수 있다는 것**이다.

- 예: 위키 페이지 제목을 사용자 1은 A→B로, 사용자 2는 A→C로 동시에 수정.
- 각자의 리더에는 반영되지만, **동기화될 때 충돌 발생.**
- 단일 리더 복제에서는 발생하지 않는 문제.

### 2.2.1 충돌 감지

- **동기식 검출**: 모든 리더에 쓰기가 복제될 때까지 기다렸다가 사용자에게 성공 여부 반환. (단, 멀티 리더의 장점 상실)
- **비동기식 검출**: 대부분 멀티 리더는 이 방식. 하지만 충돌 발견이 늦고 사용자가 이미 다른 작업을 진행했을 수 있음.

### 2.2.2 충돌 회피 (Conflict Avoidance)

- 가능한 한 **특정 레코드의 모든 쓰기를 같은 리더에서 처리**하도록 보장.
    - 예: 특정 사용자의 데이터는 항상 같은 데이터센터로 라우팅.

### 2.2.3 일관된 상태 수렴 (Converging to Consistent State)

- 단일 리더는 마지막 쓰기가 승리.
- 멀티 리더에서는 순서가 달라 불일치가 발생할 수 있음.
- 따라서 모든 복제본이 최종적으로 동일한 값에 도달해야 한다. → 데이터베이스는 수렴 방식으로 충돌을 해소해야 한다.
- 수렴 방식의 여러 방법
    - **고유 ID 부여 + 승자 선택**
        - 각 쓰기에 고유 ID(타임스탬프, 무작위 수, UUID, key+value 해시 등)를 부여.
        - 가장 큰 ID를 가진 쓰기를 “승자(winner)”로 선택하고 나머지는 폐기.
        - 흔히 **LWW (Last Write Wins)** 라고 부름.
        - 단순하고 인기 있지만, 데이터 손실 위험이 크다.
    - 복제본 ID 우선순위
        - 각 복제본에도 고유 ID를 부여.
        - 더 높은 ID를 가진 복제본에서 발생한 쓰기가 항상 우선권을 갖도록 함.
        - 마찬가지로 데이터 손실이 발생할 수 있음.
    - 값 병합
        - 충돌난 값을 규칙적으로 합침.
        - 예: 사전순으로 정렬 후 연결 → “B/C” 같은 결과.
        - 상황에 따라 응용 로직이 필요.
    - 명시적 충돌 기록
        - 충돌 자체를 데이터 구조로 저장.
        - 애플리케이션이 나중에 사용자에게 알려주거나, 별도 로직으로 해결.
        - 예: CouchDB 같은 시스템이 이 방식을 채택.

## 2.3 사용자 정의 충돌 해소 로직

다중 리더 복제 도구들은 보통 **애플리케이션 코드로 충돌 해소 로직**을 작성할 수 있도록 지원한다.

### 2.3.1 쓰기 수행 중 해소

- DB 시스템이 충돌을 감지하면 곧바로 충돌 핸들러를 호출.
- 일반적으로 사용자에게 충돌 상황을 보여주지 않고, **백그라운드 프로세스에서 빠르게 실행**.

### 2.3.2 읽기 수행 중 해소

- 충돌 발생 시, 여러 버전의 데이터를 저장.
- 데이터를 읽을 때 애플리케이션에 여러 버전이 전달됨.
- 애플리케이션이 사용자에게 충돌 내용을 보여주거나 자동으로 해소.
- 해소된 결과는 DB에 다시 기록.

## 2.4 자동 충돌 해소

- **CRDT (Conflict-Free Replicated Datatypes)**
    - Set, Map, 정렬 목록, 카운터 같은 데이터 구조를 대상으로 함.
    - 여러 사용자가 동시에 편집해도 자동으로 합리적인 결과로 수렴.
    - 예: Riak 2.0에 일부 구현.
- **병합 가능한 영속 데이터 구조 (Mergeable Persistent Data Structures)**
    - Git 버전 관리와 유사.
    - 명시적 히스토리 기록 + 삼중 병합 함수(three-way merge).
    - CRDT는 이중 병합(two-way merge) 방식.
- **운영 변환 (Operational Transformation, OT)**
    - 협업 편집 애플리케이션(Etherpad, Google Docs)에서 사용.
    - 텍스트 문서나 정렬된 리스트 같은 항목의 **동시 편집 충돌 해결**에 적합.

## 2.5 다중 리더 복제 토폴로지

**복제 토폴로지**란 한 노드에서 다른 노드로 쓰기 변경사항을 전달하는 통신 경로를 의미한다.

- 리더가 2개 이상이면 다양한 토폴로지가 가능
    
    <img width="416" height="132" alt="image" src="https://github.com/user-attachments/assets/95546af1-2dae-4210-9d2f-9ab73fcd8a02" />

    
- **원형 토폴로지 (Circular Topology)**
    - 각 노드가 한 노드로부터 쓰기를 받아 다음 노드에 전달.
    - MySQL 기본 방식.
- **별 모양 토폴로지 (Star Topology)**
    - 지정된 루트 노드가 모든 다른 노드로 쓰기를 전달.
    - 트리 형태로 확장 가능.
- **전체 연결 토폴로지 (All-to-All Topology)**
    - 모든 리더가 다른 모든 리더에 직접 쓰기를 전달.
    - 메시지가 여러 경로를 따라 이동할 수 있기 때문에, 단일 장애 지점을 피할 수 있다. 즉, 내결함성이 가장 좋다.
    - 가장 일반적이지만 네트워크 비용이 큼.

**단점**

- circular, star
    - 하나의 노드 장애가 전체 흐름에 영향을 줌.
    - 장애 시 재설정 필요 → 운영 부담.
- all-to-all
    - 네트워크 속도 차이로 인해 일부 메시지가 추월할 수 있음.
    - 쓰기 순서가 꼬이는 문제가 발생할 수 있음.
        
        <img width="434" height="231" alt="image" src="https://github.com/user-attachments/assets/7be11ecb-12cd-4b3e-8832-ea65119f3d8a" />

        
    - 네트워크 지연, 경로 차이로 인해 복제 메시지 도착 순서가 뒤바뀜.
    - 단순히 **타임스탬프**만으로는 신뢰할 수 없음 → 노드 간 시계 불일치 가능.
    - ⇒ **버전 벡터 (Version Vectors)** 사용
        - 각 이벤트의 인과 관계를 추적하여 정확한 순서 보장.
        - 하지만 많은 다중 리더 시스템에서 제대로 구현되지 않음.

# 3. 리더 없는 복제

리더 없는 복제는 **클라이언트가 여러 복제 서버에 직접 쓰기 요청**을 전송한다. 중앙 집중형이 아닌 독립적으로 요청하는 방식.

- 리더 기반 방식처럼 중앙 노드가 쓰기 순서를 조정하지 않고, 모든 복제 서버가 독립적으로 요청을 처리할 수 있다.
- **예시**: 아마존의 Dynamo 시스템, 이를 기반으로 한 Cassandra, Voldemort 등 오픈소스 데이터스토어 → 이런 계열을 **다이나모 스타일**이라 부름.

## 3.1 노드 장애 시 쓰기 처리

- 리더 기반 복제는 특정 리더에 장애가 생기면 장애 복구 후에야 쓰기 처리가 가능.
- 리더 없는 복제에서는 복제 서버 중 일부만 정상 동작해도 쓰기를 진행할 수 있음.
- **예시 상황**:
    
    <img width="515" height="256" alt="image" src="https://github.com/user-attachments/assets/03e11695-495e-4f73-89ea-2730d066a57d" />

    
    - 복제 서버 3대 중 1대가 다운되더라도, 나머지 2대가 쓰기를 성공하면 전체적으로 쓰기 성공으로 간주.
    - 이후 장애 서버가 복구되면 누락된 데이터를 다시 동기화.

## 3.2 읽기 복구 (Read Repair) & 안티 엔트로피 (Anti-Entropy)

- **읽기 복구(Read Repair)**
    - 클라이언트가 여러 복제 서버에 동시에 읽기 요청을 보내, 최신 값과 오래된 값을 비교.
    - 오래된 값을 가진 서버에는 최신 값으로 갱신 → 읽기 과정에서 점진적으로 데이터 복구.
- **안티 엔트로피(Anti-Entropy)**
    - 백그라운드 프로세스를 통해 주기적으로 서버 간 데이터 차이를 비교하고, 누락된 데이터를 동기화.
    - 복제 로그 방식과 달리 특정 순서 보장이 없으며, 장기적으로 데이터 일관성을 맞추는 역할.

## 3.3 정족수 합의 (Quorum)

<img width="421" height="213" alt="image" src="https://github.com/user-attachments/assets/0b94cc40-302d-4b3c-8edc-261d18d65a48" />


- 리더 없는 복제에서 **정족수(quorum) 방식**으로 읽기/쓰기를 보장.
- **n** = 복제 서버 개수, **w** = 쓰기 확인 최소 개수, **r** = 읽기 확인 최소 개수.
- 조건: **w + r > n** 이면 항상 최신 데이터를 읽을 수 있음.
- 예시:
    - n=3, w=2, r=2 → 최소 2대에 쓰기가 성공하고, 읽을 때도 2대 이상 확인하므로 데이터 무결성 확보.
    - n=5, w=3, r=3 → 노드 2대가 고장나도 정상 동작 가능.

## 3.4 정족수 일관성

- 정족수 일관성은 **최신 값 반환을 어느 정도 보장**하지만, 여러 예외 상황으로 인해 절대적 보장은 불가능.
- 최신성 모니터링 및 지표화가 필요하며, 운영 측면에서 **“얼마나 최신성에서 벗어나는지”를 추적**해야 함.
- 느슨한 정족수와 암시된 핸드오프는 **가용성 확보에 유리**하지만 **일관성 약화**라는 트레이드오프 존재.
- 다중 데이터센터 환경에서는 리더 없는 복제가 더 안정적이며, **지역 내 정족수 확인 + 원격 데이터센터 비동기 동기화** 방식이 일반적.
