# 일관성과 합의

이 장에서는 장애에 강한 분산 시스템을 구축하기 위한 몇 가지 알고리즘과 프로토콜 사례를 살펴보겠습니다. <br>
장애에 강한 시스템을 만드는 가장 좋은 방법은 유용한 보장을 제공하는 범용 추상화를 찾아 한 번 구현한 뒤, 애플리케이션이 그 보장에 의존하도록 하는 것입니다. br
이는 7장에서 트랜잭션을 사용한 접근과 동일합니다. 트랜잭션을 사용하면 애플리케이션은 장애가 없다고(원자성), 다른 사람이 동시에 데이터베이스에 접근하지 않는다고(격리성), 저장 장치가 완벽히 신뢰할 수 있다고(내구성) 가정할 수 있습니다. 실제로는 장애, 경합 조건, 디스크 고장이 발생하지만, 트랜잭션 추상화가 이러한 문제를 숨겨 애플리케이션이 걱정하지 않도록 합니다.

이제 같은 흐름을 이어가며, 애플리케이션이 분산 시스템의 일부 문제를 무시할 수 있게 해 주는 추상화를 찾아보겠습니다. <br>
예를 들어, 분산 시스템에서 가장 중요한 추상화 중 하나는 합의(consensus)입니다. 즉, 모든 노드가 어떤 사항에 대해 동일하게 동의하도록 만드는 것입니다.

## 일관성 보장

데이터베이스가 어떤 복제 방식(싱글 리더, 멀티 리더, 리더리스 복제)을 사용하든 불일치는 발생합니다. <br>
대부분의 복제된 데이터베이스는 최소한 **최종적 일관성(eventual consistency)** 을 제공합니다. <br>
이는 데이터베이스에 대한 쓰기를 중단하고 어떤 특정되지 않은 시간만큼 기다리면, 결국 모든 읽기 요청이 동일한 값을 반환한다는 의미입니다. <br>
최종적 일관성의 엣지 케이스는 시스템에 장애(예: 네트워크 중단)가 있거나 높은 동시성에서만 명확해집니다.

## 선형화 가능성(Linearizability)

최종적 일관성 데이터베이스에서는 같은 시점에 서로 다른 복제본에 동일한 질문을 하면 서로 다른 답을 받을 수 있습니다. <br>
이는 혼란스럽습니다. 데이터베이스가 복제본이 하나뿐인 것처럼(즉, 데이터가 하나의 사본만 있는 것처럼) 보이게 만들 수 있다면 어떨까요? <br>
그러면 모든 클라이언트가 동일한 데이터 뷰를 갖게 되고, 복제 지연에 대해 걱정하지 않아도 됩니다. 이것이 _선형화 가능성_ 의 아이디어입니다(원자적 일관성, 강한 일관성, 즉시 일관성, 외부 일관성이라고도 합니다).

기본 아이디어는 시스템을 데이터가 단 하나의 사본만 존재하고, 그 위의 모든 연산이 원자적으로 수행되는 것처럼 보이게 만드는 것입니다. <br>
이 보장을 통해 실제로는 여러 복제본이 있더라도, 애플리케이션은 이를 신경 쓸 필요가 없습니다.

<img width="638" height="493" alt="Image" src="https://github.com/user-attachments/assets/7ed926f8-f33c-45db-8528-25bc46fe2d56" />

선형화 가능성의 요구사항은 연산 마커를 이어 주는 선이 시간에 따라 항상 앞으로(왼쪽에서 오른쪽으로) 진행하고, 결코 뒤로 가지 않아야 한다는 것입니다. 이 요구사항은 최신성(recency) 보장을 제공합니다.

### 선형화 가능성에 의존하기

선형화 가능성이 시스템을 올바르게 동작하도록 만드는 데 중요한 요구사항인 몇 가지 영역은 다음과 같습니다.

- 잠금과 리더 선출  
  싱글 리더 복제를 사용하는 시스템은 실제로 리더가 하나뿐임을 보장해야 하며, 여러 리더가 존재하는 ‘스플릿 브레인’ 상황은 피해야 합니다. 리더를 선출하는 한 가지 방법은 잠금을 사용하는 것입니다. 시작하는 모든 노드는 잠금을 획득하려 시도하고, 성공한 노드가 리더가 됩니다. 이 잠금이 어떻게 구현되든, 반드시 선형화 가능해야 합니다. 모든 노드가 어느 노드가 잠금을 소유하는지에 대해 일치된 견해를 가져야 하며, 그렇지 않으면 무용지물입니다.

- 제약과 고유성(유니크) 보장  
  데이터베이스에서는 고유성 제약이 흔합니다. 예를 들어, 사용자 이름이나 이메일 주소는 한 명의 사용자만을 고유하게 식별해야 합니다. 쓰기 시점에 이 제약을 강제하여 오류를 반환하려면, 선형화 가능성이 필요합니다.

- 채널 간 타이밍 종속성  
  여기 문제는 웹 서버와 리사이저 사이에 파일 저장소와 메시지 큐라는 두 가지 서로 다른 통신 채널이 존재하기 때문에 발생합니다. 선형화 가능성이 제공하는 최신성 보장이 없다면, 이 두 채널 간에 경쟁 조건(race condition)이 발생할 수 있습니다.  
  선형화 가능성은 이 경쟁 조건을 피하는 유일한 방법은 아니지만, 가장 이해하기 쉽습니다. 추가 통신 채널을 제어할 수 있다면, 더 복잡성을 감수하는 대가로 다른 접근법을 사용할 수도 있습니다.

### 선형화 가능한 시스템 구현

시스템을 장애에 강하게 만드는 가장 일반적인 접근법은 복제를 사용하는 것입니다. <br>
다음 방식들이 선형화 가능하게 만들 수 있는지 비교해 보겠습니다.

- 싱글 리더 복제(잠재적으로 선형화 가능)  
  리더에서 읽거나, 동기적으로 업데이트되는 팔로워에서 읽는다면 선형화 가능할 잠재력이 있습니다. 그러나 모든 싱글 리더 데이터베이스가 실제로 선형화 가능한 것은 아닙니다. 설계상(예: 스냅샷 격리를 사용) 또는 동시성 버그로 인해 선형화 가능하지 않을 수 있습니다.

- 합의 알고리즘(선형화 가능)  
  합의 프로토콜은 스플릿 브레인과 오래된 복제본을 방지하는 장치를 포함하고 있어, 선형화 가능한 스토리지를 안전하게 구현하기 쉽습니다.

- 멀티 리더 복제(선형화 불가능)  
  여러 노드에서 동시 쓰기를 처리하고 다른 노드로 비동기 복제를 수행하기 때문에 선형화 가능성을 만족시키는 것이 불가능합니다.

- 리더리스 복제(아마도 선형화 불가능)  
  일부는 “강한 일관성”을 얻기 위해 정족수(쿼럼) 읽기/쓰기(w + r > n)를 요구하면 된다고 주장하지만, 이는 사실이 아닙니다.

### 선형화 가능성의 비용

분리된(연결이 끊긴) 클라이언트 문제는 싱글 리더 또는 멀티 리더 복제의 결과만이 아닙니다. <br>
어떤 방식으로 구현되든, 모든 선형화 가능한 데이터베이스가 겪는 문제입니다. <br>
또한 이 이슈는 멀티 데이터센터 배치에만 국한되지 않으며, 하나의 데이터센터 내에서도 신뢰할 수 없는 네트워크에서는 발생할 수 있습니다. 트레이드오프는 다음과 같습니다.

- 애플리케이션이 선형화 가능성을 요구하고, 어떤 복제본들이 네트워크 문제로 다른 복제본들과 분리되어 있다면, 분리된 복제본은 분리된 동안 요청을 처리할 수 없습니다. 네트워크 문제가 해결될 때까지 기다리거나 오류를 반환해야 합니다. 어느 경우든, 해당 복제본은 **가용하지 않게(unavailable)** 됩니다.
- 애플리케이션이 선형화 가능성을 요구하지 않는다면, 각 복제본이 다른 복제본과 분리되어 있더라도 독립적으로 요청을 처리할 수 있도록 작성할 수 있습니다(예: 멀티 리더). 이 경우 네트워크 문제 상황에서도 애플리케이션은 가용성을 유지할 수 있지만, 동작은 선형화 가능하지 않습니다.

따라서 선형화 가능성을 요구하지 않는 애플리케이션은 네트워크 문제에 더 잘 견딜 수 있습니다. 이 통찰은 일반적으로 **CAP 정리**로 알려져 있습니다. <br>
선형화 가능성은 유용한 보장이지만, 실제로 선형화 가능한 시스템은 놀랍도록 적습니다. 많은 분산 데이터베이스는 선형화 가능한 보장을 제공하지 않는데, 이는 주로 내고장성보다는 성능 향상을 위해서입니다. <br>
선형화 가능성은 느립니다 — 그리고 이는 네트워크 장애 시에만이 아니라 항상 참입니다.

## 순서 보장

앞서, 선형화 가능한 레지스터는 데이터 사본이 하나뿐인 것처럼 동작하며, 모든 연산이 어떤 한 시점에 원자적으로 발생하는 것처럼 보인다고 했습니다. 이 정의는 연산이 잘 정의된 순서로 실행됨을 의미합니다.

- 5장에서 싱글 리더 복제에서 리더의 주요 목적은 복제 로그에서 쓰기의 순서를 결정하는 것이었음을 보았습니다. 즉, 팔로워가 그 쓰기를 적용하는 순서입니다.
- 7장의 직렬성(serializability)은 트랜잭션이 어떤 순차적 순서로 실행된 것처럼 보이도록 보장하는 것입니다.
- 8장에서 논의한 분산 시스템의 타임스탬프와 시계(clock) 사용 역시 두 개의 쓰기 중 어느 것이 더 나중에 발생했는지 결정하기 위해 순서를 도입하려는 또 다른 시도입니다.

결국, 순서(ordering), 선형화 가능성, 그리고 합의(consensus) 사이에는 깊은 연결이 존재합니다.

### 순서와 인과성

인과성(causality)은 사건에 순서를 부여합니다. <br>
원인이 결과보다 먼저 오고, 메시지는 수신되기 전에 송신되고, 질문은 답보다 먼저 옵니다. <br>
이렇게 인과적으로 종속된 연산들의 연결은 시스템 내 인과적 순서를 정의합니다. 즉, 무엇이 무엇보다 먼저 일어났는지를 나타냅니다.

전체 순서(total order)와 부분 순서(partial order)의 차이는 서로 다른 데이터베이스 일관성 모델에 반영됩니다.

- 선형화 가능성  
  선형화 가능한 시스템에서는 연산의 **전체 순서**가 있습니다. 시스템이 데이터 사본이 하나뿐이며 모든 연산이 원자적으로 수행되는 것처럼 동작한다면, 어떤 두 연산에 대해서도 항상 어느 것이 먼저 발생했는지 말할 수 있어야 합니다.

- 인과성  
  두 연산이 서로 먼저-나중 관계가 없다면, 우리는 그 둘이 동시적(concurrent)이라고 말했습니다. 달리 말해, 두 사건은 인과적으로 관련되어 있다면(하나가 다른 것보다 먼저 발생했다면) 순서가 정해지고, 동시적이라면 비교 불가능합니다. 이는 인과성이 **부분 순서**를 정의한다는 의미입니다. 어떤 연산들은 서로에 대해 순서가 정해지지만, 어떤 것들은 비교할 수 없습니다.

선형화 가능성은 인과성을 **함의**합니다. 선형화 가능한 시스템은 인과성을 올바르게 보존합니다. <br>
특히, 시스템에 여러 통신 채널이 있는 경우에도, 선형화 가능성은 서로 다른 구성 요소 사이에서 타임스탬프를 전달하는 등의 특별한 조치를 하지 않아도 인과성이 자동으로 보존되도록 합니다.

시스템은 선형화 가능하게 만드는 성능 저하를 겪지 않으면서도 인과적 일관성(causal consistency)을 가질 수 있습니다(특히, CAP 정리는 적용되지 않습니다). <br>
실제로 인과적 일관성은 네트워크 지연으로 인해 느려지지 않으며, 네트워크 장애 상황에서도 가용성을 유지하는 **가장 강한** 일관성 모델입니다. <br>
많은 경우, 선형화 가능성이 필요한 것처럼 보이는 시스템도 실제로는 인과적 일관성만 필요하며, 이 방식은 더 효율적으로 구현할 수 있습니다. <br>
이러한 관찰을 바탕으로, 연구자들은 인과성을 보존하면서도 최종적 일관성 시스템과 유사한 성능과 가용성 특성을 갖는 새로운 유형의 데이터베이스를 탐구하고 있습니다.

## 분산 트랜잭션과 합의

합의(consensus)는 분산 컴퓨팅에서 가장 중요하고 근본적인 문제 중 하나입니다. 목표는 단순히 여러 노드가 어떤 사항에 대해 **동의**하도록 만드는 것입니다.

### 리더 선출과 원자적 커밋

노드들이 동의해야 하는 상황은 여러 가지가 있습니다.

- 리더 선출  
  잘못된 페일오버를 피하기 위해 합의가 중요합니다. 잘못되면 두 노드가 모두 자신을 리더라고 믿는 스플릿 브레인 상황이 발생할 수 있습니다.

- 원자적 커밋  
  트랜잭션의 원자성을 유지하려면 모든 노드가 트랜잭션 결과에 동의해야 합니다. 모두가 중단/롤백하거나 모두가 커밋해야 합니다. 이러한 합의 인스턴스는 **원자적 커밋** 문제로 알려져 있습니다.

### 2단계 커밋(2PC)

단일 노드에서는 트랜잭션 커밋이 디스크에 데이터가 내구적으로 쓰이는 **순서**에 결정적으로 의존합니다. <br>
먼저 데이터, 그다음 커밋 기록입니다. 트랜잭션이 커밋될지 중단될지를 결정하는 핵심 순간은 디스크가 커밋 기록 쓰기를 완료하는 순간입니다.

트랜잭션 커밋은 **취소 불가능**해야 합니다. 이미 커밋된 트랜잭션을 마음대로 바꾸어 소급해 중단할 수는 없습니다. <br>
그 이유는, 데이터가 커밋되면 다른 트랜잭션에 보이게 되고, 다른 클라이언트가 그 데이터에 의존하기 시작할 수 있기 때문입니다. <br>
이 원칙이 **읽기 커밋(Read Committed) 격리**의 기초를 이룹니다.

2단계 커밋은 여러 노드에 걸친 트랜잭션의 **원자적 커밋**을 달성하기 위한 알고리즘입니다. <br>
즉, 모든 노드가 커밋하거나 모든 노드가 중단하도록 보장합니다. 이는 분산 데이터베이스에서의 고전적인 알고리즘입니다. <br>
2PC는 일부 데이터베이스에서 내부적으로 사용되며, XA 트랜잭션 형태로 애플리케이션에 제공되기도 합니다.

2PC는 단일 노드 트랜잭션에는 일반적으로 등장하지 않는 새로운 구성요소를 사용합니다. <br>
바로 **코디네이터**(트랜잭션 매니저라고도 함)입니다. <br>
코디네이터는 요청하는 애플리케이션 프로세스와 동일한 프로세스 내 라이브러리로 구현될 수 있으며, 별도의 프로세스나 서비스로 구현될 수도 있습니다.

2PC 트랜잭션은 애플리케이션이 여러 데이터베이스 노드에서 데이터를 읽고 쓰는 일반적인 동작으로 시작합니다. <br>
이러한 데이터베이스 노드를 트랜잭션의 **참여자(participant)** 라고 부릅니다. <br>
애플리케이션이 커밋할 준비가 되면, 코디네이터가 1단계를 시작합니다. 각 노드에 준비 요청(prepare)을 보내 커밋할 수 있는지 묻습니다. 코디네이터는 참여자들의 응답을 추적합니다.

- 모든 참여자가 “예”라고 응답하여 커밋 준비가 되었음을 나타내면, 코디네이터는 2단계에서 커밋 요청을 보내고 실제 커밋이 이루어집니다.
- 참여자 중 누군가가 “아니오”라고 응답하면, 코디네이터는 2단계에서 모든 노드에 중단(abort) 요청을 보냅니다.

이 프로토콜에는 두 가지 중요한 **되돌릴 수 없는 지점(point of no return)** 이 있습니다. <br>
참여자가 “예”라고 투표하면, 나중에 반드시 커밋할 수 있다고 약속하는 것입니다(비록 코디네이터가 여전히 중단을 선택할 수 있지만). <br>
그리고 코디네이터가 결정을 내리면, 그 결정은 취소 불가능합니다. 이러한 약속이 2PC의 원자성을 보장합니다.

#### 코디네이터 장애

코디네이터가 준비 요청을 보내기 전에 장애가 발생하면, 참여자는 트랜잭션을 안전하게 중단할 수 있습니다. <br>
그러나 참여자가 준비 요청을 받고 “예”로 투표한 이후에는 더 이상 일방적으로 중단할 수 없습니다. <br>
코디네이터로부터 트랜잭션이 커밋되었는지 중단되었는지 응답을 들을 때까지 기다려야 합니다. <br>
이 시점에서 코디네이터가 크래시하거나 네트워크 장애가 발생하면, 참여자는 기다리는 것 외에 아무것도 할 수 없습니다. <br>
이러한 상태의 참여자 트랜잭션을 **의심 상태(in doubt, uncertain)** 라고 부릅니다.

2PC가 완료되는 유일한 방법은 코디네이터가 복구되기를 기다리는 것입니다. <br>
이 때문에, 코디네이터는 참여자에게 커밋 또는 중단 요청을 보내기 전에 자신의 커밋 또는 중단 결정을 디스크의 트랜잭션 로그에 기록해 두어야 합니다. <br>
코디네이터가 복구되면, 트랜잭션 로그를 읽어 모든 의심 상태 트랜잭션의 상태를 결정합니다. 코디네이터 로그에 커밋 기록이 없는 모든 트랜잭션은 중단됩니다. <br>
따라서 2PC의 커밋 지점(commit point)은 코디네이터에서의 일반적인 단일 노드 원자적 커밋으로 귀결됩니다.

2단계 커밋은 코디네이터가 복구될 때까지 대기 상태가 될 수 있기 때문에, **블로킹(blocking)** 원자적 커밋 프로토콜이라고 불립니다.

### 실제 분산 트랜잭션

특히 2단계 커밋으로 구현된 분산 트랜잭션은 엇갈린 평판을 가지고 있습니다. <br>
한편으로는 다른 방식으로 달성하기 어려운 중요한 안전 보장을 제공하는 것으로 여겨지지만, 다른 한편으로는 운영 문제를 야기하고 성능을 떨어뜨리며, 약속한 만큼 제공하지 못한다고 비판받습니다. <br>
많은 클라우드 서비스가 분산 트랜잭션을 구현하지 않기로 선택하는데, 이는 그들이 야기하는 운영상의 문제 때문입니다.

서로 매우 다른 두 가지 유형의 분산 트랜잭션이 종종 혼동됩니다.

- 데이터베이스 내부 분산 트랜잭션  
  복제와 파티셔닝을 표준 구성으로 사용하는 일부 분산 데이터베이스는 데이터베이스 노드들 간의 내부 트랜잭션을 지원합니다. 이 경우 트랜잭션에 참여하는 모든 노드는 동일한 데이터베이스 소프트웨어를 실행합니다.

- 이기종(heterogeneous) 분산 트랜잭션  
  이기종 트랜잭션에서는 참여자가 둘 이상 서로 다른 기술입니다. 예를 들어, 서로 다른 벤더의 두 데이터베이스 또는 메시지 브로커와 같은 비(非) 데이터베이스 시스템일 수 있습니다. 이러한 시스템들에 걸친 분산 트랜잭션은 내부 구현이 완전히 다를지라도 **원자적 커밋**을 보장해야 합니다.

데이터베이스 내부 트랜잭션은 다른 어떤 시스템과도 호환될 필요가 없으므로, 어떤 프로토콜이든 사용할 수 있고 해당 기술에 특화된 최적화를 적용할 수 있습니다. <br>
그 결과, 데이터베이스 내부 분산 트랜잭션은 종종 꽤 잘 작동할 수 있습니다. 반면, 이기종 기술에 걸친 트랜잭션은 훨씬 더 어려운 과제를 안고 있습니다.

### XA 트랜잭션

X/Open **XA**(eXtended Architecture의 약자)는 이기종 기술에 걸친 2단계 커밋을 구현하기 위한 표준입니다. <br>
XA는 많은 전통적인 관계형 데이터베이스(포스트그레스큐엘, 마이SQL, DB2, SQL 서버, 오라클 등)와 메시지 브로커(ActiveMQ, HornetQ, MSMQ, IBM MQ 등)에서 지원됩니다.

XA는 네트워크 프로토콜이 아니라, 트랜잭션 코디네이터와 인터페이스하기 위한 C API에 불과합니다. <br>
XA는 애플리케이션이 참여 데이터베이스나 메시징 서비스와 통신하기 위해 네트워크 드라이버 또는 클라이언트 라이브러리를 사용한다고 가정합니다.

## 내결함성 합의(Consensus)

비공식적으로 합의는 여러 노드가 어떤 사항에 대해 동의하도록 만드는 것을 의미합니다. <br>
예를 들어, 여러 사람이 동시에 비행기의 마지막 좌석을 예약하려고 시도한다면, 합의 알고리즘을 사용하여 서로 양립할 수 없는 이러한 연산들 중 어느 것이 승자가 될지 결정할 수 있습니다.

합의 문제는 일반적으로 다음과 같이 형식화됩니다. 하나 이상의 노드가 값을 제안(propose)할 수 있으며, 합의 알고리즘은 그 값들 중 하나를 결정(decide)합니다. <br>
이 형식에서, 합의 알고리즘은 다음 속성을 만족해야 합니다.

- **균일한 합의(Uniform agreement)**: 두 노드가 서로 다른 결정을 내리지 않습니다.
- **무결성(Integrity)**: 어떤 노드도 두 번 결정하지 않습니다.
- **정당성(Validity)**: 노드가 값 v를 결정했다면, v는 어떤 노드에 의해 제안된 값입니다.
- **종결성(Termination)**: 크래시하지 않은 모든 노드는 결국 어떤 값을 결정합니다.

균일한 합의와 무결성은 합의의 핵심 아이디어를 정의합니다. 모든 노드가 동일한 결과를 결정하고, 일단 결정하면 마음을 바꿀 수 없습니다. <br>
정당성은 대부분 자명한(무의미한) 해법을 배제하기 위해 존재합니다. 예를 들어, 항상 null을 결정하는 알고리즘은 합의와 무결성은 만족하지만, 정당성은 만족하지 못합니다.

종결성은 내고장성의 아이디어를 형식화합니다. 본질적으로, 합의 알고리즘은 영원히 아무것도 하지 않고 앉아 있을 수 없다는 것을 의미합니다. <br>
즉, **진행(progress)** 을 해야 합니다. 일부 노드가 실패하더라도, 다른 노드들은 여전히 결론에 도달해야 합니다(종결성은 **활성(liveness)** 속성이며, 다른 세 가지는 **안전(safety)** 속성입니다). <br>
어떤 합의 알고리즘이라도 종결성을 보장하려면 최소한 과반수의 노드가 올바르게 동작해야 합니다. 그 과반수는 안전하게 **정족수(quorum)** 를 형성할 수 있습니다.

### 합의의 한계

합의 알고리즘은 분산 시스템에 엄청난 발전을 가져왔습니다. 모든 것이 불확실한 시스템에서 합의는 구체적인 안전 속성(합의, 무결성, 정당성)을 제공하며, 그럼에도 내고장성을 유지합니다(대다수 노드가 동작하고 도달 가능하기만 하면 진행할 수 있음). <br>
합의는 **총 순서 브로드캐스트(total order broadcast)** 를 제공하며, 따라서 **선형화 가능한 원자적 연산**을 내고장적으로 구현할 수도 있습니다.

몇 가지 한계는 다음과 같습니다.

- 합의의 이점(위에 열거한)은 비용을 수반합니다.
- 값이 결정되기 전에 노드들이 제안에 대해 투표하는 과정은 일종의 **동기식 복제**이며, 페일오버 시 커밋된 데이터의 손실로 이어질 수 있습니다.
- 합의 시스템은 항상 **엄격한 과반수**를 필요로 합니다.
- 대부분의 합의 알고리즘은 투표에 참여하는 노드 집합이 **고정**되어 있다고 가정합니다. 즉, 클러스터에서 노드를 마음대로 추가하거나 제거할 수 없습니다(정적 멤버십 vs 동적).
- 합의 시스템은 일반적으로 **타임아웃**에 의존해 장애 노드를 감지하기 때문에, 잦은 리더 선출이 발생하면 성능이 크게 저하됩니다.
- 합의 알고리즘은 특히 **네트워크 문제**에 민감합니다.

## 멤버십 및 코디네이션 서비스

ZooKeeper나 etcd 같은 프로젝트는 종종 “분산 키-값 저장소” 또는 “코디네이션 및 구성 서비스”로 설명됩니다. <br>
이러한 서비스의 API는 데이터베이스와 아주 비슷합니다. 주어진 키의 값을 읽고 쓸 수 있으며, 키들을 순회(iterate)할 수 있습니다. <br>
그렇다면 이들이 기본적으로 데이터베이스라면, 왜 합의 알고리즘을 구현하는 데 그토록 공을 들일까요? 다른 종류의 데이터베이스와 무엇이 다를까요?

이를 이해하려면, ZooKeeper 같은 서비스가 어떻게 사용되는지 간단히 살펴보는 것이 도움이 됩니다. <br>
애플리케이션 개발자로서, 직접 ZooKeeper를 사용할 일은 드물 것입니다. ZooKeeper는 범용 데이터베이스로는 적합하지 않기 때문입니다. <br>
대신, 다른 프로젝트를 통해 간접적으로 의존하게 될 가능성이 큽니다. 예를 들어, HBase, Hadoop YARN, OpenStack Nova, Kafka 등은 모두 백그라운드에서 ZooKeeper가 실행되는 것에 의존합니다.

ZooKeeper와 etcd는 메모리에 완전히 담길 수 있는 **소량의 데이터**를 저장하도록 설계되었습니다(내구성을 위해 디스크에 쓰기는 합니다). <br>
따라서 애플리케이션의 모든 데이터를 여기에 저장하고 싶지는 않을 것입니다. 그 소량의 데이터는 **내고장성 총 순서 브로드캐스트 알고리즘**을 사용하여 모든 노드에 복제됩니다. <br>
앞서 논의했듯이, 총 순서 브로드캐스트는 데이터베이스 복제에 필요한 것입니다. 각 메시지가 데이터베이스에 대한 쓰기를 나타내면, 동일한 쓰기를 동일한 순서로 적용함으로써 복제본 간의 일관성을 유지할 수 있습니다.

ZooKeeper 등은 1980년대로 거슬러 올라가는 **멤버십 서비스** 연구의 오랜 역사 속에서 이해될 수 있으며, 이는 항공 교통 관제 같은 고신뢰 시스템 구축에 중요했습니다. <br>
멤버십 서비스는 현재 **클러스터의 활성 멤버 노드가 누구인지**를 결정합니다. 8장 전반에서 보았듯이, **무한한 네트워크 지연** 때문에 다른 노드가 장애인지 신뢰성 있게 감지하는 것은 불가능합니다. <br>
그러나 장애 감지를 합의와 결합하면, 노드들은 **어떤 노드를 살아 있는 것으로 간주할지**에 대해 합의할 수 있습니다. <br>
합의에 의해 어떤 노드가 잘못 죽은 것으로 선언될 수도 있습니다(실제로는 살아 있음에도). 그럼에도, 시스템이 현재 멤버십을 구성하는 노드들에 대해 **일치된 합의**를 갖는 것은 매우 유용합니다.
