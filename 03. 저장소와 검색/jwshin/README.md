# 3장. 저장소와 검색

- “데이터베이스는 저장하고 나중에 다시 찾도록 제공한다.”
- 3장은 이 단순한 문장을 실제로 성취하는 저장 엔진과 색인 구조를 책의 흐름대로 설명한다.
- 핵심 축은 로그 구조(LSM/SSTable) 와 페이지 지향(B-트리) 이며, 이어서 보조·전문·공간 색인, 인메모리 DB, OLTP/OLAP 분리와 컬럼 지향 웨어하우스까지 연결한다.
- 2장에서 다룬 “클라이언트가 DB에 데이터를 제공하는 방식”을 넘어, 이번 장은 DB 내부에서 데이터를 어떻게 저장·검색하는지를 다룬다.
-	특히 워크로드별(트랜잭션/분석)로 최적화된 저장소와 색인은 다르며, 설계 선택은 쓰기·읽기·공간·운영 복잡도 간의 트레이드오프다.

## 가장 단순한 DB에서 보는 본질: Append-Only 로그와 인덱스의 필요

```sql
# append-only 저장
# 쓰기: append-only
db_set () { echo "$1,$2" >> database; }

# 읽기: 선형 검색(가장 최근 값)
db_get () { grep "^$1," database | sed -e "s/^$1,//" | tail -n 1; }
```

-	db_set은 순차 쓰기라 빠르고 단순.
-	db_get은 전체 스캔이 필요 → 데이터가 커질수록 느려짐.
-	결론: 인덱스라는 메타데이터가 필요하다. 인덱스는 “어디를 읽을지”를 알려주기 위해 쓰기·공간 비용을 기꺼이 치르는 구조다.
 
## 로그 구조 엔진의 첫걸음: 해시 색인 + 세그먼트 + 컴팩션

### 1. 해시 색인

-	메모리에 key → (segment, offset) 매핑을 둬서 점 조회를 1회 랜덤 접근으로 해결.
-	키별 최신 위치만 가리키므로, 파일에는 중복 버전이 남는다 → 컴팩션 필요.

<img width="707" height="376" alt="image" src="https://github.com/user-attachments/assets/c9b3a6ea-96db-4d33-8793-ac32f05d5993" />

### 2. 세그먼트와 컴팩션
	
- 파일을 세그먼트 단위로 나누고, 주기적으로 오래된 버전/삭제표식(툼스톤) 을 제거하는 컴팩션 수행.
- 구현 시 고려할 점:
  - 바이너리 포맷 권장(CSV는 경계/손상 복구/부분읽기 불리).
  - 레코드 길이·체크섬 포함(손상 탐지).
  - 크래시 복구: 부팅 시 세그먼트 스캔으로 인덱스 재구성.
  - 동시성: 쓰기는 계속 append, 컴팩션은 백그라운드 병합.
  - 부분적 병합 가능(최신 세그먼트 우선 탐색 등으로 읽기 비용 절감).
- 이 구조는 “쓰기 유리·점 조회 양호/범위 스캔은 약함”이라는 성격을 갖는다.

<img width="702" height="305" alt="image" src="https://github.com/user-attachments/assets/ca6276a2-59cb-490e-bfcf-eed3aad0073c" />

<img width="690" height="398" alt="image" src="https://github.com/user-attachments/assets/a8d84b97-eef5-4207-9d00-5ae66431d80d" />

### 3. 한계

- 해시 색인은 점 조회엔 최적이지만 범위 스캔엔 부적합.
-	해결 열쇠: “정렬된 불변 파일”을 쌓고 병합하는 구조 → SSTable.

## SSTable과 LSM(Log-Structured Merge) 트리

### 1. SSTable(정렬된 불변 테이블)

-	각 파일이 키로 정렬된 상태로 저장, 내부에 희소 인덱스(키→오프셋) 보유.
- 장점: 범위 스캔이 연속 I/O로 빠르고, 파일 간 정렬 병합 컴팩션이 효율적.
- 블룸 필터를 붙여 “이 파일엔 없음”을 빠르게 배제.

<img width="671" height="470" alt="image" src="https://github.com/user-attachments/assets/0d04e1d6-14ec-417c-a474-ea8dfb360ce6" />

### 2. LSM 트리의 쓰기 경로

- 메모리 테이블(균형 트리/스킵리스트)에 삽입(정렬 유지).
- 임계치 도달 시 불변 SSTable로 디스크에 flush.
- 백그라운드 컴팩션으로 중복 키 제거·파일 수 제한(크기 계층/레벨드 등).

### 3. 컴팩션 전략 두 가지

- 사이즈 계층(size-tiered): 크기 비슷한 파일끼리 단계적 병합(쓰기 유리, 읽기/공간 증폭 가능).
- 레벨드(leveled): 레벨별 “키 중복 최소화”(읽기 유리, 컴팩션 작업이 규칙·빈번).

### 4. 성능 최적화 요소

- WAL(쓰기 전 로그, redo log) 로 내구성 보장 후 memtable에 반영 → crash 시 복구.
-	파일별 블룸 필터/희소 인덱스 준비, 컴팩션 스케줄/스로틀이 꼬리 지연에 직접 영향.

##  B-트리: 페이지 지향 표준 색인

### 1. 구조

- 루트→내부→리프 페이지. 각 페이지는 정렬된 (key, pointer/value) 목록.
- 분기 계수가 커서 디스크 탐색 단계 수가 작음 → 짧고 안정적인 응답.

<img width="735" height="395" alt="image" src="https://github.com/user-attachments/assets/96485713-4649-4abb-9167-c67e817badbf" />

### 2. 갱신·무결성·동시성

- 제자리 갱신(덮어 쓰기) + 필요 시 페이지 분할/병합으로 균형 유지.
-	WAL(Write Ahead Log, Redo log)로 내구성 보장, 래치(latch) 로 페이지 단위 동시성 제어.
-	장애 시 고아 페이지 처리 등 복구 루틴 필요.

<img width="727" height="440" alt="image" src="https://github.com/user-attachments/assets/367a4227-edbc-4d34-b2f2-b31dda5c515e" />

## LSM vs B-트리

### 1. LSM의 장점
	
- 순차 쓰기 중심 → 쓰기 처리량이 큼.
- 압축/삭제 정리(컴팩션)로 디스크 공간 효율이 좋을 수 있음.
- HDD/SSD 모두에 적합(특히 SSD에서 랜덤 쓰기 회피).

### 2. LSM의 단점

-	컴팩션이 읽기와 리소스를 간섭 → 꼬리 지연(p95/p99) 상승 위험.
-	읽기 증폭(여러 파일 확인)과 캐시/FD 관리 복잡도.
-	쓰기/읽기/공간 증폭 지표(WAF/RAF/SAF) 관리 필요.

### 3. B-트리의 특성

-	짧고 안정된 읽기 지연, 범위 스캔 우수(리프 연속 읽기).
-	반면 랜덤 쓰기·페이지 잠금 부담, 분할/병합·버퍼풀·WAL 튜닝 필요.

## 기타 색인 구조

### 기본키 vs 보조 색인

-	기본키: 테이블의 주 주소 체계.
-	보조 색인: 다른 칼럼 기반 접근 경로(관계형 DB의 CREATE INDEX).

### 클러스터드/비클러스터드와 저장 방식

-	클러스터드 색인: 인덱스 순서 = 물리 저장 순서(범위 질의 강함).
-	비클러스터드 + 힙 파일: 인덱스는 포인터만 → 한 번 더 테이블 접근 필요.
-	인덱스에 값 저장(커버링): 잦고 작은 값이면 유리, 큰 값·갱신 빈번이면 비추천.

### 다중 칼럼 색인

-	결합 인덱스는 정렬 순서(좌측 고정) 가 효율을 결정한다.

## 모든 것을 메모리에 보관 — 인메모리 DB

- 제품군 예시: VoltDB, MemSQL, Oracle TimesTen, RAMCloud, Redis/카우치베이스 등.
-	내구성: 커밋 로그(append) + 주기적 스냅샷.
-	안티 캐싱: 차가운 객체를 디스크로 내보내 메모리 풋프린트를 제어.
-	장점은 극저지연이지만, 복구·운영 모델(전원 장애, 스냅샷 주기 등) 설계가 필수.
-	비휘발성 메모리(NVM) 의 가능성도 언급.

## 트랜잭션(OLTP) vs 분석(OLAP)

### 1. 개념 구분과 질문의 유형

-	OLTP: 고속 처리, 낮은 지연, 키/보조 색인 기반 질의.
-	OLAP: 대량 스캔·집계 중심. “하루 매장별 매출은?”, “최근 트렌드는?”

<img width="846" height="282" alt="image" src="https://github.com/user-attachments/assets/6cbd03c6-c1f8-495a-9aea-9b549524edff" />

### 2. 데이터 웨어하우스와 ETL

- OLTP 소스 → (추출·변환·적재) ETL → 웨어하우스.
-	운영계와 분리하여 분석 안정성/성능을 확보.

<img width="698" height="514" alt="image" src="https://github.com/user-attachments/assets/dc2ab224-b46c-4125-979f-78665a4a8eb0" />

### 3. 분석용 스키마
-	별모양(Star):
  - 사실 테이블(측정값: 수량/금액 등)
  - 차원 테이블(누가·언제·어디서·무엇·왜/어떻게)
-	눈꽃송이(Snowflake): 차원 정규화(조인↑ ↔ 중복↓).
  - SQL은 날짜·제품 차원으로 묶어 집계를 수행.

<img width="624" height="709" alt="image" src="https://github.com/user-attachments/assets/b30e185a-e7be-4111-b462-f7660ea26aa8" />

## 컬럼 지향 저장소

### 1. 기본 아이디어

-	열 단위로 파일 배치 → 필요한 열만 읽는 컬럼 프루닝 가능.
-	정렬 키/파티션으로 스캔 범위를 줄임.

<img width="842" height="406" alt="image" src="https://github.com/user-attachments/assets/679efd89-58be-47fd-8b2a-fa9c992d45e1" />

### 2. 컬럼 인코딩/압축

-	사전(Dictionary): 저카디널리티 범주형에 효율적.
-	RLE: 반복 구간 압축.
- 비트맵 부호화: 범주형 필터·집합 연산 가속(SQL IN 등).

### 3. 실행 최적화

-	벡터화 처리(Vectorized/SIMD): 열 배치를 묶음으로 처리해 CPU 효율 개선.
-	파일/페이지 메타의 최솟값·최댓값 통계 로 건너뛰기.

### 4. 쓰기와 갱신

-	제자리 갱신이 어려움 → 델타 영역에 적재 후 주기적 병합(책에서 LSM식 접근을 언급).

### 5. 구체화

-	구체화 집계/뷰(데이터 큐브): 반복되는 집계를 미리 계산(신선도↔속도의 교환).

## 3장 정리

-	OLTP vs OLAP는 요구가 다르며, 저장소 선택도 달라진다.
  -	OLTP: 보통 페이지 지향(예: B-트리) 로 짧은 지연·동시성 최적화.
  -	OLAP/웨어하우스: 컬럼 지향 + 정렬/파티션 + 벡터화 로 대량 스캔·집계 최적화.
-	로그 구조 엔진(LSM/SSTable) 과 B-트리는 서로 다른 강점:
  - LSM: 쓰기 중심·순차 I/O, 컴팩션 운용이 성능의 관건.
  - B-트리: 일관된 읽기 지연·범위 질의 강함, 랜덤 갱신·분할/병합 관리 필요.
-	보조 색인(클러스터드/비클러스터드·다중 칼럼·커버링)은 OLTP에서 핵심 생산성 도구.
-	인메모리 DB는 극저지연을 제공하되 로그/스냅샷/안티 캐싱으로 내구성·용량 문제를 해결한다.
- 최종 메시지: 워크로드·질문 유형·SLA에 맞춰 저장 구조를 고르고, 증폭 지표와 꼬리 지연을 운용 측면에서 관리하라.
