#  2장. 데이터 모델과 질의 언어

-	데이터 모델은 단순히 데이터를 저장하는 방식이 아니라 소프트웨어 개발의 사고방식을 규정한다.
- 어떤 모델을 선택하느냐에 따라 문제를 어떻게 생각하고 풀어낼지가 달라짐.
- 애플리케이션은 다양한 관점에서 데이터를 모델링한다.
  - 현실 세계: 사람, 사건, 상품, 행동 등을 객체로 모델링
  - 저장 구조: JSON, XML, 테이블, 그래프 모델
  - 엔진 관점: 디스크/메모리/네트워크에 어떻게 저장하고 조회할지
  - 하드웨어 관점: 전류, 빛, 자기 등 물리적 레벨

## 주요 데이터 모델

|모델|특징|장점|단점/한계|
|------|---|---|---|
|관계형 모델|테이블(행=튜플, 열=속성), SQL|정규화, 무결성, 표준화|조인 비용, 스키마 변경 어려움|
|문서 모델|JSON/XML 기반 문서|스키마 유연성, 지역성(Locality)|데이터 중복, 무결성 관리 어려움|
|그래프 모델|정점(vertex) + 간선(edge)|복잡한 관계 표현, 탐색 최적화|성능·최적화 DB 엔진 필요|
|트리플 저장소(RDF/스파클)|(주어, 술어, 목적어) 구조|시맨틱 웹, 온톨로지 표현 가능|복잡성↑, 성능 부담|

## 관계형 모델과 문서 모델

- 관계형 모델(Relational Model)
  - 1970년 에드거 코드가 제안.
  - 데이터는 관계(테이블로 표현, 각 행은 튜플(Row), 각 열은 속성(Attribute).
  - 수십 년간 표준 DBMS의 기반 → SQL
- 문서 모델(Document Model)
  - JSON/XML 같은 반정형 데이터 저장.
  - 스키마 유연성, 중첩 구조(Locality)를 지원.
  - MongoDB, CouchDB 등 NoSQL DB에서 채택.
- 차이점
  - 관계형: 데이터가 정규화되어 여러 테이블로 분리 → JOIN 필요.
  - 문서형: 데이터가 한 문서에 함께 저장 → 읽기 성능 유리, 중복 허용.
 
## NoSQL의 등장

- 대규모 데이터, 분산 처리, 확장성 요구.
- RDB의 스키마 강제, JOIN 비용 문제 극복 필요.
- 종류: 문서 DB, 키-값 DB, 그래프 DB, 칼럼 패밀리 DB 등.

## 객체-관계 불일치 문제 (ORM과 매핑)

- 애플리케이션은 객체 모델(OOP), DB는 관계형 모델 → Impedance Mismatch.
-	ORM 프레임워크(ActiveRecord, Hibernate)로 완화하지만 근본적 차이 존재.
- 예: first_name, last_name 같은 필드를 객체/테이블 양쪽에서 매핑해야 함.

<img width="822" height="648" alt="image" src="https://github.com/user-attachments/assets/36289542-dfd1-4373-80c5-562179c1a1f9" />

<img width="824" height="711" alt="image" src="https://github.com/user-attachments/assets/fb085c22-ff17-4fcf-8b37-28edfa0074d6" />

##  다대일 / 다대다 관계

- 관계형 DB는 정규화(normalization) 개념을 기반으로 설계됨.
  - 여러 테이블을 외래 키(Foreign Key)로 연결 → JOIN 연산으로 다대일/다대다를 쉽게 표현.
  - users ↔ orders (1:N)
  - students ↔ classes ↔ student_class_map (M:N)
- 문서 DB는 “데이터를 하나의 문서에 최대한 담아라”라는 Locality 철학이 강함.
  - 즉, JOIN을 쓰는 대신 중첩(Nested) 구조로 함께 저장하는 걸 선호한다.
- 장단점
  - 문서 DB: 중첩 구조로 locality 확보, 읽기 성능↑
  - 관계형 DB: 정규화로 데이터 중복↓, 무결성 유지↑
 
#### (1) 다대일(many-to-one)

- 관계형: order.user_id → users.id 로 JOIN.
- 문서형: order 문서 안에 user의 일부 정보(스냅샷)를 중첩 저장.

```json
{
  "order_id": 101,
  "item": "Laptop",
  "user": {
    "id": 1,
    "name": "홍길동"
  }
}
```

- 문제: 유저 정보 변경 시 관련 문서 전체를 수정해야 함 → 팬아웃 업데이트 비용↑

#### (2) 다대다(many-to-many)

- 관계형: 학생 ↔ 수업 관계를 매핑 테이블로 관리.
- 문서형: 보통 배열에 참조 ID만 넣음.

```json
{
  "student_id": 1,
  "name": "철수",
  "class_ids": [101, 102, 103]
}
```

- 문제:
	-	역참조 어려움(“이 수업을 듣는 학생 찾기”) → 배열 전체 스캔 필요.
	-	JOIN이 없으니 집계 파이프라인이나 애플리케이션 단에서 여러 번 조회해야 함.

#### 왜 어려운가?

- JOIN 부재
  - MongoDB 같은 문서 DB도 $lookup 지원하긴 하지만, 성능·표현력이 RDB JOIN만큼 강력하지 않음.
- 데이터 중복 허용
  - 문서 DB는 성능을 위해 “중복 허용 → 빠른 읽기”를 지향.
  - 반면 다대일/다대다는 중복 없는 참조 설계가 핵심 → 문서 DB 철학과 충돌.
- 스키마 유연성
  - 같은 컬렉션의 문서가 다른 구조를 가질 수 있어 일관된 관계 표현이 어려움.
- 일관성 문제
  - 한 쪽 데이터가 바뀌면 다른 쪽도 업데이트해야 하는데, DB 레벨에서 강제되지 않음(외래 키 제약 X)

#### 어떻게 해결하나?

- Denormalization(비정규화): 필요한 데이터는 문서에 같이 저장 → 조회는 빠름, 업데이트는 복잡.
- 참조 저장(Reference): ID만 저장하고 애플리케이션 단에서 두 번 쿼리 → JOIN 역할을 코드로 구현.
- $lookup (MongoDB): JOIN 흉내 가능하지만 대규모 데이터에서 성능 부담.
- Graph DB 고려: 다대다 관계 탐색이 핵심이라면 MongoDB보다 Neo4j 같은 그래프 DB가 적합.

## 스키마와 유연성

-	관계형 DB: 스키마 고정(schema-on-write) → 필드 변경 시 마이그레이션 필요.
- 문서 DB: 스키마리스(schema-less) 또는 schema-on-read → 필드 추가,삭제 자유로움.
  - 장점: 빠른 개발, 유연성.
  - 단점: 스키마 관리가 애플리케이션 레벨 책임.
 
##  데이터 지역성(Locality)

-	문서 DB는 관련 데이터(예: user + orders)를 한 문서에 함께 저장 → 디스크 접근 최소화.
-	관계형 DB는 여러 테이블 JOIN 필요 → 캐시 전략, 인덱스 필요.

## 문서 DB와 관계형 DB의 융합

-	최신 DBMS(PostgreSQL, MySQL, Oracle 등)는 JSON 타입 지원 → 두 모델 융합.
-	문서 DB도 점점 관계형 질의 기능(SQL 유사 문법) 도입.
-	미래 DB 방향은 혼합형 모델 (Hybrid).

## 질의 언어 비교

- 명령형 질의
  - 절차 중심: “어떻게 할까?”를 코드로 명시.
  - 예: JavaScript 반복문으로 조건 맞는 데이터 수집.
  - 장점: 세밀한 제어 가능.
  - 단점: 코드가 장황, DB 최적화 어려움.
- 선언형 질의
  - 목표 중심: “무엇이 필요한가?”만 지정.
  - 예: SELECT * FROM animals WHERE family='Sharks'
  - 장점: 단순, 최적화 엔진이 실행 전략을 결정.
  - 단점: 세부 절차 제어는 어렵다.
- SQL의 장점 = 선언형 → 최적화 엔진이 실행 순서·방법을 결정.

## NoSQL 환경의 질의 확장

- MapReduce
  - 분산 환경에서 대규모 데이터 집계 처리.
  - Map(분할) + Reduce(결과 합치기).
  - 예: MongoDB의 mapReduce API.
- Aggregation Pipeline (MongoDB)
  - SQL GROUP BY와 유사한 선언형 질의.
  - MapReduce보다 단순하고 빠른 경우 많음.
- 그래프 질의 언어
  - Cypher (Neo4j): 패턴 매칭 기반.
  - SQL 재귀 쿼리(WITH RECURSIVE)도 가능하나 직관성 부족.
- RDF/SPARQL
  - 시맨틱 웹용, 주어-술어-목적어 기반 탐색.
- Datalog
  - 규칙 기반 선언형 언어.
  - “규칙(rule)”을 정의해 데이터 추론 가능.

## 정리

- 문서 DB는 단일 문서 중심, 문서 간 관계는 적음.
- 그래프 DB는 관계 중심, 연결·탐색이 강점.
- RDF/트리플 저장소는 의미론적 연결, 온톨로지 기반 응용에 유리.
- 관계형 DB는 여전히 가장 보편적, JSON·그래프 확장 기능을 추가하며 진화 중.
- 현대 DB의 방향 = 하이브리드 모델
  - SQL + JSON (관계형 + 문서)
  - 그래프 질의 기능 추가
  - 의미론적 검색과 결합
