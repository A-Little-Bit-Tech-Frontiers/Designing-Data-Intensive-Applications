# 1. 관계형 모델과 문서 모델

## 1.1 관계형 모델 (Relational Model)

- 테이블(Table) 기반의 모델로, 각 테이블은 **릴레이션(Relation)**이라 불리며, 행(Row, Tuple)들의 집합으로 구성됨.
- **특징**:
    - 명확하고 수학적 기반이 있는 구조.
    - 관계형 데이터베이스 관리 시스템(RDBMS)을 통해 데이터를 저장·질의 가능.
    - 수십 년 동안 비즈니스 데이터 처리의 표준이 되었으며, 회계·급여·재고 관리 등 일상적 업무 처리에 활용.
- **장점**: 안정적이고 보편적인 데이터 처리 가능, 대규모 트랜잭션 처리에 적합.
- **한계**:
    - 스키마(schema)가 고정적 → 유연성 부족.
    - 대용량 분산 환경에서 성능 제약 발생.
    - 복잡한 데이터(비정형 데이터 등) 처리에 비효율적.

## 1.2 문서 모델(Doument model)

- 관계형 모델의 한계를 보완하기 위해 등장. 문서(Document) 단위로 데이터를 저장·질의함.
- **특징**:
    - 데이터가 JSON, XML 같은 문서 형태로 저장됨.
    - 스키마가 고정되지 않고 유연 → 데이터 구조가 다양해도 쉽게 처리 가능.
    - 비정형 데이터 및 복잡한 데이터 표현에 강점.
- **장점**:
    - 다양한 데이터 구조를 직관적이고 유연하게 표현.
    - 특정 사용 사례(예: 콘텐츠 관리, 로그 데이터 저장, 웹 애플리케이션)에서 효율적.
- **한계**:
    - 관계형 데이터 모델만큼 보편적이지 않음.
    - 데이터 중복 및 일관성 유지가 어렵고, 트랜잭션 처리에서 제약이 있음.

## 1.3 객체 관계형 불일치

오늘날 OOP 기반의 언어로 개발을 한다. 그리고, 관계형 테이블에 저장된 데이터와 애플리케이션 사이에 전환 계층이 필요하다. 이런 모델 사이의 분리를 종종 **임피던스 불일치(impedance mismatch)**라고 부름.

<img width="555" height="476" alt="image" src="https://github.com/user-attachments/assets/c05e3381-0781-4675-aa58-9558c7b977ca" />


위 예시를 기반으로 DB와 객체 모델에서의 표현이 아래와 같은 차이가 있다.

- 관계형 DB 스키마에서는 `users`, `positions`, `education` 테이블 등으로 나누어 저장.
- 반면 객체 모델이나 JSON 문서에서는 하나의 사용자 객체 안에 직업·학력·연락처 정보를 **중첩 구조**로 표현 가능.

따라서 같은 정보를 표현하기 위해 관계형 모델은 **JOIN 연산**이 필요하지만, 객체/문서 모델은 더 직관적으로 표현 가능.

```json
{
  "user_id": 251,
  "first_name": "Bill",
  "last_name": "Gates",
  "summary": "Co-chair of the Bill & Melinda Gates... Active blogger.",
  "region_id": "us:91",
  "industry_id": 131,
  "photo_url": "/p/700/0/253/05b/388d6dec.jpg",
  "positions": [
    {
      "job_title": "Co-chair",
      "organization": "Bill & Melinda Gates Foundation"
    },
    {
      "job_title": "Co-founder, Chairman",
      "organization": "Microsoft"
    }
  ],
  "education": [
    {
      "school_name": "Harvard University",
      "start": 1973,
      "end": 1975
    },
    {
      "school_name": "Lakeside School, Seattle",
      "start": null,
      "end": null
    }
  ],
  "contact_info": {
    "blog": "http://thegatesnotes.com",
    "twitter": "http://twitter.com/BillGates"
  }
}

```

일부 사람들은 json이 애플리케이션 ↔ 저장 계층 간 임피던스 불일치를 줄인다고 생각한다. 하지만, **데이터 부호화 형식으로서 json이 가진 문제도 있다.** 

json은 테이블 방식보다 더 나은 지역성을 갖긴 한다. 정규화된 테이블과 달리 json 표현에는 모든 관련 정보가 한 곳에 있어 하나의 질의로 충분하다. 아래와 같은 일대다 관계의 트리 구조가 json 표현에서 명시적으로 잘 드러난다.

<img width="320" height="226" alt="image" src="https://github.com/user-attachments/assets/e95ff89c-6ef9-4d53-929c-3615b772cb10" />


## 1.4 다대일과 다대다 관계

- **다대일**: 여러 개체가 하나의 엔티티에 속하는 관계.
    - 문서 모델에서는 중첩 구조로 쉽게 표현 가능, 관계형 DB는 조인 필요.
- **다대다**: 여러 개체가 서로 다수의 엔티티와 연결되는 관계.
    - 문서 모델에서는 배열로 단순 표현, 관계형 DB는 별도의 연결 테이블 필요.

따라서 **문서 모델**은 관계형 DB보다 다대일/다대다 관계를 **더 직관적이고 단순하게 표현**할 수 있다는 장점이 있음.

## 1.5 문서 데이터베이스는 역사를 반복하고 있나?

관계형 DB와 NoSQL 논쟁은 사실 과거의 데이터베이스 시스템 역사 속에서 반복된 주제다. 
1970년대 IBM IMS(Information Management System)가 대표적인 **계층 모델** 데이터베이스이고 특징은 아래와 같다.

- 트리 구조 기반, 오늘날 문서 DB의 JSON 구조와 유사.
- 하지만 다대다 관계 표현이 어려움.
- 당시 대안으로 **관계형 모델**과 **네트워크 모델(CODASYL, 코다실 모델)** 이 등장.
    - 네트워크 모델은 레코드 간 연결 경로를 지정해 다대다 관계를 해결.
    - 하지만 접근 경로 추적이 복잡하고, 프로그램 수정 시 재작성 부담이 큼.

### 1.5.1 문서 데이터베이스와의 비교

- **문서 데이터베이스**는 한 측면에서 과거의 **계층 모델**로 돌아간 형태.
    - JSON 문서 안에 중첩된 구조(예: `positions`, `education`, `contact_info`)를 저장 → 계층적.
- 그러나 다대일·다대다 관계 표현 방식은 관계형 DB와 크게 다르지 않음.
    - 관계형 DB에서는 외래 키(Foreign Key),
    - 문서 DB에서는 **문서 참조(Document Reference)** 로 불림.
- 결국 문서 DB는 현재까지 **코다실 모델처럼 전철을 밟지 않고 있음**, 하지만 관계형 DB의 단순성과 최적화된 질의 모델은 여전히 강점으로 남아 있음.

## 1.6 관계형 데이터베이스와 오늘날의 문서 데이터베이스

관계형 데이터베이스와 문서 데이터베이스를 비교할 때 단순 차이만이 아니라 **동시성 처리, 참조 방식**까지 함께 고려해야 한다. 
문서 데이터 모델의 차이점에 집중해야 하며, 특정 애플리케이션에서는 문서 모델이 코드 작성과 유지보수에 더 유리한 경우가 있다.

### 1.6.1 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?

- 문서 DB는 JSON 기반 문서 구조 덕분에 관계형 모델처럼 여러 테이블을 조인하는 대신 **중첩 구조(shredding)** 로 쉽게 표현 가능 → 코드 단순화.
- 하지만 문서 DB에는 제약이 있음.
    - 중첩이 깊어지면 접근 경로가 복잡해짐.
    - 다대다 관계나 추가 질의가 필요할 때는 성능 저하 발생 가능.
- 따라서 **단순 구조**나 **비정규화된 데이터** 처리에는 문서 DB가 유리하지만, **복잡한 질의**가 필요하면 관계형 모델이 더 적합.

### 1.6.2 문서 모델에서의 스키마 유연성

- 문서 DB는 흔히 **스키마리스(schemaless)** 라고 불리지만, 실제로는 완전히 없는 게 아니라 더 유연한 형태.
- 관계형 DB: **쓰기 스키마(schema-on-write)** → 저장 시 스키마 고정.
- 문서 DB: **읽기 스키마(schema-on-read)** → 데이터를 저장할 때는 자유롭지만 읽을 때 구조를 해석.
- 장점: 새로운 필드 추가 시 마이그레이션(ALTER TABLE 같은 작업) 불필요, 기존 문서와 새로운 문서를 동시에 처리 가능.
    
    <img width="399" height="94" alt="image" src="https://github.com/user-attachments/assets/67c8d688-1610-4e56-a0a8-d32787f62d55" />

    
- 단점: 일관성 유지가 어려움, 애플리케이션 단에서 구조 검증이 필요.

### 1.6.3 질의를 위한 데이터 지역성(Storage Locality)

- 문서 DB는 JSON/XML 문서를 한 번에 가져오므로 **관련 데이터가 한 문서에 묶여 있음**.
- 장점:
    - 특정 사용자 문서에서 직업·학력 등 관련 데이터를 한 번에 읽기 가능.
    - 데이터 접근 시 조인이 필요 없음.
- 단점:
    - 문서가 커질수록 쓰기 성능이 떨어질 수 있음.
    - 특정 작은 데이터만 갱신해도 전체 문서를 다시 써야 함.
- 따라서 지역성(Locality)은 장점이 될 수도 있지만, 데이터가 지나치게 커지면 오히려 비효율적일 수 있음.

# 2. 데이터를 위한 질의 언어

## 2.1 데이터베이스 질의 언어

1. **명령형 질의 언어**
    - IMS, CODASYL 모델에서 사용.
    - 프로그래밍 언어처럼 **절차적(명령형) 코드**로 질의 수행.
    - 예: `for` 반복문으로 조건 검사 후 데이터를 수집.
    - 단점: 사용자가 **데이터 접근 경로**까지 직접 지정해야 함 → 복잡하고 비효율적.
2. **선언형 질의 언어**
    - 관계형 모델 등장과 함께 SQL이 대표.
    - **원하는 결과**만 정의, 데이터 접근 경로는 DBMS의 **질의 최적화기(query optimizer)** 가 결정.
    - 병렬 처리에도 적합 → 대규모 데이터에서 성능 우위.
    - 예: `SELECT * FROM animals WHERE family='Sharks';`
3. **웹에서의 선언형 질의**
    - CSS 선택자, XPath, XSLT 등이 예.
    - 원하는 패턴을 지정하면 엔진이 자동으로 선택/처리.
    - 명령형 접근보다 간단하고 직관적.

## 2.2 맵리듀스(MapReduce) 질의

- 대규모 데이터 처리용 프로그래밍 모델. 일부 NoSQL DB(MongoDB, CouchDB 등)에서 지원.
- **map**: 데이터를 분류/변환.
- **reduce**: 분류된 데이터를 집계.
- SQL의 `GROUP BY`와 유사한 역할.
- MongoDB 예시
    
    ```sql
    db.observations.mapReduce(
      function map() { emit(this.month, this.numAnimals); },
      function reduce(key, values) { return Array.sum(values); },
      { query: { family: "Sharks" }, out: "monthlySharkReport" }
    );
    
    ```
    

## 2.3 그래프형 데이터 모델

1. **특징**
    - **정점(Vertex)** 과 **간선(Edge)** 로 데이터를 표현.
    - 다대다 관계가 많은 데이터를 직관적으로 모델링 가능.
    - 예: 소셜 네트워크(친구 관계), 웹 그래프(링크 구조), 도로망 등.
2. **속성 그래프 모델**
    - 정점과 간선에 속성을 가질 수 있음.
    - 예: 사람(정점) –[친구관계]→ 다른 사람(정점).
3. **대표 기술**
    - Neo4j, Titan, AllegroGraph, Datomic 등.
    - Cypher(사이퍼), SPARQL 같은 **그래프 질의 언어** 제공.
4. **관계형 DB와 비교**
    - 관계형에서는 그래프 구조를 SQL 조인으로 구현해야 해서 복잡.
    - 그래프 DB는 관계 탐색(예: 친구의 친구 찾기)에 훨씬 효율적.

## 2.4 트리플 저장소와 SPARQL

1. **트리플 저장소 모델**
    - 모든 데이터를 `(주어, 술어, 목적어)` 형태로 저장.
    - RDF(Resource Description Framework) 표준 기반.
    - 예:
        
        ```
        루시(Lucy) —born_in→ 아이다호(Idaho)
        아이다호 —within→ 미국(USA)
        
        ```
        
    - 그래프 DB와 유사하지만 더 단순화된 구조.
2. **SPARQL 질의 언어**
    - RDF 데이터 질의용 표준 언어.
    - Cypher와 비슷하지만, RDF 트리플 구조에 최적화.
    - 예:
        
        ```
        SELECT ?personName WHERE {
          ?person :bornIn :Idaho .
          ?person :livesIn :Europe .
          ?person :name ?personName .
        }
        
        ```
        
    - → 아이다호에서 태어나 유럽에 사는 사람의 이름을 질의.
3. **특징**
    - 웹 데이터 통합, 시맨틱 웹 등에서 활용.
    - 관계형 DB와 달리, **데이터를 웹 리소스(URI)와 직접 연결** 가능.
    - 시맨틱 웹의 핵심 도구로 발전.

## 2.5 데이터로그(Datalog)

- **정의**:
    - 사이퍼(Cypher), 스파클(SPARQL)보다 훨씬 오래된 언어.
    - 1980년대 학계에서 활발히 연구되었음.
    - 프로로그(Prolog)와 같은 논리 기반 언어에 뿌리를 두며, **질의 언어의 초석**이 됨.
- **특징**:
    - 트리플 저장소 모델을 단순화 → `(주어, 서술어, 객체)` 대신 **서술어(주어, 객체)** 형태로 표현.
    - 규칙(rule)과 서술어(predicate)를 활용해 데이터를 추론하거나 질의할 수 있음
