# 데이터 모델과 질의 언어

대부분의 애플리케이션은 하나의 데이터 모델을 다른 데이터 모델 위에 계층을 둬서 만듦

각 계층의 핵심적인 문제 → 다음 하위 계층 관점에서 데이터 모델을 표현하는 방법

- 애플리케이션 개발자는 현실(사람, 조직, 상품. 행동, 자금 흐름, 센서 등)을 보고 객체나 데이터 구조, 그리고 이러한 데이터구조를 다루는 API를 모델링
- 데이터 구조를 저장할 때는 JSON이나 XML 문서, 관계형 데이터베이스 테이블이나 그래프 모델 같은 범용 데이터 모델로 표현
- 데이터베이스 소프트웨어를 개발하는 엔지니어는 JSON/XML/관계형/그래프 데이터를 메모리나 디스크 또는 네트워크 상의 바이트 단위로 표현하는 방법을 결정
- 더 낮은 수준에서 하드웨어 엔지니어는 전류, 빛의 파동, 자기장 등의 관점에서 바이트를 표현하는 방법을 알아냄

관계형 모델, 문서 모델, 그래프 기반 모델을 비교 및 살펴보기

## 관계형 모델과 문서 모델

- 1970년 에드가 코드가 제안한 관계형 모델 → 데이터는 관계로 구성되고, 각 관계는 순서 없는 튜플 모음이다
- 1980년 중반 RDBMS 와 SQL 은 정규화된 구조로 데이터를 저장하고 질의할 필요가 있는 사람들이 대부분 선택하는 도구가 됐다
- 관계형 데이터베이스의 근원은 1960/1970년 대 비즈니스 데이터 처리에 있음
    - **트랜잭션 처리, 일괄 처리** 로 오늘 날엔 일상적으로 수행되는 일
- 관계형 모델의 목표 → 정리된 인터페이스 뒤로 구현 세부 사항을 숨기는 것
- 1970년대와 1980년대 초반에는 **네트워크 모델과 계층 모델이 주요 대안** 이었지만 결국 관계형 모델이 우위를 차지했다

### NoSQL의 탄생

- 2010년대 NoSQL은 관계형 모델의 우위를 뒤집으려는 가장 최신 시도
- NoSQL 은 2009년 오픈소스, 분산환경, 비관계형 데이터베이스 밋업용 인기 트위터 해시태그였음
- **Not Only SQL** 로 재해석 되었다
- NoSQL 데이터베이스를 채택한 데는 다음과 같은 원동력이 있음
    - 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 뛰어난 확장성의 필요
    - 상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산
    - 관계형 모델에서 지원하지 않는 특수 질의 동작
    - 관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람
- 관계형 데이터베이스가 폭넓은 다양함을 가진 비관계형 데이터스토어와 함께 사용될 것이다
- 이런 개념을 **다중 저장소 지속성 (polyglot persistence)** 이라고 한다

### 객체 관계형 불일치

- 데이터를 관계형 테이블에 저장하려면 애플리케이션 코드와 데이터베이스 모델 객체 사이에 전환 계층이 필요하다
- 이런 모델 사이의 분리를 종종 **임피던스 불일치 (impedance mismatch)** 라고 부른다
- 액티브레코드나 하이버네이트 같은 ORM 은 전환 계층에 필요한 코드 양을 줄이지만, **두 모델간의 차이를 완벽히 숨길수는 없다**

![스크린샷 2025-08-26 오전 8.19.51.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-26_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.19.51.png)

- 위 처럼 이력서 같은 데이터 구조는 모든 내용을 갖추고 있는 문서라 JSON 표현에 매우 적합하다
- 몽고 DB, 리싱크 DB, 카우치 DB, 에스프레소 같은 문서 지향 데이터베이스는 JSON 데이터 모델을 지원한다
- JSON 모델이 애플리케이션 코드와 저장 계층 간 임피던스 불일치를 줄인다고 생각하지만, JSON 이 가진 문제도 있다

![스크린샷 2025-08-26 오전 8.22.01.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-26_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.22.01.png)

- JSON 표현은 다중 테이블 스키마보다 더 나은 지역성을 갖는다
- 난잡한 다중 조인을 수행하지 않아도 된다

### 다대일과 다대다 관계

- 중복된 데이터를 정규화하려면 **다대일 관계**가 필요한데, 다대일 관계는 문서 모델에 적합하지 않다
- 문서형 데이터베이스에서는 일대다 트리 구조를 위해 조인이 필요하지 않지만 조인에 대한 지원이 약하다
- 데이터베이스가 조인을 지원하지 않으면 다중 질의를 만들어서 애플리케이션 레벨에서 이를 흉내내야 한다
    
    ![스크린샷 2025-08-26 오전 8.35.40.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-26_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.35.40.png)
    
- 각 점선 내 데이터는 하나로 문서로 묶을수 있지만, 그 외에는 참조로 표현하고 질의시에는 조인이 필요하다

## 문서 데이터베이스는 역사를 반복하고 있나 ?

- NoSQL 은 데이터베이스에서 다대다 관계를 표현하는 제일 좋은 방법에 대한 논쟁을 다시 열었다
- 계층 모델의 한계를 해결하기 위해 다양한 해결책이 제안 되었다
    - 관계형 모델과 네트워크 모델
- 두 모델이 해결하려는 문제가 오늘 날에도 관련이 많기에 간략히 다시 살펴볼 가치가 있음

### 네트워크 모델

- 코다실 이라 불리는 위원회에서 표준화 했다
- 코다실 모델은 계층 모델을 일반화 한다
- 계층 모델의 트리구조에서 모든 레코드는 하나의 부모가 있고, 네트워크 모델에서는 다중 부모가 있을 수 있다
- 네트워크 모델에서 레코드 간 연결은 **프로그래밍 언어의 포인터**와 더 유사함
- 레코드에 접근하는 유일한 방법 → 최상위 레코드에서부터 연속된 연결 경로를 따르는 방법
    - 이를 **접근 경로** 라고 함
- 코다실 에서의 질의
    - 레코드 목록을 반복하여 접근경로를 따라 데이터베이스 끝에서 끝까지 커서를 움직여 슈행
    - 만약 레코드가 다중 부모라면 모든 관계를 추적해야 한다

### 관계형 모델

- 관계형 모델이 하는 일 → 알려진 모든 데이터를 배치하는 것
- 관계는 단순히 튜플의 컬렉션이 전부이다
    - 복잡한 접근 경로가 없다
- RDBMS 에서 옵티마이저는 어느 순서로 실행할지 결정하고 사용할 색인을 자동으로 결정한다
    - 이는 접근 경로
    - 하지만 개발자가 선택하는 것이 아닌, 옵티마이저가 자동으로 만들어 준다는 점이 다르다

### 문서 데이터베이스와의 비교

- 문서 데이터베이스는 한 가지 측면에서 계층 모델로 되돌아 갔다
- 별도 테이블이 아닌 상위 레코드 내에 중첩된 레코드를 저장한다
- 이는 근본적으로 다르지 않으며, 둘다 관련 항목은 고유한 식별자로 참조한다
    - 관계형 모델 → 외래키
    - 문서 모델 → 문서 참조

## 관계형 데이터베이스와 오늘날의 문서 데이터베이스

- 문서 데이터 모델을 선호하는 주요 이유 → 스키마 유연성, 지역성에 기인한 더 나은 성능
- 일부 애플리케이션의 경우 애플리케이션에서 사용하는 데이터 구조와 더 가깝다
- 관계형 모델 → 조인, 다대일, 다대다 관계를 더 잘 지원함으로 써 문서 데이터 모델에 대항함

## 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까 ?

- 애플리케이션에서 데이터가 문서와 비슷한 구조라면, 문서 모델을 사용하는 것이 좋음
- 문서와 비슷한 구조를 여러 테이블로 나누어 **찢는 (shredding)** 관계형 기법은 다루기 힘든 스키마와 불필요하게 복잡한 애플리케이션 코드를 발생시킨다
- 다대다 관계를 사용한다면, 문서 모델을 매력이 떨어진다
- 비정규화로 인해 조인은 줄어들지만, 데이터 일관성 유지를 위해 별도 추가 작업이 필요하다
- 일반적으로 어떤 데이터 모델이 더 간단하게 만드는지는 알 수 없다
    - 데이터 간에 존재하는 관계 유형에 따라 달라짐

### 문서 모델에서의 스키마 유연성

- 대부분 문서 데이터베이스와 관계형 데이터베이스에서 지원하는 JSON 은 스키마를 강요하지 않는다
- 종종 스키마리스라고 불리지만, 이는 오해의 소지가 있다
    - 읽는 코드는 구조의 유형을 어느정도 가정함
    - 암묵적 스키마가 있지만 이를 강요하지 않음
- 읽기 스키마 → 프로그래밍 언어에서 동적 타입과 유사
- 쓰기 스키마 → 정적 타입과 유사
- 새로운 필드를 가진 문서를 작성하기 시작했다면, 예전 문서를 읽은 경우를 처리하는 코드만 있으면 된다
    - 관계형 데이터베이스 에서는 마이그레이션이 필요함
- RDBMS 에서 스키마 변경을 보통 짧은 시간내에 수행되지만
- MySQL 은 ALTER 시 전체 테이블을 복사하여 수 분에서 수 시간까지 중단이 발생한다는 의미이다

### 질의를 위한 데이터 지역성

- 애플리케이션이 자주 전체 문서에 접근해야 할때, 저장소 지역성을 활용하는 성능 이점이 있다
- 지역성의 이점 → 한 번에 해당 문서의 많은 부분을 필요로 하는 경우에만 적용
- 지역성을 위해 관련 데이터를 함께 그룹화하는 개념이 **문서 모델에만 국한되지 않는다**
- 구글 스패너, 오라클의 다중 테이블 색인 클러스터 테이블, 칼럼 패밀리 개념이 지역성 관리와 유사한 목적이 있다

### 문서 데이터베이스와 관계형 데이터베이스의 통합

- 대부분 RDBMS 는 2000년대 중반 이후 XML 을 지원한다
- 문서 데이터베이스 사용할때와 비슷한 모델을 사용 가능해짐
- JSON 문서에 대해 비슷한 수준의 지원 기능도 제공함
- 관계형 데이터베이스와 문서 데이터베이스는 시간이 지남에 따라 점점 더 비슷해지고 있다
- 각 데이터 모델이 서로 부족한 부분을 보완해 나가고 있기 때문이다
- 관계형과 문서의 혼합 모델은 미래 데이터베이스들이 가야할 올바른 길

## 데이터를 위한 질의 언어

- SQL 은 선언형 질의 언어, IMS 와 코다실은 명령형 코드를 사용해 DB 에 질의한다
    - 일반적으로 많이 사용하는 프로그래밍 언어는 명령형 언어
- 명령형 언어
    - 특정 순서로 연산을 수행하게끔 컴퓨터에게 지시
- 선언형 언어
    - 목표를 달성하기위한 방법이 아닌 알고자 하는 데이터의 패턴
    - 결과가 충족해야 하는 조건과 데이터를 어떻게 변환할지를 지정한다
- 선언형이 일반적으로 명령형보다 간결하고, **데이터베이스 상세 구현이 숨겨져 있어** 질의 변경 없이 데이터베이스 성능 향상이 가능하다
- 또한 병렬 실행에도 적합하다

### 맵리듀스 질의

- 맵리듀스 (MapReduce) → 대량의 데이터를 처리하기 위한 프로그래밍 모델
    - 몽고, 카우치를 포함한 일부 NoSQL 은 제한된 형태의 맵리듀스를 지원
- 선언형도 아니고 완전한 명령형 질의도 아닌 중간 정도 지점에 있다
- 여러 함수형 프로그래밍 언어에 있는 map, reduce 함수를 기반으로 한다

```sql
// 상어과 종만 필터한후 달력의 월로 그룹화 한뒤 모든 관측치 보이는 동물수 합치기
db.observations.mapReduce(
function map() { 
var year = this.observationTimestamp.getFullYearO；
var month = this.observationTimestamp.getMonth() + 1；
emit(year + "-" + month, this.numAnimals)； 
},

function reduce(key, values) { 
	return Array.sum(values)； 
{
	query： { family： "Sharks" }
	out："monthlySharkReport" 
}
)；
```

- 몽고 DB 의 map, reduce 는 **순수 함수**여야 한다는 제약사항이 있다
- 맵리듀스의 사용성 문제는 연계된 함수를 신중하게 작성해야 해서 하나의 질의 작성보다 어렵다
- 몽고 2.2 부터 집계 파이프라인 이라는 선언형 질의 언어 지원을 추가했다

![스크린샷 2025-08-27 오전 7.55.03.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_7.55.03.png)

## 그래프형 데이터 모델

- 관계형 모델은 단순한 다대다 관계를 다루지만, 데이터간 연결이 더 복잡해지면 그래프로 데이터를 모델링 하는것이 더 자연스럽다
- 그래프는 두 유형의 객체로 이뤄진다
    - 정점 → 노드 or 엔티티
    - 간선 ⇒ 관계 or 호
- 일반적인 그래 모델링 예시
    - 소셜 그래프
    - 웹 그래프
    - 도로나 철도 네트워크

![스크린샷 2025-08-27 오전 7.57.01.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_7.57.01.png)

### 속성 그래프

- 속성 그래프 모델에서 각 정점의 구성요소
    - 고유 식별자
    - 유출 간선 집합
    - 유입 간선 집합
    - 속성 컬렉션 (키-값 쌍)
- 각 간선의 구성 요소
    - 고유 식별자
    - 간선이 시작하는 정점 (꼬리 정점)
    - 간선이 끝나는 정점 (머리 정점)
    - 두 정점 간 관계 유형을 설명하는 레이블
    - 속성 컬렉션 (키-값 쌍)

### 사이퍼 질의 언어

- 사이퍼 → 속성 그래프를 위한 선언헌 질의 언어 neo4j 용으로 만들어 졌다

```sql
// 그림2-5 를 사이퍼 질의로 표현
CREATE
(NAmerica：Location {name： 'North America’z type：'continent'}),
(USA：Location {name：'United States', type：'country' }),
(Idaho：Location {name：'Idaho'z type：'state' }),
(Lucy：Person {name：'Lucy' }),
(Idaho) -[:WITHIN]-〉(USA) -[：WITHIN]-> (NAmerica),
(Lucy) -[:B0RN_IN]-> (Idaho)
```

- **미국에서 유럽으로 이민온 모든 사람들의 이름 찾기** 같은 질의가 가능해짐
    
    ![스크린샷 2025-08-27 오전 8.03.06.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.03.06.png)
    

## SQL 의 그래프 질의

- RDBMS 에서도 가능은 하지만 어렵다
- 질의에 필요한 조인을 미리 알고 있어야 하고, 가변적인 여러 간선을 순회해야 한다
    - 재귀 공통 테이블 식 을 사용해 표현이 가능하다
    - WITH RECURISVE

![스크린샷 2025-08-27 오전 8.05.43.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.05.43.png)

![스크린샷 2025-08-27 오전 8.06.06.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.06.06.png)

![스크린샷 2025-08-27 오전 8.06.21.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.06.21.png)

### 트리플 저장소와 스파클

- 트리플 저장소 모델은 속성 그래프 모델과 거의 동등하다
- 트리플 저장소에서는 모든 정보를 매우 간단한 세 부분 구문 형식으로 저장한다
    - 주어, 서술어, 목적어
- 트리플의 주어 → 그래프의 정점과 동일, 목적어는 아래 둘중 한가지
    - 문자열이나 숫자 같은 원시 데이터타입의  값
    - 그래프의 다른 정점

![스크린샷 2025-08-27 오전 8.09.40.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.09.40.png)

![스크린샷 2025-08-27 오전 8.09.55.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.09.55.png)

- 2-5 를 Turtle 트리플로 표현

### 시맨틱 웹

- 트리플 저장소 데이터 모델은 시맨틱 웹과 완전 독립적이다
- 시맨틱 웹 → 컴퓨터가 읽게끔 기계가 판독가능한 데이터로도 정보를 게시하자는 개념
- 자원 기술 프레임워크 (Resource Description Framework, RDF) 는 서로 다른 웹사이트가 일관된 형식으로 데이터를 게시하기 위한 방법을 제안
- RDF → 서로 다른 웹사이트의 데이터가 일종의 전 인터넷 만물데이터베이스인 데이터 웹에 자동으로 결합할 수 있게 한다

![스크린샷 2025-08-27 오전 8.14.09.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.14.09.png)

![스크린샷 2025-08-27 오전 8.14.14.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.14.14.png)

### 스파클 질의 언어

- RDF 데이터 모델을 사용한 트리플 저장소 질의 언어
- 사이퍼보다 먼저 만들어지고, 사이퍼의 패턴 매칭을 스파클에서 차용했기 때문에 매우 유사해보인다

![스크린샷 2025-08-27 오전 8.15.50.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.15.50.png)

### 초석 : 데이터로그

- 스파클이나 사이퍼보다 훨씬 오래된 언어, 질의 언어의 기반이 되는 초석을 제공한다
- 데이토믹 → 데이터로그를 질의 언어로 사용
- 캐스캘로그 → 데이터로그의 구현체로 하둡의 대용량 데이터셋 질의 용도
- 트리플 저장소모델과 유사하지만 좀 더 일반화됨
    - 서술어 (주어, 목적어) 로 작성한다

![스크린샷 2025-08-27 오전 8.22.55.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.22.55.png)

![스크린샷 2025-08-27 오전 8.24.05.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-08-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_8.24.05.png)

- 데이터로그는 단계는 나눠 한번에 조금씩 질의 한다
    - 새로운 서술어를 데이터베이스 전달하는 규칙 을 정의
        - within_recursive, migrated
    - 서술어는 데이터나 다른 규칙으로부터 파생되며, 규칙은 함수가 다른 함수를 호출하거나 다른 규칙을 참조할 수 있다
    - 대문자로 시작하는 단어 → 변수

