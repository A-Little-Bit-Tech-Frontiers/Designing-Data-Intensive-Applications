# 7장 트랜잭션

## 서론

- 데이터 시스템에서 여러 문제가 생길 수 있는데, 시스템 신뢰성을 위해 내결함성을 갖춰야 한다
- 이런 문제를 단순화 하기 위해,  트랜잭션을 단순화 하는 메커니즘으로 채택되어 왔다
    - 전체가 성공하거나 실패, ALL or Nothing
- 문제 방지를 위한 여러 방식과, 동시성 제어 기법 살펴보기

## 트랜잭션 ACID

- 트랜잭션이 제공하는 안전성 보장 ACID
- ACID 표준을 따르지 않는 시스템은 BASE
    - 가용성 제공 (Basicallly Available)
    - 유연한 상태 (Soft state)
    - 최종적 일관성 (Eventually consistency)
- **원자성(Atomicity)**: 트랜잭션의 작업은 전부 반영되거나(커밋) 전부 폐기(롤백)된다
- **일관성(Consistency)**: 애플리케이션이 정의한 불변식이 트랜잭션 전후로 유지되어야 한다
- **격리성(Isolation)**: 동시에 실행돼도 마치 **직렬(하나씩 순서대로)** 실행된 것 같은 결과가 나오게 한다
- **지속성(Durability)**: 커밋된 결과는 장애 후에도 남는다(로그·복제·스냅샷 등으로 구현)

## 단일 객체 연산과 다중 객체 연산

**원자성**: 실행 중 오류가 나면 전체 작업을 **어보트(rollback)** 하여 부분 결과가 남지 않도록 함

**격리성**: 서로 다른 트랜잭션이 **상호 간섭**하지 않도록 함

- **더티 읽기(Dirty Read)**: 커밋되지 않은 데이터를 읽음(그림 7-2)
- **일관성 깨짐**: 한쪽은 삽입을 봤는데 카운터는 증가 전 등 (그림 7-3)

![스크린샷 2025-09-28 190802.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2025-09-28_190802.png)

![스크린샷 2025-09-28 190813.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2025-09-28_190813.png)

- **다중 객체 트랜잭션**: 여러 레코드가 **동시에 일관된 상태**여야 할 때 필요
    - 예) ‘읽지 않은 메시지 수’ 카운터 유지: 이메일 삽입과 카운터 증가가 함께 성공/실패해야 함.
- 트랜잭션이 없으면 서로 다른 읽기·쓰기 사이가 불일치(예: 사용자2가 본 읽지 않은 개수=0) 발생.

### 단일 객체 쓰기

- 저장소 엔진은 보통 **단일 객체** 수준에서 원자성/격리성을 기본 제공.
- 더 복잡한 단일 객체 원자적 연산은 **Compare-and-Set(CAS)** 같은 조건부 쓰기로 구현(동시 갱신 손실 방지)
    - 흔히 “경량 트랜잭션”이라 부르지만 **다중 객체 트랜잭션**과는 다르다

### 다중 객체 트랜잭션의 필요성

- 관계형 모델의 **참조 일관성**(여러 테이블/행 동시 갱신) 유지
- 문서 모델에서 **여러 문서 동시 갱신** 필요(예: 역정규화된 필드 동기화)
- **보상/보류 불가한 업무 규칙**을 한 단위로 처리
- 많은 분산 저장소는 구현 난이도·성능 이유로 **다중 객체 트랜잭션을 포기**하지만, 그렇다고 트랜잭션을 막을 이유는 없다

### 오류와 어보트 처리

- 트랜잭션의 핵심기능 → 오류가 발생하면 어보트 하고 안전하게 재시도 가능한 것
- ACID DB는 위험 시 **트랜잭션 전체를 폐기**. 반면 일부 시스템(특히 리더 없는 복제)은 **Best Effort**로 부분 반영 가능 → **애플리케이션이 재시도** 책임을 져야 함
- 어보트 재시도는 유용하지만 한계가 있음
    - 네트워크 끊김 시 **중복 실행** 가능(추가 중복 제거 필요)
    - **일시 오류**(타임아웃·잠금 충돌)엔 지수 백오프가 도움
    - 외부 부수효과(이메일 발송 등)가 얽히면 **정확히 한 번** 보장 어려움(2단계 커밋 등 별도 기법 필요)
    - 클라이언트 재시동 중이면 중복·유실 모두 가능 → 애플리케이션 설계로 방지

## 완화된 격리 수준

- 강한 직렬화는 이상적이지만 비용 큼.  DB는 **완화된 격리 수준**을 제공.
- **Read Committed(커밋 후 읽기)**
    - 보장 ① **더티 읽기 금지**: 커밋된 값만 읽음(그림 7-4).
    - 보장 ② **더티 쓰기 금지**: 커밋되지 않은 쓰기 위에 또 쓰는 것 금지(그림 7-5).
    - 구현: **행(로우) 잠금**으로 쓰기 보호, 읽기엔 커밋 후 값만 보이게 처리.
    - 여전히 남는 문제: **비반복 읽기/읽기 스큐**(그림 7-6) — 같은 트랜잭션 내 두 번 읽으면 값이 바뀔 수 있음.

![스크린샷 2025-09-28 191006.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2025-09-28_191006.png)

![스크린샷 2025-09-28 191024.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2025-09-28_191024.png)

![스크린샷 2025-09-28 191039.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2025-09-28_191039.png)

- **Snapshot Read & 반복 읽기**
    - 트랜잭션이 시작된 순간의 **일관된 스냅샷**을 읽게 하여, 실행 중 **과거 커밋 시점의 값**만 보게 함(더티 읽기·비반복 읽기 방지).
    - 구현은 DB별 상이(MVCC 기반 등).
    - 트랜잭션 간 **동시 쓰기 충돌**이나 **업데이트 스큐** 등은 추가 제어 필요

### 스냅샷 격리

- **문제 배경**
    - 백업/분석처럼 오래 도는 읽기 작업은 실행 중에 데이터가 바뀌면 의미가 휘청인다.
    - 이런 “일관된 시점”이 필요한 읽기를 위해 **스냅샷 격리**를 쓴다. 트랜잭션 시작 시점의 **일관된 스냅샷**만 읽는다.
- **MVCC(다중 버전 동시성 제어)**
    - DB는 한 객체의 여러 버전을 함께 유지한다. 각 행에는 `created_by(생성한 트랜잭션 ID)`, `deleted_by(삭제 표식)` 같은 메타가 붙는다.
    - 트랜잭션 T가 시작되면 자신의 **txid**보다 나중에 생성/삭제된 버전은 보이지 않는다.
    - 커밋 규칙(전형적 구현):
        1. 트랜잭션 시작 이후에 **생성**된 데이터는 무시,
        2. **어보트된** 트랜잭션이 쓴 데이터는 무시,
        3. 현재 진행 중인(커밋/어보트 미정) 트랜잭션이 쓴 데이터는 무시,
        4. 나머지는 애플리케이션의 질의 결과로 간주.
    - 오래 지속된 트랜잭션은 “오래된 스냅샷”을 본다(다른 트랜잭션에서 이미 삭제된 값을 계속 읽을 수 있음) → VACUUM/컴팩션으로 청소 필요.
- **색인과 스냅숏 격리**
    - 포스트그레스/LMDB 등은 **append-only/copy-on-write B-트리**를 사용: 변경 시 기존 페이지는 그대로 두고 새 페이지를 만들어 링크 변경.
    - 장점: 과거 버전 탐색이 쉬워 스냅샷 읽기와 궁합이 좋다(반복 읽기에 유용). 단, 백그라운드 컴팩션 필요.
- **반복 읽기와 혼란스러운 이름**
    - 많은 DB가 스냅샷 격리를 “**Repeatable Read(반복 읽기)**”라 부른다(오라클=직렬성, PostgreSQL/MySQL=Repeatable Read). SQL 표준 정의와 구현은 종종 어긋난다.

### 갱신 손실 방지

- **갱신 손실**: 두 트랜잭션이 같은 값을 읽고 각각 수정하여 마지막 쓰기가 앞선 변경을 덮어씀(예: 카운터 증가/감소, 문서의 일부 편집).
- **해결책**
    1. **원자적 쓰기 연산**(increment 등): read-modify-write를 DB 연산 하나로 제공(동시성 안전). 일부 문서 DB는 문서 내 부분 업데이트 연산 제공.
    2. **명시적 잠금**(예: `SELECT … FOR UPDATE`): 읽는 즉시 배타 잠금으로 경쟁 차단. 올바른 위치에 잠금을 잊지 않도록 주의.
    3. **자동 감지 후 재시도**: DB가 스냅샷 격리 위에서 write–write 충돌을 감지하면 트랜잭션을 어보트하고 애플리케이션이 재시도(포스트그레스, 오라클 등). MySQL/InnoDB의 Repeatable Read는 기본적으로 자동 감지가 제한적일 수 있음.
    4. **Compare-and-Set**: “읽은 값이 아직 같으면 갱신” 조건부 업데이트. 스냅샷에서 읽은 값과 현재 값이 다르면 실패 → 재시도. 단, DB의 구현 방식에 따라 안전성이 다를 수 있어 주의.

### 충돌 해소와 복제

- **CAS/잠금만으로는 부족**: 복제 환경에서 동시에 쓰기가 일어나면, 단일 노드에서 쓰기를 직렬화한다는 전제(잠금, compare-and-set)가 깨지므로 충돌을 막지 못함.
- **형제(sibling) 버전**: 같은 객체에 대해 여러 버전이 동시에 생길 수 있음 → 애플리케이션이 **도메인 규칙**으로 병합해야 함.
- **교환 법칙이 성립하는 연산**은 자동 병합에 유리
    - 예) 카운터 증감, 집합의 추가/삭제 등은 순서가 달라도 같은 결과 → CRDT류 아이디어.
- **LWW(Last Write Wins)**: 가장 단순한 자동 해법이나 데이터 유실 위험 큼(시간/시계 의존).

### 쓰기 스큐와 팬텀

- **쓰기 스큐**: 두 트랜잭션이 서로 다른 행(객체)을 갱신하지만 **공유 제약을 함께 깨뜨리는** 상황.
    - 예) 당직 의사 최소 1명 규칙: 두 의사가 각각 자기 레코드만 off로 바꾸면 규칙 위반.
- **발생 패턴(체크-후-쓰기)**
    1. 조건 확인을 위해 SELECT(“현재 on_call=TRUE인 의사 수 카운트”)
    2. 조건이 안전하다고 판단 → UPDATE 실행
    3. 둘이 거의 동시에 하면 서로의 변경을 반영하지 못해 규칙 위반
- **스냅샷 격리만으로는 방지 불가**: 읽기 전용 트랜잭션끼리는 안전하지만, **조건에 부합하는 “행의 집합”이 바뀌는 팬텀**을 막지 못함.

![스크린샷 2025-09-28 205318.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2025-09-28_205318.png)

### 쓰기 스큐를 특징짓기

- *명시적 잠금(SELECT … FOR UPDATE)**으로 “조건에 부합하는 대상”을 **잠글 수 있을 때** 해결 가능.
    - 당직 예시: `WHERE on_call=true AND shift_id=? FOR UPDATE` 로 대상 행들을 선점 → 서로 배타적으로 업데이트.
- **제약을 ‘구체화’(materializing conflict)**:
    - 팬텀은 “조건으로 정의된 집합” 때문에 생김 → 그 집합을 **구조화된 행**으로 만들어 잠글 수 있게 함.
    - 예) 회의실 예약
        - 시간 슬롯 테이블(15분 단위 등)을 만들어 회의실×시간 슬롯 행을 미리 생성
        - 예약 트랜잭션이 해당 슬롯 행들을 `FOR UPDATE`로 잠근 뒤 예약을 기록
        - 이렇게 **충돌을 테이블의 행 잠금**으로 변환해 방지
- **도구 선택 가이드**
    - 단순 카운터/집합 → 교환법칙 연산(원자적 갱신, CRDT 성격) 활용 가능.
    - 도메인 규칙(유일성, 최소/최대, 일정 겹침 금지 등)이 얽힌 경우 → **강한 직렬화 수단**이 필요:
        - 행 잠금, 범위 잠금(인덱스/갭 잠금), 물리적 슬롯 테이블로의 **충돌 구체화**,
        - 혹은 **직렬화 격리 수준**(Serializable) 채택.
- **주의**: 스냅샷 격리나 반복 읽기(Repeatable Read)만으로는
    - 스큐/팬텀, 스케줄 충돌, 유일성 경쟁(동시 가입, 중복 결제) 등을 완벽히 못 막음.
    - 체크-후-쓰기 패턴을 쓰면 **반드시 잠금 또는 직렬화**로 보강.

### 쓰기 스큐 예시

- **회의실 예약**: 단순 “COUNT=0이면 INSERT”는 경합 시 팬텀으로 뚫림 → 슬롯 테이블 + `FOR UPDATE`로 해결.
- **멀티플레이어 게임**: “두 플레이어가 같은 위치 점유 금지”는 잠금만으로는 움직임/규칙까지 보장하기 어려움 → 모델링(충돌 구체화) 필요.
- **사용자명 유일성**: 스냅샷 격리에서 중복 생성 위험 → **유니크 인덱스 + 충돌 재시도**가 현실적.
- **이중 사용(Double-spending)**: 잔고 집계형 시스템은 **원자적 차감** 또는 **보류/락**으로 보장.

## 직렬성

- 여러 트랜잭션이 동시에 실행돼도 결과가 **마치 순차(직렬)로 실행된 것과 동일**하도록 보장하는 가장 강한 격리 수준
- **SSI(Serializable Snapshot Isolation)**: 스냅숏 격리 위에 “직렬성 보장”을 덧씌우는 알고리즘
- 완전한 직렬성을 제공하면서도 2단계 잠금(2PL)보다 **성능 손실이 작다**
- 비교적 최근(2008년경 학술화) 개념이며, 오늘날 단일 노드 DB(예: PostgreSQL 9.1+)와 분산 DB에서 널리 채택 하고 있음
- 직렬성을 달성하는 대표 방식 3가지
    - 실제로 직렬로 실행하기  (단일스레드 순차실행)
    - 2단계 잠금 (2PL)
    - 직렬화 가능한 스냅숏 격리 (SSI)

### 실제적인 직렬 실행

- 트랜잭션을 한 번에 하나씩, **단일 스레드**에서 실행 → 모든 경쟁 조건 제거해 버리자
- 메모리 가격 하락으로 **작은 OLTP 트랜잭션은 메모리 상주 데이터**만 만져도 됨. 짧은 질의 위주인 OLTP에서는 단일 스레드 처리도 충분한 경우가 많음.
- 처리량이 한 CPU 코어의 처리량으로 한정됨
- **스토어드 프로시저**
    - 트랜잭션 로직을 DB 서버로 캡슐화
    - 전통 PL/SQL은 생산성/운영성 제약이 있었지만, **현대 구현**은 자바/그루비/루아/클로저 등 범용 언어를 지원하는 사례도 있음
    - **복제 환경**에선 결정적(deterministic) 실행이 중요하다
- **파티셔닝**
    - 데이터를 파티션으로 나눠 **파티션마다 단일 스레드**로 직렬 처리 → CPU 코어 수만큼 수평 확장.
    - **교차 파티션 트랜잭션**은 조정 비용이 커지므로(잠금·2PC 등) 가능하면 **단일 파티션에 국한**되게 모델링

### 2단계 잠금 (2PL)

- 트랜잭션은 **필요한 잠금(공유/독점)을 모두 획득**한 뒤에야 진행하고, **커밋/어보트까지 잠금을 유지**
- → 읽는 쪽은 쓰는 쪽을, 쓰는 쪽은 읽는 쪽을 막아 **모든 경쟁 조건을 차단**
- **공유(Shared)·독점(Exclusive)·업그레이드**
    - 읽기: 공유 잠금 선점 → 다른 트랜잭션도 공유 잠금은 가능, 독점은 불가.
    - 쓰기: 독점 잠금 필요 → 다른 공유/독점 잠금이 있으면 **대기**.
    - 이미 공유 중인 행을 수정하려면 **업그레이드**가 발생(교착의 원인).
- **성능 특성**
    - 잠금 획득/해제 오버헤드 + **대기**로 인해 레이턴시·처리량 저하.
    - 접근 패턴에 따라 **교착상태**가 자주 생김 → 타임아웃/어보트 후 재시도 필요.
    - 그래도 **가장 보편적으로 쓰이는 직렬성 구현**(MySQL/InnoDB, SQL Server 등의 “Serializable”은 2PL 기반인 경우가 많음).
- **팬텀(phantom) 해결: 서술 잠금 & 색인 범위 잠금**
    - **서술(프레디케이트) 잠금**: `WHERE` 조건에 **부합하는 모든 객체**(현재+미래)에 대한 논리적 잠금. 이상적이지만 구현·비용이 큼.
    - **색인 범위/넥스트-키 잠금**: 실무적 대안. **인덱스 범위** 자체를 잠가 새로운 행 삽입/변경으로 조건을 만족하게 만드는 것을 차단.
        - 적절한 인덱스가 있으면 **조건 범위만 잠금** → 팬텀·쓰기 스큐 방지.
        - 인덱스가 없으면 **테이블 잠금** 등으로 대체(성능 저하 감수).

### 서술 잠금과 색인 범위 잠금

- “특정 시간대에 같은 회의실 **중복 예약을 금지**”하려면:
    1. 먼저 `SELECT … WHERE room_id=… AND time overlaps …` 로 **검색 조건에 대한 공유(혹은 전용) 서술 잠금**을 잡음.
    2. 삽입/갱신 트랜잭션은 그 조건에 **겹치는 범위에 독점 잠금**이 있으면 커밋까지 대기.
- 실무에선 **서술 잠금 대신 색인 범위 잠금**을 사용: `room_id, start_time, end_time` 등에 인덱스/넥스트-키 잠금을 걸어 겹치는 기간에 대한 갱신을 차단. 적절한 인덱스가 없으면 넓은 범위(심지어 테이블) 잠금으로 대체.

## 직렬성 스냅숏 격리 (SSI)

- **직렬 실행/2PL**: 직렬성 확실하지만 성능·확장성 낮음
- **완화된 격리(스냅숏 격리 등)**: 성능은 좋지만 쓰기 스큐·팬텀·갱신 손실 위험
- **SSI(Serializable Snapshot Isolation)**: 스냅숏 격리 위에 충돌 감지·어보트(중단)를 더해 **직렬성에 가깝고 성능 저하가 적은** 알고리즘

### 비관적 동시성 제어 vs 낙관적 동시성 제어

- **2PL → 비관적 동시성 제어**
- **SSI → 낙관적 동시성 제어**
    - 우선 실행하고, **위험 징후가 확인되면 어보트**. 경쟁이 심할수록 어보트가 늘어 성능 저하
    - 모든 읽기는 **MVCC 스냅숏**에서 수행 한다
    - 트랜잭션 사이의 **쓰기-읽기 의존**을 추적해, 직렬성 위반이 될 경로가 생기면 가해 트랜잭션을 **어보트**
    - 스냅숏 위에서 **직렬성 판단을 위한 추가 알고리즘**만 결합

### 뒤처진 전제에 기반한 결정

- 애플리케이션은 “현재 상태”를 읽어 **결정** 후 쓰기.
- 스냅숏 읽기는 과거 상태일 수 있으므로, **그 결정이 커밋 시점에는 유효하지 않을 수 있음**
- DB는 질의 결과가 바뀌었는지 추적하여 **유효하지 않으면 어보트**
    - 두가지 상황을 고려 해야함

### 오래된 MVCC 읽기 감지하기

![스크린샷 2025-09-30 232424.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2025-09-30_232424.png)

- T1이 읽을 땐 보이지 않던 T2의 쓰기가 **T1보다 먼저 커밋**되어 T1의 근거를 무너뜨리면 충돌
- T1 커밋 시점에 “내가 읽은 버전이 오래됨”이 드러나면 **T1 또는 T2 중 하나 어보트 해야함**

### 과거 읽기에 영향을 미치는 쓰기 감지

![스크린샷 2025-09-30 232600.png](%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2025-09-30_232600.png)

- T1이 **조건/범위**(WHERE 절)로 읽은 집합을 **T2가 나중에 변경/삽입/삭제** → T1의 판단 근거 변조.
- SSI는 **프레디킷(조건) 기반 범위 추적**을 하고, 해당 범위를 바꾸는 쓰기 커밋 때 **충돌 표식(tripwire)** 를 남겨 **위험한 순환**을 판정.
- **색인 범위 잠금(= next-key / index-range 개념)**
    - MySQL next-key-lock, gap-lock 과 비슷한 의도
- SSI에서는 전통적 잠금처럼 막아두기보다 **읽은 범위를 추적**하고 그 위로 쓰기가 지나가면 **충돌로 판단**

### 성능

- **읽기는 잠금 없이**, 마지막에 **쓰기에 대해서만** 충돌 판단 → OLTP에서 **예측 가능·낮은 지연**.
- 긴 읽기 전용 트랜잭션은 유리하나, **쓰기 많은 워크로드**에서 **어보트율**이 성능을 좌우한다
- 분산/파티셔닝 환경에서는 **직렬성 보장 + 확장성**을 위해 장비/파티션 간 **읽기·쓰기 추적**이 필요
