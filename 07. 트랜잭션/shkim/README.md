# 트랜잭션

데이터 시스템의 냉혹한 현실에서는 많은 일이 잘못될 수 있다:

- 데이터베이스 소프트웨어나 하드웨어가 언제든지 실패할 수 있다(쓰기 작업 중간에도).
- 애플리케이션이 언제든지 크래시될 수 있다(여러 작업을 수행하는 도중에도).
- 네트워크 중단으로 인해 애플리케이션이 데이터베이스와, 또는 데이터베이스 노드 간의 연결이 끊길 수 있다.
- 여러 클라이언트가 동시에 데이터베이스에 쓰기를 시도해 서로의 변경사항을 덮어쓸 수 있다.
- 일부만 업데이트된 데이터를 읽어 논리적으로 맞지 않는 데이터를 읽을 수 있다.
- 클라이언트 간의 경쟁 조건(race condition)으로 인해 예기치 못한 버그가 발생할 수 있다.

시스템이 신뢰할 수 있으려면 이러한 결함을 처리하고 전체 시스템의 치명적인 실패로 이어지지 않도록 해야 한다. <br>
하지만 장애 허용(fault tolerance) 메커니즘을 구현하는 것은 많은 작업이 필요하다.

수십 년 동안 **트랜잭션**은 이러한 문제를 단순화하는 데 사용되어 왔다. <br>
트랜잭션은 애플리케이션이 여러 번의 읽기와 쓰기를 논리적인 하나의 단위로 묶을 수 있는 방법이다. <br>
개념적으로 트랜잭션 내의 모든 읽기와 쓰기는 하나의 작업처럼 실행된다: 트랜잭션 전체가 성공(커밋)하거나, 실패(중단, 롤백)한다. <br>
실패할 경우 애플리케이션은 안전하게 재시도할 수 있다. 트랜잭션을 사용하면 일부 작업만 성공하고 일부는 실패하는(부분 실패) 상황에 대해 신경 쓸 필요가 없어져 애플리케이션의 오류 처리가 훨씬 간단해진다.

트랜잭션을 사용하면 애플리케이션은 특정 오류 시나리오와 동시성 문제를 무시할 수 있다. <br>
데이터베이스가 이를 대신 처리해주기 때문이다(이를 **안전성 보장**이라고 한다).

## 트랜잭션이라는 애매모호한 개념

오늘날 거의 모든 관계형 데이터베이스와 일부 비관계형 데이터베이스는 트랜잭션을 지원한다. <br>
2000년대 후반, 비관계형(NoSQL) 데이터베이스가 인기를 얻기 시작했다. <br>
이들은 새로운 데이터 모델을 제공하고, 기본적으로 복제와 파티셔닝을 지원함으로써 관계형 데이터베이스의 한계를 개선하려 했다. <br>
이 과정에서 트랜잭션은 주요 희생양이 되었다: 이 새로운 세대의 데이터베이스 중 상당수는 트랜잭션을 완전히 포기하거나, 이전보다 훨씬 약한 보장만을 의미하는 용어로 재정의했다.

이러한 분산 데이터베이스의 유행과 함께, 트랜잭션이 확장성의 적이며, 대규모 시스템에서는 좋은 성능과 높은 가용성을 위해 트랜잭션을 포기해야 한다는 믿음이 퍼졌다. <br>
반면, 트랜잭션 보장은 “중요한 애플리케이션”과 “가치 있는 데이터”를 위한 필수 요소라고 주장하는 데이터베이스 벤더들도 있다. 두 관점 모두 과장이다.

**진실은 그리 단순하지 않다: 다른 모든 기술적 설계 선택과 마찬가지로 트랜잭션도 장점과 한계가 있다.**

## ACID의 의미

- **ACID**: 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 지속성(Durability)
- **BASE**: 기본적으로 사용 가능(Basically Available), 소프트 상태(Soft state), 최종적 일관성(Eventual consistency)

### 원자성(Atomicity)

일반적으로 원자적(atomic)이라는 것은 더 이상 쪼갤 수 없는 것을 의미한다.

ACID의 원자성은 클라이언트가 여러 번의 쓰기를 하다가 일부만 처리된 상태에서 장애가 발생할 때 어떻게 되는지를 설명한다. <br>
예를 들어, 프로세스가 크래시되거나, 네트워크 연결이 끊기거나, 디스크가 가득 차거나, 무결성 제약 조건이 위배된 경우 등이다. <br>
이러한 쓰기들이 원자적 트랜잭션으로 묶여 있다면, 트랜잭션이 완료(커밋)되지 못할 경우 트랜잭션은 중단되고, 데이터베이스는 지금까지 이 트랜잭션에서 수행한 모든 쓰기를 폐기하거나 되돌려야 한다.

오류 발생 시 트랜잭션을 중단하고, 해당 트랜잭션의 모든 쓰기를 폐기할 수 있는 능력이 ACID 원자성의 핵심이다.

### 일관성(Consistency)

ACID에서 일관성은 데이터베이스가 “좋은 상태”에 있다는 애플리케이션 고유의 개념을 의미한다.

ACID 일관성의 핵심은 데이터에 대해 항상 참이어야 하는 어떤 명제(불변식, invariant)가 있다는 것이다. <br>
예를 들어, 회계 시스템에서는 모든 계좌의 입금과 출금이 항상 균형을 이루어야 한다.

하지만 이러한 일관성은 애플리케이션의 불변식에 달려 있으며, 이를 지키는 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임이다. <br>
데이터베이스는 잘못된 데이터를 쓰는 것을 막아줄 수 없다(일부 불변식은 외래 키 제약이나 유일성 제약 등으로 검사할 수 있지만, 일반적으로 올바른 데이터인지 여부는 애플리케이션이 정의하고 데이터베이스는 그저 저장할 뿐이다).

원자성, 고립성, 지속성은 데이터베이스의 속성이지만, 일관성(ACID 의미의)은 애플리케이션의 속성이다. <br>
애플리케이션은 데이터베이스의 원자성과 고립성에 의존해 일관성을 달성할 수 있지만, 데이터베이스만으로 달성되는 것은 아니다.

### 고립성(Isolation)

ACID에서 고립성이란 동시에 실행되는 트랜잭션들이 서로 격리되어 있다는 뜻이다. <br>
고전적인 데이터베이스 교과서는 고립성을 **직렬 가능성(serializability)** 으로 공식화한다. <br>
즉, 각 트랜잭션은 자신만 데이터베이스에서 실행되고 있다고 가정할 수 있다. <br>
데이터베이스는 트랜잭션들이 커밋된 후의 결과가 실제로는 동시에 실행되었더라도, 마치 순차적으로(하나씩) 실행된 것과 동일하도록 보장한다.

### 지속성(Durability)

지속성이란 트랜잭션이 성공적으로 커밋된 후에는, 해당 트랜잭션이 기록한 데이터가 하드웨어 장애나 데이터베이스 크래시가 발생해도 잊혀지지 않는다는 약속이다.

단일 노드 데이터베이스에서는 일반적으로 데이터가 하드 드라이브나 SSD와 같은 비휘발성 저장장치에 기록되는 것을 의미한다. <br>
또한, 디스크의 데이터 구조가 손상될 경우 복구할 수 있도록 **write-ahead log** 같은 로그를 사용한다. <br>
복제 데이터베이스에서는 데이터가 여러 노드에 성공적으로 복제된 것을 의미할 수 있다. <br>
데이터베이스가 지속성 보장을 하려면 이러한 쓰기나 복제가 완료될 때까지 트랜잭션의 성공을 보고하지 않아야 한다.

## 단일 객체 및 다중 객체 연산

ACID에서 원자성(모두 또는 전혀 없음 보장)과 고립성(모두 또는 전혀 없음)은 클라이언트가 하나의 트랜잭션 내에서 여러 객체(행, 문서, 레코드)를 동시에 수정하고자 할 때 데이터베이스가 어떻게 동작해야 하는지를 설명한다. 여러 데이터를 동기화해야 하는 경우 이러한 **다중 객체 트랜잭션**이 필요하다.

다중 객체 트랜잭션은 어떤 읽기/쓰기 연산이 동일 트랜잭션에 속하는지 구분할 방법이 필요하다. <br>
관계형 데이터베이스에서는 일반적으로 클라이언트와 데이터베이스 서버 간의 TCP 연결을 기준으로, BEGIN TRANSACTION과 COMMIT 사이의 모든 연산이 하나의 트랜잭션으로 간주된다. <br>
반면, 많은 비관계형 데이터베이스는 이런 식의 그룹핑 방법이 없다.

<img width="757" height="326" alt="Image" src="https://github.com/user-attachments/assets/53ca8825-3f22-4300-b1b7-dbae8e04b978" /> <br>
<img width="733" height="225" alt="Image" src="https://github.com/user-attachments/assets/e0d5c550-3b93-405e-8ee0-8370699d9f79" />

### 단일 객체 쓰기

원자성과 고립성은 단일 객체를 변경할 때도 적용된다. 거의 모든 저장 엔진은 단일 객체(예: 하나의 키-값 쌍) 수준에서 원자성과 고립성을 제공하려고 한다.

## 완화된 격리 수준

동시성 문제(경쟁 조건)는 한 트랜잭션이 다른 트랜잭션에 의해 동시에 수정된 데이터를 읽거나, 두 트랜잭션이 동시에 같은 데이터를 수정하려고 할 때 발생한다.

이러한 동시성 버그는 타이밍이 맞아떨어질 때만 발생하므로 테스트로 찾기 어렵고, 재현도 힘들다. <br>
특히, 대규모 애플리케이션에서는 어떤 코드가 데이터베이스에 접근하는지 알기 어려워 동시성 문제를 파악하기가 매우 어렵다.

이 때문에 데이터베이스는 오랫동안 애플리케이션 개발자에게 동시성 문제를 숨기기 위해 트랜잭션 고립성을 제공해왔다. <br>
이론적으로 고립성은 동시성이 전혀 없는 것처럼 생각할 수 있게 해준다. **직렬 가능 고립성(serializable isolation)** 은 트랜잭션이 순차적으로 실행된 것과 동일한 효과를 보장한다.

그러나 현실적으로 직렬 가능 고립성은 성능 비용이 크기 때문에, 많은 데이터베이스는 비용을 감수하지 않으려 한다. 그래서 일부 동시성 문제만을 막는 **더 약한 고립성 수준**이 흔히 사용된다.

### Read Committed

가장 기본적인 트랜잭션 고립성 수준은 **read committed**이다. 두 가지를 보장한다:

- 데이터베이스에서 읽을 때, 커밋된 데이터만 볼 수 있다(더러운 읽기 없음).
- 데이터베이스에 쓸 때, 커밋된 데이터만 덮어쓸 수 있다(더러운 쓰기 없음).

두 트랜잭션이 동시에 같은 객체를 업데이트하려고 하면, 어느 쪽이 먼저 쓰게 될지 알 수 없지만, 일반적으로 나중에 쓴 값이 앞선 값을 덮어쓴다. <br>
하지만 앞선 쓰기가 아직 커밋되지 않은 상태에서 나중 쓰기가 그 값을 덮어쓰면, 이를 **더러운 쓰기(dirty write)** 라고 한다. <br>
read committed 수준에서는 더러운 쓰기를 막아야 하며, 보통 두 번째 쓰기를 첫 번째 트랜잭션이 커밋되거나 중단될 때까지 지연시켜 해결한다.

read committed는 매우 인기 있는 고립성 수준이며, Oracle 11g, PostgreSQL, SQL Server 2012, MemSQL 등에서 기본값이다.

## 스냅샷 고립성 및 반복 읽기

**스냅샷 고립성(snapshot isolation)** 은 위의 문제(예: $100이 사라지는 것처럼 보이는 **nonrepeatable read** 또는 **read skew**)를 해결하는 가장 흔한 방법이다. <br>
각 트랜잭션은 데이터베이스의 일관된 스냅샷에서 읽는다. 즉, 트랜잭션이 시작될 때 커밋된 모든 데이터를 읽으며, 그 이후 다른 트랜잭션이 데이터를 변경해도 현재 트랜잭션에서는 이전 상태의 데이터만 본다. <br>
스냅샷 고립성은 백업이나 분석 등 장기 실행 읽기 전용 쿼리에 매우 유용하다.

스냅샷 고립성은 PostgreSQL, MySQL(InnoDB 스토리지 엔진), Oracle, SQL Server 등에서 지원된다.

<img width="652" height="545" alt="Image" src="https://github.com/user-attachments/assets/81ce9664-57bd-48a5-84fb-131d8edac703" />

## 업데이트 손실 방지

지금까지 논의한 read committed와 snapshot isolation은 주로 읽기 전용 트랜잭션이 동시 쓰기 상황에서 무엇을 볼 수 있는지에 대한 보장이었다. <br>
두 트랜잭션이 동시에 쓰기를 시도할 때 발생할 수 있는 **업데이트 손실(lost update)** 문제는 별도로 다루어야 한다.

### 업데이트 손실 문제

애플리케이션이 어떤 값을 읽고, 수정한 뒤, 수정된 값을 다시 쓰는(즉, **read-modify-write** 사이클) 경우, 두 트랜잭션이 동시에 이를 수행하면 한 쪽의 수정이 사라질 수 있다.

이 패턴은 다음과 같은 다양한 시나리오에서 발생한다:

- 카운터를 증가시키거나 계좌 잔고를 업데이트할 때(현재 값을 읽고, 새 값을 계산해, 업데이트)
- 복잡한 값의 일부만 수정할 때(예: JSON 문서 내 리스트에 요소 추가 등)
- 두 사용자가 동시에 위키 페이지를 수정해, 각자 전체 내용을 서버에 저장할 때

이 문제를 막기 위해 여러 가지 해결책이 개발되었다.

#### 원자적 쓰기 연산

많은 데이터베이스는 **원자적 업데이트 연산**을 제공해, 애플리케이션 코드에서 read-modify-write 사이클을 구현하지 않아도 되도록 한다. <br>
보통 객체를 읽을 때 배타적 락을 걸어, 업데이트가 끝날 때까지 다른 트랜잭션이 읽지 못하게 하거나, 모든 원자적 연산을 단일 스레드에서 실행하도록 한다.

#### 명시적 락

데이터베이스의 내장 원자 연산으로 해결할 수 없는 경우, 애플리케이션에서 명시적으로 객체에 락을 걸어 업데이트할 수 있다. <br>
이 경우, 다른 트랜잭션이 해당 객체를 읽으려 하면, 첫 번째 read-modify-write 사이클이 끝날 때까지 대기해야 한다.

#### 자동 업데이트 손실 감지

원자 연산과 락은 read-modify-write 사이클을 순차적으로 강제해 업데이트 손실을 막는다. <br>
반면, 이 사이클을 병렬로 실행하되, 트랜잭션 매니저가 업데이트 손실을 감지하면 트랜잭션을 중단시키고 재시도를 강제하는 방법도 있다. <br>
이 방법은 스냅샷 고립성과 함께 효율적으로 적용할 수 있다.

자동 손실 감지는 코드를 수정하지 않아도 되므로, 락이나 원자 연산을 빠뜨려 버그가 생길 위험이 줄어든다.

#### Compare-and-set

트랜잭션을 지원하지 않는 데이터베이스에서는 **compare-and-set**이라는 원자 연산이 제공되기도 한다. <br>
이는 마지막으로 읽은 값이 변하지 않은 경우에만 업데이트를 허용한다. <br>
값이 바뀌었으면 업데이트가 적용되지 않고, read-modify-write 사이클을 다시 시도해야 한다.

#### 충돌 해결과 복제

복제 데이터베이스에서는 여러 노드에 데이터 복사본이 존재하고, 각 노드에서 동시 수정이 가능하므로, 업데이트 손실 방지를 위한 추가 조치가 필요하다. <br>
락이나 compare-and-set은 단일 최신 복사본이 있을 때만 적용 가능하다. <br>
하지만 멀티 리더나 리더 없는 복제에서는 여러 쓰기가 동시에 발생하고 비동기 복제가 이뤄지므로, 이러한 기법이 적용되지 않는다.

이 경우, 여러 충돌 버전(형제, siblings)을 허용하고, 애플리케이션 코드나 특수 데이터 구조를 통해 사후에 병합/해결하는 방법이 흔하다. <br>
**Last Write Wins(LWW)** 방식은 업데이트 손실에 취약하지만, 많은 복제 데이터베이스에서 기본값이다.

## Write Skew와 팬텀(Phantom)

**Write skew**는 두 트랜잭션이 서로 다른 객체를 업데이트할 때 발생하는 경쟁 조건이다. <br>
두 트랜잭션이 순차적으로 실행됐다면 발생하지 않았을 문제이나, 동시에 실행되어 이상 행동이 나타난다. 이는 업데이트 손실 문제의 일반화로 볼 수 있다.

<img width="654" height="536" alt="Image" src="https://github.com/user-attachments/assets/ee399e44-f624-4cf8-9204-907d6d059072" />

### 팬텀(Phantom)에 의한 write skew

이런 현상은 보통 다음과 같은 패턴을 따른다:

1. SELECT 쿼리로 특정 조건을 만족하는 행이 있는지 확인(예: 대기 중인 의사가 2명 이상인지, 방이 이미 예약됐는지 등)
2. 결과에 따라 애플리케이션이 계속 진행하거나 오류를 보고 트랜잭션을 중단
3. 계속 진행할 경우, 데이터베이스에 쓰기(INSERT, UPDATE, DELETE) 후 트랜잭션 커밋

이때 쓰기 연산이 조건을 바꿔, 1단계의 SELECT 쿼리 결과가 달라진다. <br>
즉, 한 트랜잭션의 쓰기가 다른 트랜잭션의 SELECT 쿼리 결과에 영향을 주는 현상을 **팬텀(phantom)**이라고 한다. <br>
스냅샷 고립성은 읽기 전용 쿼리에서 팬텀을 막지만, 읽기-쓰기 트랜잭션에서는 tricky한 write skew를 초래할 수 있다.

## 직렬 가능성(Serializability)

직렬 가능 고립성은 가장 강력한 고립성 수준으로 간주된다. <br>
트랜잭션이 병렬로 실행되더라도, 결과는 순차적으로 하나씩 실행된 것과 동일하다. <br>
즉, 트랜잭션이 단독으로 실행될 때 올바르게 동작한다면, 병렬로 실행되어도 올바르게 동작하도록 데이터베이스가 모든 경쟁 조건을 방지한다.

### 실제 직렬 실행

가장 단순한 동시성 문제 해결 방법은 동시성을 아예 없애고, 하나의 스레드에서 한 번에 하나의 트랜잭션만 순차적으로 실행하는 것이다. <br>
이 방식은 락을 통한 조정 오버헤드를 피할 수 있어 경우에 따라 더 나은 성능을 보일 수 있지만, 처리량은 한 CPU 코어의 한계에 묶인다.

- RAM 가격 하락으로 많은 경우 전체 데이터셋을 메모리에 올릴 수 있게 되었고, 디스크에서 데이터를 읽을 필요가 없으므로 트랜잭션 속도가 빨라졌다.
- OLTP 트랜잭션은 보통 짧고 읽기/쓰기가 적다. 반면, 장기 실행 분석 쿼리는 읽기 전용이므로, 직렬 실행 루프 밖에서 스냅샷 고립성으로 처리할 수 있다.

#### 저장 프로시저로 트랜잭션 캡슐화

대화형 트랜잭션 방식에서는 애플리케이션과 데이터베이스 간 네트워크 통신에 많은 시간이 소요된다. <br>
데이터베이스에서 동시성을 허용하지 않고 한 번에 한 트랜잭션만 처리하면, 대부분의 시간을 다음 쿼리를 기다리며 낭비하게 된다. 이런 시스템에서는 여러 트랜잭션을 동시에 처리해야 성능이 나온다.

따라서 단일 스레드 직렬 트랜잭션 처리 시스템에서는 대화형 다중 쿼리 트랜잭션을 허용하지 않고, 애플리케이션이 트랜잭션 전체 코드를 미리 데이터베이스에 **저장 프로시저**로 제출해야 한다.

#### 파티셔닝

여러 CPU 코어와 노드로 확장하려면 데이터를 파티셔닝할 수 있다. <br>
각 트랜잭션이 하나의 파티션 내에서만 데이터를 읽고 쓴다면, 각 파티션은 독립적으로 트랜잭션 처리 스레드를 가질 수 있다. <br>
이렇게 하면 CPU 코어 수에 비례해 처리량이 선형적으로 증가한다.

하지만 여러 파티션을 동시에 접근하는 트랜잭션이 있으면, 모든 파티션을 조정해야 하므로 추가 오버헤드가 발생하며, 단일 파티션 트랜잭션보다 훨씬 느려진다.

## 2단계 락킹(2PL, Two-Phase Locking)

2PL은 락 요구사항을 훨씬 엄격하게 만든다. 여러 트랜잭션이 동시에 같은 객체를 읽는 것은 허용되지만, 누군가가 해당 객체를 쓰려고 하면 독점적 접근이 필요하다.

- 트랜잭션 A가 객체를 읽고 있는 상태에서, 트랜잭션 B가 해당 객체를 쓰려고 하면, B는 A가 커밋 또는 중단될 때까지 기다려야 한다.
- 트랜잭션 A가 객체를 쓴 상태에서, 트랜잭션 B가 해당 객체를 읽으려 하면, B는 A가 커밋 또는 중단될 때까지 기다려야 한다.

2PL에서는 쓰기 트랜잭션이 다른 쓰기뿐 아니라 읽기 트랜잭션도 블로킹하며, 반대도 마찬가지다. <br>
반면, 스냅샷 고립성은 “읽기는 쓰기를, 쓰기는 읽기를 블로킹하지 않는다”는 원칙을 따른다. 2PL은 직렬 가능성을 제공하므로, 업데이트 손실, write skew 등 모든 경쟁 조건을 방지한다.

## 직렬 가능한 스냅샷 고립성(SSI)

지금까지 데이터베이스의 동시성 제어에 대해 암울한 그림을 그렸다. <br>
한편으로는 성능이 좋지 않거나 확장성이 떨어지는 직렬 가능성 구현(2PL, 직렬 실행), 다른 한편으로는 성능은 좋지만 다양한 경쟁 조건에 취약한 약한 고립성 수준이 있다. <br>
과연 직렬 가능성과 좋은 성능은 양립할 수 없는 것일까?

꼭 그렇지는 않다. 비교적 새로운 알고리즘인 **직렬 가능한 스냅샷 고립성(SSI, Serializable Snapshot Isolation)** 은 매우 유망하다. <br>
스냅샷 고립성에 비해 성능 저하가 거의 없이 완전한 직렬 가능성을 제공한다.

SSI는 낙관적 동시성 제어(optimistic concurrency control) 기법이다. <br>
여기서 “낙관적”이란, 위험한 일이 발생해도 일단 트랜잭션을 계속 진행시키고, 커밋 시점에 데이터베이스가 문제가 발생했는지(고립성이 위배됐는지) 검사해, 문제가 있으면 트랜잭션을 중단하고 재시도하게 한다. <br>
직렬적으로 실행된 트랜잭션만 커밋이 허용된다.

여유 용량이 충분하고 트랜잭션 간 충돌이 많지 않다면, 낙관적 동시성 제어 기법이 비관적 기법보다 더 좋은 성능을 보이는 경향이 있다.