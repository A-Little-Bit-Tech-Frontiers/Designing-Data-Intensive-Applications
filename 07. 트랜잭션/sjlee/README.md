# 1. 애매모호한 트랜잭션의 개념

## 1.1 ACID의 의미

원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)

현실은 데이터베이스마다 ACID 구현이 제각각

### 1.1.1 원자성

all or nothing을 설명하는 개념이다.

⇒ 이를 통해, 여러 변경 작업 도중에 생기는 오류에 대해 처리해야하는 복잡한 문제를 단순하게 만들어준다.

### 1.1.2 일관성

이 친구가 굉장히 여러 의미로 쓰임.

ACID 일관성의 아이디어는 항상 진실이어야 한다는 것이다. 
→ 불변식이 유효한 데이터베이스에서 트랜잭션이 시작하고 실행된 모든 쓰기는 유효성을 보존한다는 것.

아이러니하게도 이런 불변식은 애플리케이션의 책임이고, 유효성을 보장하도록 트랜잭션을 올바르게 정의하는것 또한 애플리케이션의 책임이다.

→ 데이터베이스에서 불변식을 위반하는 잘못된 데이터를 막을 수는 없다.(물론, 다양한 제약조건이 있긴 함)

그래서 원자성, 격리성, 지속성은 데이터베이스의 속성인 반면에, 일관성은 애플리케이션에 종속적인 성격을 가진다. 데이터베이스만으로 되지 않는다는 것이다.

### 1.1.3 격리성

데이터베이스가 공유 자원인만큼 동시성 문제에 맞닥뜨리게 되어 있음.

<img width="614" height="166" alt="image" src="https://github.com/user-attachments/assets/33e97016-dea7-48ea-a82e-d5f07b75af16" />


ACID의 격리성은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미함. 
(여러 서적에서 직렬화 한다고 하긴 하는데, 직렬화가 각 트랜잭션이 전체 데이터베이스에서 실행되는 유일한 트랜잭션인것처럼 동작하는 것을 의미함)

⇒ 직렬성 격리(serializable isolation)는 성능 손해를 동반하므로, 잘 안씀
⇒ 격리 수준 중에 serializable이 있긴 하지만, 살짝 약한 **스냅샷 격리**를 통해 격리 수준을 완화하곤 함.

### 1.1.4 지속성

성공한 트랜잭션에 대해 데이터베이스가 죽더라도 데이터 손실이 안되어야 한다는 컨셉.

- 트랜잭션이 커밋되면 → 하드웨어 장애나 서버 다운이 발생해도 데이터는 안전해야 함.
- 단일 노드 DB: 주로 디스크(HDD/SSD)에 기록 + **쓰기 전 로그(write-ahead log)** 등으로 보장.
- 분산 DB: 단순히 디스크 기록뿐 아니라, **여러 노드에 복제(replication)** 해서 보장.

하지만 현실적으로는 완벽한 지속성은 불가능하다.

⇒ 디스크와 백업이 동시에 망가지면 어쩔 수 없음.
⇒ 따라서 여러 수단(쓰기 전 로그, 복제, 백업)을 **중첩해서 사용**해야 함.

**결론:** 지속성(durability)은 트랜잭션 커밋 후 데이터가 절대 잃어버리지 않도록 보장하는 성질이지만, 단일 수단으로는 불가능하며, 디스크 기록·복제·백업 등 여러 기법을 함께 써야 한다.

## 1.2 단일 객체 연산과 다중 객체 연산

원자성과 격리성은 어쨌든 한 번에 여러 객체(로우, 문서, 레코드)를 변경할 수 있다는걸 가정하는 정의다.

- **격리성으로 일관성을 보장하는 방법**
    
    <img width="629" height="230" alt="image" src="https://github.com/user-attachments/assets/1ac69716-d301-4a8d-bb77-83de9475278f" />

    
    - 트랜잭션이 다른 트랜잭션에서 썼지만 커밋되지 않은 데이터를 읽음 (dirty read)
    - 격리성은 사용자2가 삽입된 이메일과 갱신된 개수를 모두 보거나 모두 못보게 하고, 일관성이 깨진 중간 지점을 보는 일은 없게 해준다.

- **원자성이 일관성을 보장하는 방법**
    
    <img width="631" height="171" alt="image" src="https://github.com/user-attachments/assets/eecb67d8-7736-49f8-9ecf-623a8bd62ce4" />

    
    - 오류가 발생하면 트랜잭션에서 이전에 실행한 쓰기를 취소함.

RDB는 이렇게 트랜잭션 안에 여러 연산이 묶이지만, 비관계형 DB는 이렇게 강하게 묶는 기능이 없다.

### 1.2.1 단일 객체 쓰기

원자성과 격리성은 단일 객체를 변경하는 경우에도 적용됨.

20KB JSON 문서 저장 예시

- 첫 10KB를 보낸 후에 네트워크가 끊기면? → DB는 파싱 불가능한 10KB JSON 조각을 저장할 것인가
- 디스크에 저장된 기존 값을 덮어쓰는 도중에 전원이 나가면?
- 쓰기 도중 다른 읽기 요청이 들어오면? → 부분적으로 갱신된 값을 읽게 되는가

**원자성**은 장애 복구용 로그를 써서 구현할 수 있고, **격리성**은 각 객체 잠금을 통해 구현할 수 있다.

원자적 연산을 제공하기 위해 잠금 뿐만이 아니라 CAS 연산 등과 같이 다양한 기법을 구현할 수 있다.

### 1.2.2 다중 객체 트랜잭션의 필요성

- 단일 객체 연산만으로 충분한 경우도 있지만, 실제 애플리케이션에서는 **여러 객체를 동시에 갱신해야 하는 경우**가 많다.
- 이에 따라 코디네이션이 필요하고, 이게 트랜잭션임.

**관계형 데이터 모델**

- 테이블의 로우가 다른 테이블의 로우를 참조(외래 키).
- 참조 무결성을 보장하려면 다중 객체 트랜잭션 필요.
- 예: 여러 레코드 삽입 시 외래 키 관계가 올바르게 유지되어야 함.

**문서 데이터 모델**

- 문서 안의 여러 필드가 동시에 갱신되어야 일관성 유지.
- 단일 문서 갱신만으로는 충분하지 않고, 여러 문서를 한 번에 갱신해야 하는 경우 다중 객체 트랜잭션이 필요.

**보조 색인**

- 데이터베이스가 자동으로 유지하는 색인은 **데이터와 색인이 항상 동시에 갱신**되어야 함.
- 그렇지 않으면 색인은 최신 데이터를 반영하지 않아 쿼리 시 잘못된 결과가 나옴.

# 2. 완화된 격리 수준

직렬성 격리는 성능 비용이 있고 많은 데이터베이스들은 그 비용을 지불하려고 하지 않는다.

완화된(비직렬성) 격리 수준을 살펴보고 발생 가능한 경쟁 조건과 발생 불가능한 경쟁 조건을 나눠 생각해볼 수 있어야 함.

## 2.1 커밋 후 읽기 (Read Committed)

가장 기본적인 격리 수준 

1. 데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다. (dirty read X)
2. 데이터베이스에서 쓸 때 커밋된 데이터만 덮어쓰게 된다. (dirty write X)

### 2.1.1 Dirtry Read 방지

다른 트랜잭션에서 커밋되지 않은 데이터를 읽는 현상.

아래와 같이 해당 격리 수준에서는 커밋되지 않은 데이터가 읽히면 안된다.

<img width="615" height="169" alt="image" src="https://github.com/user-attachments/assets/50283823-cebb-4dea-9bae-e5d33f2bd75f" />


- dirty read가 발생하면, 일부 트랜잭션은 갱신된 값을 보고 일부는 갱신되지 않은 값을 볼 수 있게된다.
- 갱신 중인 트랜잭션이 롤백되면, 갱신된 값을 읽은 다른 트랜잭션도 쓰기 작업을 다 롤백해야됨.

### 2.1.2 Dirty Write 방지

먼저 쓴 트랜잭션이 커밋될 때까지 다른 트랜잭션 쓰기를 지연시키는 방법을 통해, Read Committed 격리 수준에서는 dirty write를 방지해야 한다.

안그러면, 아래와 같이 불일치 발생

<img width="539" height="266" alt="image" src="https://github.com/user-attachments/assets/d3e839c4-684e-4ab9-9a90-fcd1b7be56dc" />


### 2.1.3 Read Committed 구현

로우 수준 잠금을 사용해 더티 쓰기를 방지한다. 

더티 읽기를 방지하고 잠금을 거는건 다른 읽기만 수행하는 트랜잭션에 지연을 발생시킨다.
⇒ 이에 따라 과거 커밋된 값을 읽고, 새 값이 커밋되어야만 다른 트랜잭션들이 새 값을 읽도록 처리한다.

## 2.2 스냅샷 격리와 반복 읽기(Repeatable read)

Read Commited는 아래와 같은 문제 여전히 존재.

<img width="586" height="283" alt="image" src="https://github.com/user-attachments/assets/1fced7cc-4668-41e1-8419-04ee93baa61c" />


- 앨리스가 일관성이 깨진 데이터베이스를 보게 됨.
- 앨리스가 은행 잔고 총액이 1000인 상태

새로고침하면 일관성 있게 조회가 가능하겠지만, 일시적인 비일관성도 안될 경우가 있다.

**스냅샷 격리를 통해 이를 해결함.** ⇒ 각 트랜잭션에서는 일관된 스냅샷으로부터 읽음

### 2.2.1 스냅샷 격리 구현

쓰기 잠금은 여전히 건다. (Read Committed 처럼)

성능 관점에서 **“읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고, 쓰는 쪽에서도 읽는 쪽을 결코 차단하지 않는다”**가 스냅샷 격리의 핵심이다.

⇒ 그래서, 락 경쟁 없이 일관성 있게 읽기 작업을 수행할 수 있다.

데이터베이스는 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 한다. ⇒ MVCC, Multi-Version Concurrency Control

스냅샷 격리가 아니라 **Read Commited 격리 수준이라면, 객체마다 버전 두 개씩만 유지하면 된다. (커밋 전, 커밋 후)
⇒** 그러나, 스냅샷 격리를 지원하는 저장소 엔진은 보통 Read Committed를 위해서도 MVCC 사용 한다고 함.
→ 단, **Read Committed는 질의별로 독립된 스냅샷 사용하고, 스냅샷 격리는 트랜잭션 단위로 동일한 스냅샷을 사용**

아래는 postgresql mvcc 기반 스냅샷 격리

<img width="512" height="364" alt="image" src="https://github.com/user-attachments/assets/d19a136f-21f4-456a-94ea-ee3f18374e7b" />


- 트랜잭션이 시작하면 고유 트랜잭션을 할당 받음.
- 데이터베이스에 데이터를 쓸 때마다 쓰기를 실행한 트랜잭션 ID가 같이 붙음
    - 더 낮은 txid 여부로 판단

## 2.3 색인과 스냅샷 격리

다중 버전 DB의 색인은 트랜잭션별로 볼 수 있는 버전만 노출하도록 동작하며, PostgreSQL은 같은 페이지에 버전을 저장하는 방식을, 카우치DB/LMDB 등은 B트리 기반 copy-on-write 방식을 사용한다.
후자의 경우 스냅숏 유지가 쉽지만 컴팩션이 필요하다.

## 2.4 갱신 손실(Lost Update) 방지

**Lost Update**는 두 트랜잭션이 같은 데이터를 수정할 때, 나중에 실행된 트랜잭션이 먼저 실행된 트랜잭션의 결과를 덮어써서 앞선 결과가 사라지는 문제다.

해결책은 아래와 같이 있음.

### 2.4.1 원자적 쓰기 연산

- 애플리케이션에서 read-modify-write 루프를 구현할 필요 없음
    - DB에서 `UPDATE ... SET value = value + 1` 같은 **원자적 갱신 연산**을 제공.
- 대부분의 RDBMS와 일부 NoSQL(DB)에서 제공, 동시성 안전.
- 구현 방식: 독점 잠금(exclusive lock) → 다른 트랜잭션은 해당 객체를 갱신 완료될 때까지 접근 불가.
- 커서 안정성(cursor stability)이라고도 부름.

### 2.4.2 명시적인 잠금

- DB가 원자적 연산을 제공하지 않을 경우, 애플리케이션에서 **명시적 잠금**을 걸 수 있음.
    - 예: `FOR UPDATE` 구문 → 해당 로우에 잠금을 걸어 동시에 다른 트랜잭션이 갱신 못 하도록 보장.
    - 단점: 코드에서 잠금을 관리해야 하므로 복잡하고 경쟁 조건이 생기기 쉬움.

### 2.4.3 갱신 손실 자동 감지

- DB가 내부적으로 read-modify-write 주기가 충돌했는지 자동 감지.
- 충돌 발견 시 해당 트랜잭션을 **어보트(abort)** 시켜서 재시도하게 강제.
- 장점: 스냅숏 격리와 결합 시 효율적. PostgreSQL, Oracle, SQL Server 일부에서 지원.
- MySQL/InnoDB는 갱신 손실 감지를 자동으로 하지 않음.

### 2.4.4 CAS 연산

- 트랜잭션 없는 DB에서 제공하는 기법
- 이 연산의 목적은 값을 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것이다.
- 읽은 값이 여전히 같은지 조건을 걸고 업데이트:
    
    ```sql
    UPDATE wiki_pages SET content = 'new content'
    WHERE id = 1234 AND content = 'old content';
    ```
    
    - 내용이 바뀌면 갱신 실패 → 애플리케이션이 재시도.
- 하지만 스냅숏 읽기 허용 시에는 여전히 충돌 감지가 불완전할 수 있음.

## 2.5 쓰기 스큐와 팬텀

### 2.5.1 쓰기 스큐(Write Skew) 문제

- **정의**: 동시에 실행된 트랜잭션들이 각각의 조건 검사를 통과했지만, 결과적으로는 데이터 무결성이 깨지는 현상.
- Dirty Write나 Lost Update처럼 **같은 행을 직접적으로 덮어쓰는 게 아니라, 조건 기반으로 다른 행을 갱신**할 때 발생.

예시)

<img width="501" height="343" alt="image" src="https://github.com/user-attachments/assets/94bc790a-ca58-470c-9d38-e0b29ab199ad" />

- 규칙: 최소 한 명의 의사는 반드시 교대 상태(on-call)에 있어야 함.
- 상황: 두 의사(앨리스, 밥)가 동시에 “교대 상태를 끄기” 버튼을 누름.
- 각 트랜잭션은 `currently_on_call >= 2` 조건을 확인하고, 조건을 만족하므로 자신을 교대 상태에서 제외.
- 각각은 올바르게 보이지만, 두 트랜잭션이 동시에 커밋되면 → **아무도 on-call이 아닌 상태**가 되어 규칙 위반.

### 2.5.2 쓰기 스큐 특징

- 쓰기 스큐는 **Dirty Write**나 **Lost Update**가 아님.
    - 두 트랜잭션이 **각자 다른 객체를 갱신**하면서, 동시에 실행될 때 이상 현상이 나타나는 것이다.
    - 예: 두 의사가 동시에 on-call 상태를 끔 → 결과적으로 아무도 on-call이 남지 않음.
- 하나씩 순차 실행됐다면 문제는 발생하지 않았음.
- 따라서 **조건 기반 갱신에서 동시 실행될 때 무결성이 깨지는 전형적인 문제임.**

Lost update 방지 방법에는 여러 개가 있었다. 하지만, **쓰기 스큐 문제는 방지 방법이 더 제한적**이다.

- 단일 객체 원자적 연산 → 쓰기 스큐 방지 불가.
- 스냅숏 격리(Snapshot Isolation)도 자동 감지 못함 → 쓰기 스큐 방지에는 **직렬성(Serializable) 수준** 필요.
- 따라서 쓰기 스큐는 일반적인 갱신 손실 문제보다 훨씬 까다롭다.

**쓰기 스큐 방지하는 방법**

- **제약 조건 활용**
    - DB 차원에서 “최소 한 명은 on-call이어야 한다” 같은 제약을 정의.
    - 일부 DB는 제약 조건을 직접 지원, 없는 경우는 materialized view 등으로 구현 가능.
- **명시적 잠금**
    - 트랜잭션이 참조하는 행 집합을 직접 잠금(`FOR UPDATE`)으로 보호.
        
        ```sql
        BEGIN TRANSACTION;
        SELECT * FROM doctors
        WHERE on_call = true AND shift_id = 1234 FOR UPDATE;
        
        UPDATE doctors
        SET on_call = false
        WHERE name = 'Alice' AND shift_id = 1234;
        
        COMMIT;
        ```
        

### 2.5.3 쓰기 스큐 예

- **회의실 예약 시스템**
    - 동시에 여러 사용자가 같은 회의실을 예약하려고 할 때, 스냅숏 격리만으로는 중복 예약을 막을 수 없음.
    - 따라서 한 번 더 직렬성 격리 같은 강력한 제약이 필요.
- **다중플레이어 게임**
    - 두 플레이어가 동시에 같은 오브젝트(예: 캐릭터, 아이템)를 움직이려 할 경우 발생.
    - 단순 락만으로는 규칙 위반을 완전히 막을 수 없고, 유일성 제약 같은 추가 조건이 필요.
- **사용자명 획득**
    - 동시에 여러 사용자가 같은 사용자명을 등록하려 할 때 발생.
    - 스냅숏 격리만으로는 안전하지 않고, 유일성 제약 조건을 반드시 활용해야 함.
- **이중 지불(double spending) 방지**
    - 사용자가 계좌에 있는 돈보다 더 많이 지출하려는 경우.
    - 동시 쓰기로 인해 잔고가 음수가 되는 상황을 막기 위해 트랜잭션 단위의 강력한 제약이 필요.

## 2.6 쓰기 스큐를 유발하는 팬텀

팬텀(phantom)은 **검색 질의의 결과가 다른 트랜잭션의 쓰기에 의해 바뀌는 현상**이다.

예를 들어, `SELECT COUNT(*) ...` 했을 때 결과는 2였지만, 다른 트랜잭션이 동시에 실행되며 새로운 row를 추가하거나 기존 row를 변경 → 결과가 달라짐.

⇒ 즉, **검색 조건에 부합하는 row의 집합 자체가 달라지는 것**이 팬텀이다.

쓰기 스큐의 대부분은 팬텀 현상으로 설명할 수 있음.

예시

- "현재 on-call 의사가 2명 이상" 조건을 확인하는 SELECT
- 다른 트랜잭션이 동시에 실행되어 조건을 바꿔버리면, 두 명 모두 빠져버리는 스큐 발생.

**해결방법**

- 스냅샷 격리는 읽기 전용 질의에서만 팬텀 읽기를 회피. read-write 트랜잭션에서는 쓰기 스큐 발생이 가능함.
- **SELECT FOR UPDATE**
    - 이미 존재하는 row를 잠가서 동시에 갱신이 안 되게 막을 수 있음.
    - 하지만 팬텀 문제처럼 *존재하지 않는 row를 추가*하는 경우는 막지 못함.
- **충돌 구체화(Materializing conflict)**
    - 팬텀 문제를 방지하기 위해 아예 **제약조건을 구체적인 row로 모델링**.
    - 예: 회의실 예약 → “시간 슬롯과 회의실” 조합으로 미리 row를 생성해두고, 예약 시 해당 row를 잠그는 방식.
    - 이렇게 하면 팬텀(새로운 row 추가)을 막을 수 있음.
    - ⇒ 이건 동시성 제어 메커니즘이 애플리케이션 데이터 모델로 새어 나올 수 있으므로, 관리도 어려움.

정리) 쓰기 스큐는 팬텀의 특수한 경우이며, 팬텀을 막으려면 직렬성 수준의 잠금과 충돌 구체화같은 기법을 활용해야 한다.

# 3. 직렬성

완화된 격리 수준을 사용하다보니 경쟁 조건을 유발하는 다양한 문제가 있다. 데이터베이스가 발생할 수 있는 모든 경쟁 조건을 막기위한. 가장 강력한 격리수준이 직렬성 격리다.

직렬성을 제공하는 데이터베이스는 아래 세 가지 기법 중 하나를 사용한다. (대부분)

- 트랜잭션 순차적으로 실행하기
- 2단계 잠금
- 직렬성 스냅샷 격리 같은 낙관적 제어 기법

## 3.1 실제적인 직렬 실행

**모든 트랜잭션을 하나씩 순차적으로 실행**하는 방식이다. 이렇게 하면 동시성 제어를 위한 복잡한 충돌 감지나 롤백 처리 없이도, 직렬성(serializability)을 보장할 수 있음.

과거에는 직렬 실행이 너무 비효율적이라고 여겨졌지만, 최근에는 기술 발전 덕분에 현실적으로 가능해졌다고 한다.

- **메모리 가격 하락 + 대용량 메모리 사용 가능**
    - 전체 데이터셋을 메모리에 올려둘 수 있게 됨 → 디스크 I/O 병목이 크게 줄어듦.
    - 즉, 트랜잭션에 필요한 데이터 접근 속도가 빨라져 직렬 실행도 충분히 빠르게 동작.
- OLTP(온라인 트랜잭션 처리) 트랜잭션의 특성
    - 대부분 **짧고 단순한 읽기/쓰기 연산**으로 구성.
    - 오래 걸리는 분석 질의(OLAP)는 별도의 시스템에서 실행할 수 있으므로, OLTP에서는 직렬 실행 모델을 적용해도 성능 저하가 크지 않음.
- 동시성 제어의 오버헤드 회피
    - 전통적인 동시성 제어(락, MVCC 등)는 충돌 감지/해결 비용이 큼.
    - 직렬 실행은 이 오버헤드가 없으므로 오히려 더 단순하고 효율적인 경우가 많음.

하지만, CPU 코어가 많아도 직렬 실행은 **하나의 코어만 사용**하는 구조가 될 수 있다. ⇒ 병렬 처리 능력 제한될 수 있음.

따라서 직렬 실행을 쓰려면 **트랜잭션이 전통적인 형태(짧고 단순한 OLTP)**여야 하고, 분석용 질의는 별도 시스템에서 처리하는 구조로 나누는 것이 바람직함.

### 3.1.1 트랜잭션을 스토어드 프로시저 안에 캡슐화하기

- 초기 데이터베이스 설계에서는 전체 사용자 활동(여행 예약 등)을 하나의 트랜잭션으로 묶어 원자적으로 처리하려는 의도가 있었음.
    - 하지만 현실에서는 사용자가 입력을 기다리는 동안 트랜잭션을 유지하는 것이 비효율적이므로 대부분 짧은 트랜잭션을 유지.
- 전통적으로는 애플리케이션이 SQL을 보내고 결과를 받고, 이어 다른 SQL을 보내는 방식 → 네트워크 왕복 비용이 큼.
    - 이를 개선하기 위해 **트랜잭션 코드를 스토어드 프로시저 형태로 DB에 직접 제출**하여, DB 내부에서 필요한 연산을 빠르게 실행할 수 있음.

정리하면 아래와 같다.

<img width="438" height="247" alt="image" src="https://github.com/user-attachments/assets/6d596387-0fbc-4d68-b0da-afe280e4c966" />


- **상호작용식**: 애플리케이션 ↔ DB 간 여러 번 네트워크 요청/응답 발생. → 지연과 비효율.
- **스토어드 프로시저**: 전체 로직을 DB 내부에서 실행. 필요한 데이터는 메모리에 있고, 디스크 I/O 대기 없이 빠르게 처리 가능.

### 3.1.2 스토어드 프로시저 장단점

**단점**

- DB 벤더마다 사용하는 언어가 다름 (예: PL/SQL, T-SQL, pgSQL 등) → 표준화 부족, 생태계 협소.
- 코드 관리가 어렵고, 배포/테스트/모니터링도 불편.
- 잘못 작성된 스토어드 프로시저가 DB 성능에 심각한 병목이 될 수 있음.

**극복**

- 최근에는 **일반 프로그래밍 언어**(Java, Groovy, Clojure, Lua 등)로 스토어드 프로시저 작성 가능.
- 데이터가 메모리에 저장되어 있다면 단일 스레드 실행으로도 충분히 높은 성능 확보 가능.
- 불필요한 동시성 제어 오버헤드 제거 가능.

복제를 사용하는 DB에서는 스토어드 프로시저도 동일하게 각 서버에서 실행되어야 함.

⇒ 따라서 스토어드 프로시저는 **결정적(deterministic)**이어야 한다. (예: "현재 시각" 같은 비결정적 연산은 특별 API 필요).

### 3.1.3 파티셔닝

트랜잭션 처리를 단일 스레드로 직렬화 해버리면 병목이 되고, 단일 cpu 코어 수준으로 처리량이 제한된다. 이에 따라 파티셔닝으로 확장하고, 병렬로 처리하는 방법을 고려해볼 수 있다.

**파티셔닝으로 확장**

- 데이터를 여러 파티션으로 나누면 각 파티션은 독립적으로 트랜잭션을 처리할 수 있음.
- 즉, 각 CPU 코어가 서로 다른 파티션을 맡아 병렬 처리 가능 → 전체 처리량을 CPU 코어 수에 비례하게 확장할 수 있음.

**문제점: 다중 파티션 트랜잭션**

- 트랜잭션이 여러 파티션에 접근해야 한다면, 각 파티션 간 **코디네이션(조율)**이 필요함.
- 이 경우 락과 동기화가 추가되면서 오버헤드가 커지고 성능이 급격히 저하됨.
- 따라서 단일 파티션 내에서만 처리 가능한 트랜잭션이 이상적임.

## 3.2 2단계 잠금(2PL, Two-phase Locking)

- **원리**
    
    트랜잭션이 실행 중일 때 **잠금 획득 단계**와 **잠금 해제 단계**로 나눔.
    
    - 처음에는 필요한 모든 잠금을 얻음 (읽기 잠금/쓰기 잠금).
    - 이후 트랜잭션이 끝나기 전까지는 절대 잠금을 해제하지 않음.
    - 커밋이나 어보트 시점에서 잠금을 모두 해제.

**특징**

- **충돌 방지**: 같은 객체에 동시에 쓰려 하면, 먼저 잠금 획득한 트랜잭션이 끝날 때까지 대기. → **더티 쓰기 방지**.
- **읽기/쓰기 충돌 제어**
    - 읽는 쪽은 공유 모드(shared),
    - 쓰는 쪽은 독점 모드(exclusive) 잠금.
    - 공유 모드는 여러 트랜잭션이 동시에 가능하지만, 독점 모드는 단독 접근만 허용.
- **스냅숏 격리와 차이**: 스냅숏 격리는 “읽는 쪽은 쓰는 쪽을 막지 않는다”가 원칙인데, 2PL은 읽기와 쓰기 모두 경쟁 조건에서 보호.

**단점: 교착 상태(Deadlock)**

- 여러 트랜잭션이 서로 상대방의 잠금 해제를 기다리며 멈추는 상황 발생.
- DB는 이를 **자동 감지** 후, 트랜잭션 중 하나를 어보트시켜 교착을 풀고 나머지를 진행시킴.
- 어보트된 트랜잭션은 애플리케이션에서 다시 재시도 필요.

### 3.2.1 2단계 잠금 구현

- **잠금 모드**
    - **공유 모드(Shared Mode)**: 읽기 전용. 여러 트랜잭션이 동시에 읽을 수 있음.
    - **배타 모드(Exclusive Mode)**: 쓰기 전용. 하나의 트랜잭션만 접근 가능.
- **동작 방식**
    - 읽기 시 → 공유 잠금 획득.
    - 쓰기 시 → 배타 잠금 획득.
    - 공유 → 배타 승격(업그레이드) 가능. (읽기 → 쓰기로 바뀔 때)
- 단점
    - **성능 저하**: 잠금 유지 때문에 대기 시간이 늘어나 응답 지연 및 처리량 감소.
    - **교착 상태(Deadlock)**: 서로 잠금을 기다리다가 멈추는 상황 발생 → DBMS가 자동으로 감지 후 트랜잭션 중 하나를 강제 Abort.
    - **높은 불확실성**: 어떤 트랜잭션이 오래 기다릴 수 있음 → 응답 시간 예측 어려움.

### 3.2.2 서술 잠금

- **필요성**: 단순히 이미 존재하는 행만 잠그는 것이 아니라, **아직 존재하지 않지만 조건을 만족할 수도 있는 잠재적 행(팬텀 문제)**까지 잠궈야 직렬성 보장 가능.
- **예시**: 회의실 예약 시스템에서 “같은 시간대에 중복 예약이 없어야 함”을 보장하려면, 단순히 현재 행만 잠그는 게 아니라 조건에 해당하는 “모든 잠재적 예약”을 잠가야 함.
- **한계**: 구현이 복잡하고 성능 저하가 심함.

### 3.2.3 색인 범위 잠금(Index-Range Locking, Next-Key Locking)

- **개념**: 서술 잠금보다 현실적으로 구현이 쉬운 방법. **인덱스를 기준으로 특정 범위(range)에 대해 잠금을 거는 방식.**
- **장점**: 팬텀, 쓰기 스큐 문제를 막을 수 있음.
- **예시**: `room_id=123 AND time between 12:00~13:00` 예약 시, 해당 시간 범위 전체에 대해 **색인 잠금을 걸어 다른 트랜잭션이 동일 조건으로 예약하지 못하게 막음.**
- **단점**: 필요 이상으로 많은 객체에 잠금을 걸 수 있어 성능 저하 가능.

범위 잠금을 잡을 수 있는 적합한 색인이 없다면 테이블 전체에 공유 잠금을 잡는걸로 대체할 수 있다. 

## 3.3 직렬성 스냅샷 격리(SSI, Serializable snapshot isolation)

- **정의**: 직렬성과 스냅샷 격리를 결합한 알고리즘.
- **특징**:
    - 스냅샷 격리의 성능(낙관적 동시성 제어 기반) + 직렬성 보장.
    - 직렬성 구현치고는 성능 손해가 거의 없음.
- **장점**:
    - 다양한 경합 문제(갱신 손실, 쓰기 스큐, 팬텀 등) 해결.
    - 스냅샷 격리 대비 약간의 성능 저하만 존재.
    - 다른 전통적 제어 기법에 비해 훨씬 효율적이고 미래에 기본값이 될 가능성 있음.

### 3.3.1 비관적 동시성 제어 vs 낙관적 동시성 제어

- **비관적 동시성 제어** (예: 2단계 잠금, 2PL)
    - 트랜잭션 실행 도중 충돌 가능성이 있다고 보고 **미리 잠금**을 걸어 충돌을 방지.
    - 장점: 안전하고 확실.
    - 단점: 잠금 경합으로 인한 병목, 교착 상태 발생 가능, 성능 저하.
- **낙관적 동시성 제어**
    - 충돌이 **자주 일어나지 않을 것**이라고 가정.
    - 일단 걍 트랜잭션 실행을 먼저 진행하고 봄 → 커밋 시점에서 충돌 여부 검사.
    - 충돌 발생 시 롤백(Abort) 후 재시도.
    - 장점: 잠금 오버헤드 없음, 높은 병렬성.
    - 단점: 충돌이 잦을 경우 성능 저하, 재시도로 인한 비용 증가.

SSI는 **스냅숏 격리를 기본으로 하여** 동작한다. 즉, 트랜잭션에서 실행되는 모든 읽기는 일관된 스냅샷을 바라본다. 
→ 이 부분의 낙관적 제어 기법과 크게 다른 점이다.

SSI는 스냅샷 격리 위에 쓰기 작업 사이의 직렬성 충돌을 감지하고 Abort 시키는 것을 감지하는 기법이다.
