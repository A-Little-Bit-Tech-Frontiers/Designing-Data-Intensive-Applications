# 7장. 트랜잭션

## 1. 트랜잭션이 필요한 이유

- **소프트웨어/하드웨어 실패**: 중간에 죽거나(크래시) 재부팅, 쓰기 연산 중단.
- **동시성**: 여러 클라이언트/스레드가 같은 데이터에 동시에 읽고/쓰기를 시도.
- **네트워크 이슈**: 클라이언트↔DB, 노드↔노드 간 단절·지연·패킷 손실.
- **부분 실패**: 일부 복제본만 갱신, 요청 재시도로 **중복 실행**.
- **예측 못한 상호작용**: 서로 다른 요청이 미묘하게 엇갈리며 버그 유발.

→ 트랜잭션은 이런 실패/경쟁 조건을 **안전성 보장(safety guarantee)** 으로 감싸 **“프로그램을 더 단순하게”** 만들어주는 추상화이다.

## 2. ACID의 의미

- **A(원자성, Atomicity)**
    - 여러 변경을 **전부(commit)** 하거나 **전혀 안 함(rollback/abort)**.
    - 중간상태가 밖으로 노출되지 않음. 보통 WAL/undo log로 구현.
- **C(일관성, Consistency)**
    - 일관성의 아이디어는 항상 진실이어야 하는, 데이터에 관한 어떤 선언(불변식(invariant))이 있다는 것이다.
    - 예를 들어 회계 시스템에서 모든 계좌에 걸친 대변과 차변은 항상 맞아떨어져야 한다.
    - 단, 이것은 항상 데이터베이스에서 보장하는 것이 아니다. 데이터베이스는 불변식을  위반하는 잘못된 데이터를 쓰지 못하도록 막을 수 없다. (예외적으로 외래 키 제약 조건이나 유일성 제약조건은 가능)
    - 원자성, 격리성, 지속성은 데이터베이스의 속성인 반면 일관성은 애플리케이션의 속성이다.
    - 애플리케이션에서 일관성을 달성하기 위해 데이터베이스의 원자성과 격리성 속성세 기댈 수는 있지만 데이터베이스만으로 되는 것은 아니다.
- **I(격리성, Isolation)**
    - 여러 클라이언트들이 동시에 동일한 레코드에 접근하면 동시성 문제(경쟁 조건)가 발생할 수 있다.
    - 격리성이란 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다. 트랜잭션은 다른 트랜잭션을 방해할 수 없다.
    - 직렬성은 각 트랜잭션이 전체 데이터베이스에서 실행되는 유일한 트랜잭션인 것처럼 동작할 수 있다는 것을 의미한다.
    - 즉, 동시에 실행돼도 결과가 **순차(serial) 실행과 같아 보이게** 하는 정도.

<img width="647" height="220" alt="image" src="https://github.com/user-attachments/assets/c868d476-0da2-40fb-8e1c-44b93a0e7e8d" />

- **D(지속성, Durability)**
    - 지속성은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.
    - 보통 디스크에 저장된 데이터 구조가 오염됐을 때 복구할 수 있게 해주는 쓰기 전 로그(WAL, write-ahead-log)나 비슷한 수단을 동반한다.
    - 과거에는 지속성이 아카이브 테이프에 기록하는 것을 의미. 그 후로는 디스크나 SDD에 기록하는 것을 의미. 최근에는 복제를 의미하게 되었다. 즉, 지속성의 의미는 시간이 지남에 따라 확장되고 있다.

## **3. 단일 객체 연산과 다중 객체 연산**

- **원자성**: 여러 개의 쓰기를 실행하는 도중 오류가 발생하면 트랜잭션은 **어보트**돼야 하고 그때까지 쓰여진 내용은 폐기해야 한다. 전부 반영되거나 아무것도 반영되지 않는 것을 보장함으로써 부분 실패를 걱정할 필요가 없게 도와준다.

<img width="713" height="219" alt="image" src="https://github.com/user-attachments/assets/6f524824-9bd4-45c7-9bbd-039a33ee6ea6" />

- **격리성**: 동시에 실행되는 트랜잭션들은 서로를 방해하지 말아야 한다. 예를 들어, 한 트랜잭션이 여러 번 쓴다면 다른 트랜잭션은 그 내용을 전부 볼 수 있든지 아무것도 볼 수 없든지 둘중 하나여야 하고 일부분만 볼 수 있어서는 안된다.

<img width="694" height="294" alt="image" src="https://github.com/user-attachments/assets/cbe0fcfb-6019-4fa5-a463-d7962501d73f" />

### **단일 객체 쓰기**

- 저장소 엔진은 보통 **단일 객체** 수준에서 원자성과 격리성을 제공하는 것을 목표로 한다.
- 원자성은 장애 복구용 로그를 써서 구현할 수 있고, 격리성은 각 객체에 잠금을 사용해 구현할 수 있다.
- 어떤 데이터베이스는 증가 연산처럼 더 복잡한 원자적 연상을 제공하기도 한다. 원자적 증가 연산은 그림7-1의 **read-modify-write** 주기를 반복하지 않도록 도와준다. 비슷한 방식으로 **compare-and-set(CAS)** 도 원자적 연산을 지원한다.

### **다중 객체 트랜잭션의 필요성**

- 많은 분산 데이터스토어는 다중 객체 트랜잭션 지원을 포기했다. 여러 파티션에 걸쳐서 구현하기가 어렵고 매우 높은 가용성과 성능이 필요한 곳에서는 방해가 되는 시나리오도 있기 때문이다.
- 단일 객체 삽입, 갱신, 삭제만으로 충분한 사용 사례도 있지만, 다른 경우에는 여러 개의 다른 객체에 실행되는 쓰기 작업은 코디네이션돼야 한다.
    - 관계형 데이터 모델에서 외래키 참조를 갱신할 때 다중 객체 트랜잭션은 참조가 유효한 상태가 유지되도록 보장해준다. 서로 참조하는 여러 레코드를 삽입할 때 참조 키는 올발라야 하고 최신 정보를 반영해야 한다.
    - 문서 데이터 모델에서 조인기능이 없기 때문에 비정규화를 장려하기도 하는데, 이ㄷ 때 비정규화된 정보를 갱신할 때는 한번에 여러 문서를 갱신해야 한다. 트랜잭션은 이런 상황에서 비정규화된 데이터의 동기화가 깨지는데 도움이 된다.
    - 보조 색인이 있는 데이터베이스에서는 값을 변경할 때마다 색인도 갱신돼야 한다. 예를 들어 트랜잭션 격리성이 없으면 어떤 색인에서는 레코드가 보이지만, 아직 갱신되지 않은 색인에서는 레코드가 보이지 않을 수 있다.

### **오류와 어보트 처리**

- 트랜잭션의 핵심기능은 오류가 생기면 **어보트**되고 **안전하게 재시도**할 수 있다는 것이다.
- 데이터베이스가 ACID를 위반할 위험이 있으면 중간 데이터가 있더라도 트랜잭션을 완전히 폐기한다.
- 그러나, 리더 없는 복제를 사용하는 데이터스토어는 best effort 원칙을 기반으로 일부를 반영할 수도 있다. → 오류 복구는 애플리케이션의 책임이다.
- 어보트 및 재시도는 간단하고 효과적인 오류 처리 메커니즘이지만 완벽하지는 않다.
    - 트랜잭션이 성공하고 커밋을 응답하는 도중 네트워크가 끊기면 클라이언트는 재시도를 하게 되고, 같은 트랜잭션이 **중복으로 실행**된다.
    - DB 과부하로 오류가 발생하고 있는 상황이라면 재시도는 상황을 악화시킬 수 있다. 재시도 횟수 제한, 지수적 백오프, 과부화와 관련된 오류 별도 처리 하는 방법 등으로 우회해야 한다.
    - 일시적인 오류(교착 상태, 격리성 위반, 일시적인 네트워크 오류)만 재시도할 가치가 있으며 영구적인 오류(제약 조건 위반)는 재시도해도 소용 없다.
    - 트랜잭션이 DB외에도 부수 효과가 있다면 어보트 후 재시도할 때 부수 효과가 발생할 수 있다. 예를 들어 트랜잭션 부수 효과로 이메일을 보낸다면 트랜잭션을 재시도할 때마다 이메일이 다시 전송될 수 있다. 2단계 커밋 등의 별도 기법이 필요하다.
    - 클라이언트 프로세스가 재시도 중에 죽어버리면 그 클라이언트에서 데이터베이스에 쓰려고 했던 데이터가 모두 손실된다.

## 4. 완화된 격리 수준

- 데이터베이스는 트랜잭션 격리를 제공함으로써 애플리케이션 개발자들에게 동시성 문제를 감추려고 했다.
- 직렬성 격리는 여러 트랜잭션들이 직렬적으로 실행되는 것(즉 동시성 없이 한 번에 트랜잭션 하나만 실행)과 동일한 결과가 나오도록 보장하는 것을 의미한다.
- 그러나 직렬성 격리는 성능 비용이 크다. 그래서 DB는 일부 이슈가 있을 수는 있지만 성능 문제는 크지 않은 완화된 격리 수준을 제공한다.
- 완화된 격리 수준을 몇 가지 살펴보고, 격리 수준이 보장하는 것과 발생할 수 있는 경쟁 조건을 살펴보자.

### 커밋 후 읽기 (Read Committed)

- 보장1. 커밋된 데이터만 본다. (**더티 읽기** 없음)

<img width="647" height="223" alt="image" src="https://github.com/user-attachments/assets/a2bf601e-eefd-4850-a4b0-06da12d91716" />

- 보장2. 커밋된 데이터만 덮어쓰게 된다. (**더티 쓰기** 없음)
    - "더티" 라는 것은 아직 커밋되지 않은 것을 말한다. 즉, 더티 쓰기는 아직 커밋되지 않은 값을 덮어버리는 것을 말한다.
    - 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때까지 두 번째 쓰기를 지연시키는 방법을 사용해서 방지한다.
    
<img width="609" height="349" alt="image" src="https://github.com/user-attachments/assets/f00ae3f5-ba27-44de-b715-66d9405aa2ad" />
    
- 구현 방법 1. 로우 수준 잠금을 사용해 더티 쓰기를 방지한다. 트랜잭션에서 특정 객체를 변경하고 싶으면 잠금을 획득하고, 한 트랜잭션만 잠금을 보유할 수 있다. 이런 잠금은 커밋 후 읽기레벨에서 자동으로 실행된다.
- 구현 방법 2. 더티 읽기를 막기 위해 잠금을 획득하는 것은 응답 시간 지연 문제가 발생할 수 있다. DB는 쓰여진 모든 객체에 대해 과거에 커밋된 값과 현재 쓰기 잠금을 갖고 있는 트랜잭션에서 쓴 새로운 값을 모두 기억한다. 읽기 트랜잭션에서는 과거의 값을 읽게 된다.

### 스냅숏 격리(SI)와 반복 읽기(Repeatable Read)

- 커밋된 데이터만 본다고 해서 문제가 완전히 해결되는 것은 아니다. 아래 그림7-6처럼 **읽기 스큐** 문제가 발생할 수 있다.
- 참고) 스큐(skew)는 여러 가지 의미로 사용된다. 이전에는 **핫스팟이 있는 불균형적 작업부하**라는 뜻으로 사용했지만, 여기서는 **시간적인 이상 현상(timing anomaly)** 을 뜻한다.

<img width="617" height="341" alt="image" src="https://github.com/user-attachments/assets/70eb4646-2e39-42ce-877d-bcd411a8b8e2" />

- 스냅숏 격리는 이런 문제의 가장 흔한 해결책이다. 각 트랜잭션은 데이터베이스의 **일관된 스냅숏**으로부터 읽는다.
- 즉, 트랜잭션은 시작할 때 커밋된 모든 데이터를 본다. 데이터가 나중에 다른 트랜잭션에 의해 변경되어도 각 트랜잭션은 특정한 시점의 과거 데이터를 본다.
- **스냅숏 격리 구현 MVCC(Multi Version Concurrency Control)**
    - MVCC는 쓰기에는 잠금을 사용하고, 읽을 때는 잠금을 사용하지 않는다. 따라서 일관성 있는 스냅숏에 대해 오래 실행되는 읽기 작업을 처리할 수 있다.
    - 데이터베이스는 객체마다 커밋된 버전 여러 개를 유지하고 있는다. (multi-version-concurrency-control, MVCC)
    - 트랜잭션이 시작할 때 고유한 트랜잭션 ID(txid)를 할당받고, 데이터를 쓸 때마다 쓰기를 실행한 트랜잭션의 ID가 함께 붙는다(`created_by 필드`). 삭제될 때도 데이터를 지우는게 아니라, 삭제한 트랜잭션의 ID(`deleted_by 필드`)가 붙는다. 갱신은 내부적으로 삭제와 생성으로 변환되어 수행된다.
    
<img width="636" height="521" alt="image" src="https://github.com/user-attachments/assets/68a1f992-3009-484c-bc1c-6c26c3f2082c" />
    
- **일관된 스냅숏을 보는 가시성 규칙**
  - 데이터베이스는 트랜잭션을 시작할 때 그 시점에 진행 중인 모든 트랜잭션 목록을 만든다. 각 트랜잭션에서는 **진행중인 트랜잭션은 무시**한다.
  - **어보트된 트랜잭션이 쓴 데이터는 모두 무시**한다.
  - **트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터는 무시**한다. (즉, 나중에 시작된 트랜잭션 무시)
  - 그 밖의 모든 데이터는 질의로 조회 가능하다.

### 갱신 손실(lost update) 방지

- 갱신 손실 문제는 애플리케이션에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때(**read-modify-write**) 발생할 수 있다. 마지막 쓰기 작업이 이전의 쓰기 작업을 덮어쓰게 되므로 손실이 발생한다.
- 갱신 손실 발생 시나리오 예시
    - 카운터를 증가시키거나 계좌잔고를 갱신한다.(현재 값을 읽고, 새 값을 계산한 후 값을 다시 쓴다.)
    - 위키에서 두 명의 사용자가 동시에 같은 페이지를 편집한다.
- 해결책
    - **원자적 쓰기 연산:** DB레벨에서 read-modify-write주기를 제공 `UPDATE counters SET value = value + 1 WHERE key = ‘foo’;`
    - **명시적인 잠금:** 애플리케이션 레벨에서 잠금을 획득하는 방법. `SELECT ~ FOR UPDATE`
    - **갱신 손실 자동 감지:** 위의 방법들과 다르게 read-write-modify 주기를 순차적으로 실행되게 하는 것이 아니라, 병렬로 실행하게 하되 트랜잭션 관리자가 갱신 손실을 발견하면 트랜잭션을 어보트시키고 재시도하도록 강제하는 방법. DB마다 제공 여부가 다르니 확인 필요.
    - **Compare-and-set:** 값을 마지막으로 읽은 후 변경 되지 않았을 때만 갱신을 허용하는 방법.

### 충돌 해소와 복제

- 다중 리더 또는 리더 없는 복제를 사용하는 데이터베이스는 여러 쓰기가 동시에 실행되고 비동기식으로 복제되는 것을 허용하므로 다른 접근 방법이 필요하다.
- 복제가 적용된 데이터베이스에서 흔히 쓰는 방법은 **형제(sibling)** 라고 부르는 한 값에 여러 개의 충돌된 버전을 생성하고 추후에 애플리케이션 코드나 특별한 구조를 사용해 충돌을 해소하는 것이다.

### 쓰기 스큐와 팬텀

- **쓰기 스큐**:  두 트랜잭션이 각자 **다른 행**을 수정하지만, 수정 결과가 합쳐졌을 때 **공유 불변식(예: “항상 최소 1명 on-call”)** 을 위반하는 현상.
- **전제 조건**
    1. 제약이 **단일 행이 아니라 “조건을 만족하는 행들의 집합”** 에 걸려 있다.
    2. 두 트랜잭션이 **같은 조건을 조회**한다(예: on_call = true AND shift_id = 1234인 의사 수).
    3. 각 트랜잭션은 **서로 다른 행**을 변경한다(그래서 **행 수준의 write-write 충돌이 없다**).
    4. 동시에 진행되므로 **서로의 변경이 조회 결과에 반영되지 않는다**.
- **전형적 시나리오(체크 → 쓰기 경합)**
    1. 둘 다 “지금 on-call 의사 수가 충분”하다고 **SELECT**로 판단
    2. 각각 자기 레코드를 **UPDATE** 해서 off로 바꿈
    3. 둘 다 커밋하면, 최종 상태가 “on-call = 0”이 되어 **불변식이 깨짐**
- **왜 스냅샷 격리(SI)로는 막지 못하나**
    - SI에서는 각 트랜잭션이 **자기 스냅샷**을 읽는다. 두 트랜잭션 모두 “안전한” 동일 스냅샷을 보고 출발하므로 **읽기 결과가 같다**.
    - 서로 **다른 행을 수정**하니 **쓰기 충돌**도 없다.
    - 업데이트 결과로 **조건을 만족하는 행의 집합이 바뀌는 것**(= **팬텀**)을 **SI는 차단하지 않는다**. 그래서 둘 다 커밋 가능.
    - 요약: SI는 **더티 읽기/반복 불가능 읽기/잃어버린 갱신** 등은 막지만, **쓰기 스큐/팬텀**은 허용될 수 있다.

<img width="574" height="441" alt="image" src="https://github.com/user-attachments/assets/69748332-1ff3-45b3-9991-60cb918ac596" />

### 쓰기 스큐를 특정짓기

- 쓰기 스큐는 두 트랜잭션이 두 개의 다른 객체를 갱신하므로 더티 쓰기도 갱신 손실도 아니다.
- 만약 두 트랜잭션이 한 번에 하나씩 실행됐다면 두 번째 의사는 호출 대기를 끄는 게 방지됐을 것이다. 즉, 트랜잭션이 동시에 실행됐기 때문에 이상 동작이 나타났다.
- 쓰기 스큐는 두 트랜잭션이 같은 객체들을 읽어서 그중 일부를 갱신할 때 나타날 수 있다.(다른 트랜잭션은 다른 객체를 갱신한다.) 반면, 더티 쓰기나 갱신 손실은 서로 다른 트랜잭션이 하나의 동일한 객체를 갱신하는 경우에 발생한다.
- 해결책
    - 여러 객체가 관련되므로 원자적 단일 객체 연산은 소용 없다.
    - 일부 스냅숏 격리 구현에서 제공되는 갱신 손실 자동 감지도 소용 없다.
    - 어떤 데이터베이스는 제약 조건을 설정할 수 있다. 데이터베이스에 따라 트리거나 구체화 뷰(materialized view)를 사용해 구현할 수 있다.
    - 직렬성 격리 수준을 사용할 수 없다면 트랜잭션이 의존하는 로우를 명시적으로 잠그는 것이 차선책이다. 의사 문제의 경우 아래와 같이 질의를 작성할 수 있다.
    
<img width="567" height="387" alt="image" src="https://github.com/user-attachments/assets/f44818af-19da-49ac-b6ef-ef474b58bb44" />

### 추가적인 쓰기 스큐의 예

- **회의실 예약 시스템**: 동시에 같은 회의실을 중복 예약할 수 없다.

<img width="736" height="393" alt="image" src="https://github.com/user-attachments/assets/5d6c2d8c-fe9f-45c9-be46-7821ba09c700" />

- **다중 플레이어 게임:** 플레이어들이 두 개의 다른 물체를 게임판 위의 같은 위치로 옮기거나 잠재적으로 게임의 규칙을 위반하는 이동을 하는 경우
- **사용자명 획득:** 두 명의 사용자가 같은 사용자명으로 계정 생성을 시도. 이 경우 유일성 제약조건이 간단한 해결책
- **이중 사용(double-spending) 방지:** 사용자가 돈이나 포인트를 지불하는 서비스에서는 사용자가 가진 것보다 더 많이 지불하지 않는지 확인해야 한다.

<img width="733" height="380" alt="image" src="https://github.com/user-attachments/assets/4747e176-e70b-4c8c-bf30-e4220a6f5004" />

## 5. 직렬성

- 여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 **직렬로** 실행될 때와 같도록 보장하는 가장 강력한 격리 수준. 즉, 데이터베이스가 발생할 수 있는 모든 경쟁 조건을 막아준다.
- 직렬성을 구현하는 세 가지 기법
    - **실제적인 직렬 실행:** 말 그대로 트랜잭션을 순차적으로 실행
    - **2단계 잠금(2PL):** 수십 년 동안 유일한 수단이었음
    - **직렬성 스냅숏 격리(SSI):** 낙관적 동시성 제어(optimistic concurrency control) 기법

### 실제적인 직렬 실행

- 한 번에 트랜잭션 하나씩만 직렬로 단일 스레드에서 실행
- RAM 가격이 저렴해지면서 데이터셋 전체를 메모리에 유지할 수 있을 정도가 됐다. 트랜잭션이 접근하는 데이터가 메모리에 있게 되면 디스크에서 읽어오는 것보다 트랜잭션이 훨씬 빨리 실행될 수 있다.
- OLTP 트랜잭션은 보통 짧기 때문에 단일 스레드로 트랜잭션을 처리해도 충분하다.
- 모든 트랜잭션은 작고 빨라야 한다. 느린 트랜잭션 하나가 모든 트랜잭션 처리를 지연시킬 수 있기 때문
- 활성화된 데이터셋이 메모리에 적재될 수 있는 경우로 사용이 제한된다. 단일 스레드 트랜잭션에서 디스크에 접근해야 한다면 시스템이 매우 느려진다.
- 쓰기 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 충분히 낮아야 한다. 그렇지 않으면 여러 파티션에 걸친 코디네이션이 필요하지 않도록 트랜잭션을 파티셔닝해야 한다.

### 2단계 잠금(2PL)

- 약 30년 동안 데이터베이스에서 직렬성을 구현하는 널리 쓰인 유일한 알고리즘. 2단계 잠금(two-phase locking, 2PL)
- 2PL은 직렬성을 제공하므로 앞에서 설명했던 갱신 손실과 쓰기 스큐를 포함한 모든 경쟁 조건으로부터 보호해준다.
- 2PL에서는 읽기/쓰기에 따라 각각 다른 잠금을 획득하고 실행되며, 이들은 서로 공존할 수 없다. 즉, 쓰기 트랜잭션이 실행되는 동안 읽기 트랜잭션은 실행될 수 없으며, 읽기 트랜잭션이 실행되는 동안 쓰기 트랜잭션은 실행될 수 없다.
- 스냅숏 격리는 읽는 쪽은 결코 쓰는 쪽을 막지 않으며 쓰는 쪽도 결코 읽는 쪽을 막지 않는다는 원칙이 있는데, 이게 스냅숏 격리와 2단계 잠금의 중요한 차이다. (2PL에서는 읽기와 쓰기가 서로를 막는다.)
- 잠금은 **공유 모드(shared mode)**나 **독점 모드(exclusive mode)**로 사용될 수 있다.
    - 트랜잭션이 객체를 읽기 원한다면 공유 모드로 잠금을 획득해야 한다. 여러 트랜잭션이 공유 모드로 잠금을 획득하는 것은 허용되지만, 그 객체에 이미 독점 모드로 잠금을 획득한 트랜잭션이 있으면 완료될 때 까지 기다려야 한다.
    - 트랜잭션이 객체에 쓰기를 원하면 독점 모드로 잠금을 획득 해야 한다. 독점 모드로 잠금을 획득하면 공유모드든지 독점 모드든지 어떤 트랜잭션도 동시에 잠금을 획득할 수 없다.
    - 트랜잭션이 객체를 읽다가 쓰기를 실행할 때는 공유 잠금을 독점 잠금으로 업그레이드 해야 한다.
    - 트랜잭션이 잠금을 획득한 후에 트랜잭션이 종료될 때까지 잠금을 갖고 있어야 한다. 그래서 “2단계”라는 이름이 붙었다.
- 잠금이 많이 사용되기 때문에 교착 상태를 조심해야 한다.
- 또, 완화된 격리 수준보다 성능이 안좋기 때문에 1970년대부터 모두가 이것을 쓰지 않기도 했다. 잠금을 획득하고 해제하는 오버헤드 때문이기도 하지만, 더 중요한 것은 동시성이 줄어드는 것이다.
- **서술 잠금(predicate/range lock)** 필요: 조건에 해당하는 **아직 존재하지 않는 행**까지 보호(팬텀 차단).
- **색인 범위 잠금(index-range locking, next-key locking):** 색인에 공유 잠금을 잡아서 경쟁을 차단한다. 적절한 인덱스가 없다면 테이블 전체에 공유 잠금을 잡는 것으로 대체한다. 이건 성능에는 좋지 않지만 안전한 대비책이다.

### 직렬성 스냅숏 격리(SSI)

- 2단계 잠금은 성능이 좋지 않고, 직렬 실행은 확장이 어렵다.
- 완화된 격리 수준은 성능은 좋지만 다양한 경쟁 조건(갱신 손실, 쓰기 스큐, 팬텀 등)에 취약하다.
- 오늘날 SSI는 단일 노드 데이터베이스와 분산 데이터베이스 모두에서 사용되는 직렬성 격리와 좋은 성능을 공존 가능하게 만드는 알고리즘이다.
- 2단계 잠금은 **비관적 동시성 제어** 메커니즘이다. 즉, 잘못될 가능성이 있으면 상황이 안전해질 때까지 기다리는 게 낫다는 원칙을 기반으로 한다. 상호 배제(mutual exclusion)와 비슷하다.
- 반면 직렬성 스냅숏 격리는 **낙관적 동시성 제어** 메커니즘이다. 위험한 상황이 발생할 가능성이 있을 때 트랜잭션을 막는 대신 상황이 괜찮아질 거라는 희망을 갖고 계속 진행한다는 뜻이다.  트랜잭션을 커밋하기 전에 나쁜 상황이 발생했는지 확인하고, 잘못되었다면 트랜잭션을 어보트하고 재시도해야 한다.
- SSI는 스냅숏 격리 위에서 작업 사이의 직렬성 충돌을 감지하고 어보트시킬 트랜잭션을 결정하는 앎고리즘을 추가한다.
- **뒤처진 전제에 기반한 결정:** 트랜잭션이 데이터베이스에서 어떤 데이터를 읽고 그 질의 결과를 기반으로 쓰기를 결정하는데, 스냅숏 격리에서는 이 질의 결과가 최신이 아닐 수 있다. 따라서 두 가지 상황을 고려해야 한다.(오래된 MVCC 읽기 감지, 과거의 읽기에 영향을 미치는 쓰기 감지)
- **오래된 MVCC 읽기 감지하기:** 오래된 MVCC를 읽었고 커밋 시점에 전제가 달라졌다면(이전 버전이 커밋되었다면) 해당 트랜잭션을 어보트하고, 재시도하도록 한다.

<img width="605" height="386" alt="image" src="https://github.com/user-attachments/assets/201f9147-7655-494d-b042-133411ffaf28" />

- **과거의 읽기에 영향을 미치는 쓰기 감지하기:** 데이터를 읽은 후 다른 트랜잭션에서 그 데이터를 변경할 때를 고려해야 한다.

<img width="619" height="410" alt="image" src="https://github.com/user-attachments/assets/c662e054-9c58-4379-974b-e1d85744bd14" />

## 6. 7장 정리

- “트랜잭션은 현실 세계의 실패·경쟁·네트워크 문제를 애플리케이션 바깥에서 흡수해 주는 안전 장치”라는 전제에서 ACID(원자성·일관성·격리성·지속성)를 실제 의미와 한계까지 해부한다.
- 단일 객체에는 원자적 갱신(레코드 교체, 카운터 증가, CAS 등)으로도 많은 문제가 풀리지만, 여러 객체를 함께 갱신·검사할 땐 트랜잭션 수준의 보호가 필요하다.
- 가장 보편적인 커밋 후 읽기(Read Committed) 는 더티 읽기·더티 쓰기를 막지만, 같은 값의 반복 읽기 보장은 없고 경쟁 윈도우가 넓다.
- 스냅샷 격리(SI, MVCC 기반) 는 읽기 일관성을 크게 높이고 갱신 손실을 줄이지만, 조건에 걸린 “행 집합”이 바뀌는 팬텀과 그로 인한 쓰기 스큐(서로 다른 행을 고쳐 공통 제약을 깨뜨림)는 허용할 수 있다.
- 쓰기 스큐/팬텀을 막으려면 2단계 잠금(2PL) + 술어/범위 잠금으로 질의의 “범위” 자체를 잠그거나, DB가 의존성 그래프를 추적해 사이클을 중단하는 SSI(Serializable Snapshot Isolation) 를 사용한다.
- 갱신 손실은 SELECT ~ FOR UPDATE, 명시적 잠금, CAS/Compare-and-Set, 커서 안정성, 충돌을 구체화(materializing conflict)(집계 행·슬롯 행에 의도적 충돌 만들기) 등으로 예방한다.
- 충돌·지연을 줄이려면 라운드트립을 줄이는 스토어드 프로시저/서버 측 실행이 도움이 되고, 반대로 분산·파티셔닝 환경에서는 범위 잠금·전역 직렬화가 더 어렵다는 점을 설계에 반영해야 한다.
- 격리 수준은 비용 대비 효과가 다르므로, 읽기 위주·분석계는 SI도 충분할 수 있지만 불변식이 중요한 OLTP 는 가능하면 직렬화(2PL/SSI) 또는 모델링으로 충돌을 노출시키는 방식을 선택한다.
- 마지막으로, 실패는 언제든 일어나므로 재시도·멱등성·오류 보상을 애플리케이션 레벨에 갖추는 것이 트랜잭션 설계의 일부다.
