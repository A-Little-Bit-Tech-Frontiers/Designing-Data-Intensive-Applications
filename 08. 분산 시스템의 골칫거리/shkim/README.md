# 분산 시스템의 문제점

최근 몇 장에서 반복적으로 다룬 주제는 시스템이 문제 상황을 어떻게 처리하는가였습니다. <br>
예를 들어, 복제본 장애 조치, 복제 지연, 트랜잭션 동시성 제어 등을 논의했습니다. 실제 시스템에서 발생할 수 있는 다양한 엣지 케이스를 이해할수록, 이를 더 잘 다룰 수 있게 됩니다. <br>
그러나 많은 장애에 대해 이야기했음에도, 지난 몇 장은 여전히 지나치게 낙관적이었습니다. 현실은 더 어둡습니다. 이제 우리는 비관주의를 극대화하여, 잘못될 수 있는 것은 무엇이든 잘못된다고 가정하겠습니다.

## 장애와 부분 실패

CPU 명령은 항상 동일한 일을 수행합니다. 메모리나 디스크에 데이터를 쓰면 그 데이터는 무작위로 손상되지 않고 그대로 유지됩니다. <br>
이러한 항상-정확한 계산이라는 설계 목표는 최초의 디지털 컴퓨터로 거슬러 올라갑니다.

여러 대의 컴퓨터가 네트워크로 연결되어 동작하는 소프트웨어를 작성할 때 상황은 근본적으로 달라집니다. <br>
분산 시스템에서는 더 이상 이상화된 시스템 모델에서 운영하지 않습니다—물리 세계의 지저분한 현실을 마주할 수밖에 없습니다. <br>
그리고 물리 세계에서는 놀랄 만큼 다양한 일이 잘못될 수 있습니다.

분산 시스템에서는 일부 구성 요소가 예측 불가능한 방식으로 고장 나 있을 수 있으며, 다른 구성 요소는 정상적으로 작동할 수 있습니다. <br>
이를 ‘부분 실패’라고 합니다. 어려운 점은 부분 실패가 비결정적이라는 것입니다. 여러 노드와 네트워크가 관련된 어떤 작업을 시도할 때, 어떤 때는 성공하고 어떤 때는 예측 불가능하게 실패할 수 있습니다.

> **클라우드 컴퓨팅과 슈퍼컴퓨팅** <br>
> 
> 대규모 컴퓨팅 시스템을 구축하는 철학에는 스펙트럼이 존재합니다.
> - 한쪽 끝에는 고성능 컴퓨팅(HPC) 분야가 있습니다. 수천 개의 CPU를 갖춘 슈퍼컴퓨터는 일반적으로 날씨 예측이나 분자 동역학(원자와 분자의 움직임을 시뮬레이션)과 같은 계산 집약적 과학 계산 작업에 사용됩니다.
> - 다른 극단에는 클라우드 컴퓨팅이 있습니다. 이는 명확히 정의되지는 않았지만, 다중 테넌트 데이터센터, IP 네트워크(종종 이더넷)로 연결된 범용 컴퓨터, 탄력적/온디맨드 자원 할당, 사용량 기반 과금 등이 연상됩니다.
> - 전통적인 엔터프라이즈 데이터센터는 이 극단들 사이 어딘가에 위치합니다.
> 
> 이러한 철학에는 장애 처리 방식의 큰 차이가 따라옵니다. 슈퍼컴퓨터에서는 작업이 일정 시간마다 내구성 있는 저장소에 계산 상태를 체크포인트합니다. <br>
> 하나의 노드가 실패하면 일반적인 해결책은 전체 클러스터의 작업을 단순히 중지하는 것입니다. 결함 노드가 복구된 후 마지막 체크포인트에서 계산을 재시작합니다. <br>
> 따라서 슈퍼컴퓨터는 단일 노드 컴퓨터에 더 가깝습니다: 부분 실패를 전체 실패로 확대하여 시스템의 어떤 부분이라도 실패하면 모든 것을 충돌시키는(단일 머신의 커널 패닉처럼) 방식으로 처리합니다.
> 분산 시스템을 제대로 작동시키고자 한다면, 부분 실패의 가능성을 받아들이고 소프트웨어에 내장된 내결함성 메커니즘을 구축해야 합니다. 즉, 신뢰할 수 없는 구성 요소로부터 신뢰할 수 있는 시스템을 만들어야 합니다.

## 신뢰할 수 없는 네트워크

이 책에서 중점적으로 다루는 분산 시스템은 ‘셰어드-낫싱(shared-nothing) 시스템’입니다. <br>
즉, 네트워크로 연결된 여러 대의 머신 집합입니다. 네트워크만이 이들 머신이 소통할 수 있는 유일한 수단입니다. <br>
각 머신은 자체 메모리와 디스크를 가지고 있고, 한 머신이 다른 머신의 메모리나 디스크에 접근할 수 없습니다(서비스에 네트워크 요청을 보내는 경우를 제외합니다).

셰어드-낫싱은 시스템을 구축하는 유일한 방법은 아니지만, 인터넷 서비스를 구축하는 데 있어 지배적인 접근법이 되었습니다. <br>
그 이유는 비교적 저렴하고(특수 하드웨어가 필요 없기 때문), 범용화된 클라우드 컴퓨팅 서비스를 활용할 수 있으며, 여러 지리적으로 분산된 데이터센터 간의 중복성을 통해 높은 신뢰성을 달성할 수 있기 때문입니다.

이러한 상황에서 송신자는 패킷이 전달되었는지조차 알 수 없습니다. 유일한 옵션은 수신자가 응답 메시지를 보내는 것인데, 그 응답조차도 손실되거나 지연될 수 있습니다. <br>
비동기 네트워크에서는 이러한 이슈들이 구분되지 않습니다. 여러분이 가진 유일한 정보는 아직 응답을 받지 못했다는 사실뿐입니다. <br>
다른 노드로 요청을 보내고 응답을 받지 못하면, 그 이유를 판단하는 것은 불가능합니다. 이 문제를 다루는 일반적인 방법은 ‘타임아웃’입니다. 일정 시간이 지나면 기다림을 포기하고 응답이 오지 않을 것이라고 가정합니다.

### **실무에서의 네트워크 장애**

네트워크 문제로부터 자유로운 사람은 없습니다. <br>
예를 들어, 스위치의 소프트웨어 업그레이드 중 문제로 인해 네트워크 토폴로지 재구성이 트리거되고, 이 과정에서 네트워크 패킷이 1분 이상 지연될 수 있습니다. <br>
상어가 해저 케이블을 물어 손상시키는 경우도 있습니다. 또 다른 놀라운 장애로는, 어떤 네트워크 인터페이스가 때때로 모든 수신 패킷을 드롭하지만, 송신 패킷은 정상적으로 보낼 수 있는 경우가 있습니다. <br>
네트워크 링크가 한 방향에서 작동한다고 해서 반대 방향에서도 작동한다고 보장되지 않습니다.

여러분의 환경에서 네트워크 장애가 드물더라도, 장애가 발생할 수 있다는 사실 때문에 소프트웨어는 이를 처리할 수 있어야 합니다. <br>
네트워크를 통한 통신이 일어날 때마다 실패할 수 있습니다—이를 피할 방법은 없습니다. 소프트웨어가 예상치 못한 상황에 놓이면, 임의의 예상치 못한 행동을 할 수 있습니다.

### **장애 감지**

많은 시스템은 결함 난 노드를 자동으로 감지해야 합니다. 불행히도 네트워크의 불확실성 때문에 노드가 정상인지 아닌지를 판별하는 것은 어렵습니다. <br>
특정 상황에서는 무언가가 작동하지 않는다는 명시적 피드백을 받을 수 있습니다. <br>
요청이 성공했음을 확실히 하려면, 애플리케이션 자체로부터 긍정적인 응답이 필요합니다. <br>
반대로 문제가 생긴 경우, 스택의 어떤 레벨에서 오류 응답을 받을 수도 있지만, 일반적으로는 아무런 응답도 받지 못할 것이라고 가정해야 합니다.

### **타임아웃과 무한 지연**

타임아웃이 장애를 감지하는 유일한 확실한 방법이라면, 타임아웃을 얼마로 설정해야 할까요? 불행히도 간단한 답은 없습니다.

긴 타임아웃은 노드가 죽었다고 선언하기까지 긴 대기 시간을 의미합니다(그 동안 사용자는 대기하거나 오류 메시지를 볼 수 있습니다). <br>
짧은 타임아웃은 더 빠르게 장애를 감지하지만, 실제로는 일시적 느려짐(예: 노드 또는 네트워크의 부하 급증) 때문에 노드가 죽었다고 잘못 선언할 위험이 더 큽니다.

조기에 노드를 죽었다고 선언하는 것은 문제를 일으킵니다. 노드가 죽었다고 선언되면, 그 노드의 책임을 다른 노드로 이전해야 하며, 이는 다른 노드와 네트워크에 추가적인 부하를 가합니다. <br>
시스템이 이미 높은 부하로 고군분투 중이라면, 조기 선언은 문제를 악화시킬 수 있습니다. <br>
특히, 실제로 노드는 죽지 않았고 단지 과부하로 응답이 느렸을 뿐일 수 있습니다. <br>
그 노드의 부하를 다른 노드로 이전하면 연쇄적인 실패를 유발할 수 있습니다(극단적인 경우, 모든 노드가 서로를 죽었다고 선언하고 모든 것이 작동을 멈출 수 있습니다).

불행히도 우리가 다루는 대부분의 시스템에는 최소 또는 최대 응답 시간 보장이 없습니다. <br>
비동기 네트워크는 무한 지연(즉, 패킷을 가능한 한 빨리 전달하려고 하지만, 패킷이 도착하는 데 걸리는 시간에 상한이 없음)을 가지며, 대부분의 서버 구현은 요청을 일정한 최대 시간 내에 처리할 수 있다는 보장을 할 수 없습니다. <br>
장애 감지를 위해서는 시스템이 대부분의 시간에 빠른 것만으로는 충분하지 않습니다. 타임아웃이 낮으면 왕복 시간의 일시적 스파이크만으로도 시스템이 균형을 잃을 수 있습니다.

### **네트워크 혼잡과 큐잉**

컴퓨터 네트워크에서 패킷 지연 변동은 대부분 큐잉 때문에 발생합니다.

- 여러 노드가 동시에 동일한 목적지로 패킷을 보내려고 하면, 네트워크 스위치는 이를 큐에 넣고 목적지 네트워크 링크에 하나씩 공급해야 합니다. 바쁜 네트워크 링크에서는 패킷이 슬롯을 얻기까지 기다려야 할 수 있습니다(이를 ‘네트워크 혼잡’이라고 합니다). 들어오는 데이터가 너무 많아 스위치 큐가 가득 차면 패킷이 드롭되며, 네트워크가 정상적으로 기능하고 있음에도 재전송이 필요합니다.
- 패킷이 목적지 머신에 도착했을 때, 모든 CPU 코어가 현재 바쁘다면, 운영체제는 네트워크에서 들어오는 요청을 애플리케이션이 처리할 준비가 될 때까지 큐에 넣습니다. 머신의 부하에 따라 이 대기 시간은 임의의 길이가 될 수 있습니다.
- 가상화 환경에서는 실행 중인 운영체제가 다른 가상 머신이 CPU 코어를 사용하는 동안 수십 밀리초 동안 일시 정지되는 경우가 흔합니다. 이 시간 동안 해당 VM은 네트워크에서 데이터를 소비할 수 없으므로, 들어오는 데이터는 가상화 모니터에 의해 큐(버퍼링)됩니다. 이는 네트워크 지연 변동을 더욱 증가시킵니다.
- TCP는 흐름 제어(‘혼잡 회피’ 또는 ‘역압’으로도 알려짐)를 수행하며, 노드는 네트워크 링크나 수신 노드의 과부하를 피하기 위해 자신의 송신 속도를 제한합니다. 이는 데이터가 네트워크에 들어가기 전에 송신 측 큐잉을 의미합니다. 또한 TCP는 패킷이 특정 타임아웃 내에 확인(ACK)되지 않으면 패킷이 손실된 것으로 간주하며, 손실된 패킷을 자동으로 재전송합니다.

이처럼 변동성이 큰 환경에서는 타임아웃을 실험적으로만 설정할 수 있습니다. <br>
장기간에 걸쳐 많은 머신에서 네트워크 왕복 시간 분포를 측정하여 지연의 예상 변동 폭을 파악해야 합니다. <br>
그런 다음 애플리케이션의 특성을 고려하여, 장애 감지 지연과 조기 타임아웃 위험 사이에서 적절한 절충을 결정할 수 있습니다.

### **동기식 대 비동기식 네트워크**

네트워크가 일정한 최대 지연 내에서 패킷을 전달하고 패킷을 드롭하지 않는다고 신뢰할 수 있다면, 분산 시스템은 훨씬 단순해질 것입니다. <br>
TCP 연결의 패킷은 사용 가능한 네트워크 대역폭을 기회적으로 활용합니다. <br>
TCP에 가변 크기의 데이터 블록(예: 이메일이나 웹페이지)을 제공하면 가능한 한 짧은 시간 내에 전송하려고 시도합니다. <br>
TCP 연결이 유휴 상태일 때는 대역폭을 사용하지 않습니다. 이더넷과 IP는 패킷 교환 프로토콜로, 큐잉에 의해 네트워크에서 무한 지연을 겪을 수 있습니다.

데이터센터 네트워크와 인터넷이 패킷 교환을 사용하는 이유는 무엇일까요? 답은 ‘버스티(bursty) 트래픽’에 최적화되어 있기 때문입니다. <br>
회선 교환은 통화처럼, 통화 기간 동안 초당 비교적 일정한 비트 수를 전송해야 하는 경우에 적합합니다. <br>
반면, 웹페이지 요청, 이메일 전송, 파일 전송은 특정 대역폭 요구사항이 없습니다—우리는 단지 가능한 한 빨리 완료되길 원합니다. <br>
TCP는 사용 가능한 네트워크 용량에 맞추어 데이터 전송 속도를 동적으로 조정합니다.

품질 보장(QoS: 패킷의 우선순위 지정 및 스케줄링)과 수락 제어(발신자 속도 제한)를 신중히 사용하면, 패킷 네트워크에서 회선 교환을 에뮬레이션하거나 통계적으로 경계가 있는 지연을 제공할 수 있습니다. <br>
그러나 이러한 QoS는 현재 다중 테넌트 데이터센터와 공용 클라우드, 또는 인터넷 통신에서 활성화되어 있지 않습니다. <br>
iv 현재 배포된 기술은 네트워크의 지연이나 신뢰성에 대해 어떤 보장도 제공하지 못합니다. 우리는 네트워크 혼잡, 큐잉, 무한 지연이 발생할 것이라고 가정해야 합니다. <br>
결과적으로 타임아웃의 ‘정답’ 값은 없습니다—실험적으로 결정해야 합니다.

## 신뢰성 없는 시계

분산 시스템에서 시간은 까다로운 문제입니다. 통신은 즉시 이루어지지 않기 때문입니다. <br>
메시지가 한 머신에서 다른 머신으로 네트워크를 통해 이동하는 데 시간이 걸립니다. 메시지 수신 시점, 메시지 순서, 네트워크 지연, 개별 시계—이 모든 것이 시간을 매우 신뢰하기 어렵게 만듭니다.

어느 정도까지는 시계를 동기화할 수 있습니다.<br>
가장 흔히 사용되는 메커니즘은 ‘네트워크 타임 프로토콜(NTP)’로, 컴퓨터 시계를 여러 서버가 보고하는 시간에 맞춰 조정합니다. <br>
서버는 더 정확한 시간 소스(예: GPS 수신기)에서 시간을 가져옵니다.

### **단조 시계(Monotonic) vs. 일시(時時) 시계(Time-of-day)**

일시 시계는 직관적으로 기대하는 일을 합니다. 즉, 어떤 달력(‘벽시계 시간’이라고도 함)에 따라 현재 날짜와 시간을 반환합니다. <br>
일시 시계는 일반적으로 NTP로 동기화되므로, 한 머신의 타임스탬프가(이상적으로) 다른 머신의 타임스탬프와 동일한 의미를 갖습니다.

단조 시계는 지속 시간(시간 간격), 예를 들어 타임아웃이나 서비스 응답 시간을 측정하는 데 적합합니다. <br>
이름은 시계가 항상 앞으로만 움직인다는 보장에서 비롯됩니다(반면 일시 시계는 시간이 뒤로 점프할 수 있습니다).

분산 시스템에서 경과 시간(예: 타임아웃)을 측정할 때 단조 시계를 사용하는 것은 일반적으로 괜찮습니다. <br>
서로 다른 노드의 시계 동기화를 가정하지 않으며, 측정의 약간의 부정확성에도 민감하지 않기 때문입니다.

### **동기화된 시계에 의존하기**

단조 시계는 동기화를 필요로 하지 않지만, 일시 시계는 NTP 서버나 다른 외부 시간 소스에 맞춰 설정되어야 유용합니다. <br>
어떤 소프트웨어가 정확히 동기화된 시계에 의존한다면, 그 결과는 극적인 크래시보다는 조용하고 미묘한 데이터 손실일 가능성이 더 큽니다. <br>
따라서 동기화된 시계를 필요로 하는 소프트웨어를 사용한다면, 모든 머신 간의 시계 오프셋을 신중히 모니터링하는 것이 필수적입니다.

## 지식, 진실, 그리고 거짓

지금까지 이 장에서는 분산 시스템이 단일 컴퓨터에서 실행되는 프로그램과 어떻게 다른지 살펴보았습니다. <br>
공유 메모리가 없고, 오직 가변 지연을 가진 신뢰할 수 없는 네트워크를 통한 메시지 전달만 있으며, 시스템은 부분 실패, 신뢰할 수 없는 시계, 처리 중단을 겪을 수 있습니다.

### **진실은 다수결로 정의됩니다**

비대칭 장애를 가진 네트워크를 상상해 보십시오. 어떤 노드는 자신에게 보내진 모든 메시지를 받을 수 있지만, 그 노드에서 나가는 모든 메시지는 드롭되거나 지연됩니다. <br>
분산 시스템은 단일 노드에만 배타적으로 의존할 수 없습니다. <br>
노드는 언제든지 실패할 수 있으며, 잠재적으로 시스템을 멈추고 복구 불가능하게 만들 수 있기 때문입니다. <br>
그래서 많은 분산 알고리즘은 ‘쿼럼’에 의존합니다. 즉, 노드 간 투표를 통해 의사 결정을 내리는 것입니다. 특정 노드에 대한 의존도를 줄이기 위해, 결정에는 여러 노드로부터 최소한의 표 수가 필요합니다.

### 시스템 모델과 현실

시스템에서 발생할 것으로 예상하는 장애 유형을 어떤 방식으로든 형식화해야 합니다. 이를 위해 ‘시스템 모델’을 정의합니다. 시스템 모델은 알고리즘이 어떤 것을 가정할 수 있는지를 설명하는 추상화입니다.

‘타이밍 가정’과 관련하여 일반적으로 사용되는 세 가지 시스템 모델이 있습니다:

- ‘동기식 모델’(네트워크 지연 상한, 프로세스 정지 상한, 시계 오차 상한이 존재)
- ‘부분 동기식 모델’(네트워크 지연, 프로세스 정지, 시계 드리프트가 때때로 상한을 초과)
- ‘비동기식 모델’(알고리즘이 어떤 타이밍 가정도 할 수 없음—사실, 시계 자체가 없어서 타임아웃을 사용할 수 없음)

타이밍 이슈 외에도 ‘노드 실패’를 고려해야 합니다. 노드에 대한 가장 일반적인 세 가지 시스템 모델은 다음과 같습니다:

- ‘Crash-stop 장애’(노드는 오직 한 가지 방식—크래시—으로만 실패)
- ‘Crash-recovery 장애’(노드는 언제든지 크래시할 수 있으며, 알 수 없는 시간이 지난 후 다시 응답하기 시작할 수도 있음)
- ‘비잔틴(임의) 장애’(노드는 절대적으로 무엇이든 할 수 있으며, 다른 노드를 속이고 기만하려는 행동도 포함)

실제 시스템을 모델링할 때는 ‘부분 동기식 모델’과 ‘Crash-recovery 장애’ 조합이 일반적으로 가장 유용합니다.

### **알고리즘의 정합성(Correctness)**

알고리즘이 올바르다는 의미를 정의하기 위해, 우리가 원하는 속성을 기술할 수 있습니다. 분산 알고리즘에 기대하는 속성은 다음과 같습니다:

- ‘유일성’(펜싱 토큰에 대한 두 요청이 동일한 값을 반환하지 않음)
- ‘단조 시퀀스’(요청 x가 토큰 tx를 반환했고, 요청 y가 토큰 ty를 반환했으며, x가 완료된 후 y가 시작되었다면, tx < ty)
- ‘가용성’(펜싱 토큰을 요청하고 크래시하지 않는 노드는 결국 응답을 받음)

알고리즘은 특정 시스템 모델에서, 그 모델에서 발생할 수 있다고 가정하는 모든 상황에서 위 속성을 항상 만족하면 ‘정합적’이라고 합니다. <br>
이 경우, ‘유일성’과 ‘단조 시퀀스’는 ‘안전성(safety)’ 속성이고, ‘가용성’은 ‘활성(liveness)’ 속성입니다. <br>
안전성은 비공식적으로 “나쁜 일이 일어나지 않는다”로, 활성은 “좋은 일이 결국 일어난다”로 정의하곤 합니다.
