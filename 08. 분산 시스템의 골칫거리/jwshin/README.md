# 8장. 분산시스템의 골칫거리

## 1. 서론 - 불완전함 속에서의 신뢰성

- 실제 세계에서 시스템이 실패하는 이유는 다양하다.
- 네트워크 장애, 하드웨어 고장, GC 일시 정지, 시계 불일치 등은 모두 현실적이며 피할 수 없다.
- 따라서, 분산 시스템을 설계할 때는 **완벽을 목표로 하기보다 실패를 전제로 하는 태도**가 필요하다.
- 저자는 이를 “*비관주의를 최대한으로 끌어올려라*”라고 표현한다.

## 2. 결함과 부분 장애 (Partial Failure)

- 단일 머신 내부에서는 대부분의 구성요소가 함께 작동하므로, 장애는 전체 중단으로 명확히 드러난다.
- 그러나 분산 시스템에서는 일부 노드만 실패해도 전체는 부분적으로 계속 작동할 수 있다. 이것이 **부분 장애(partial failure)** 다.
    - 예시: 웹 애플리케이션 서버 여러 대 중 하나가 다운되어도 나머지는 정상 동작한다. 하지만 다운된 서버에 요청이 라우팅된다면 일부 요청은 실패한다.
- 부분 실패는 **예측 불가능하며, 재현하기 어렵고, 디버깅이 힘들다.** 그 이유는 시스템이 네트워크, CPU, 디스크 등 서로 다른 자원에 의존하기 때문이다.
- 결국 분산 시스템은 **항상 무언가가 부분적으로 고장 나 있는 상태**라고 가정하는게 합리적이다.

## 3. 신뢰성 없는 네트워크

### 3.1 비동기 패킷 네트워크

- 인터넷과 대부분의 데이터센터 네트워크는 **비동기 패킷 네트워크(asynchronous packet network)** 이다.
- 이 환경에서는 송신자가 메시지를 보냈다고 해서 수신자가 반드시 받는다는 보장이 없다.
- 가능한 문제들
1. 요청이 손실될 수 있다.
2. 요청이 중복될 수 있다.
3. 순서가 바뀔 수 있다.
4. 요청이 지연되거나 너무 늦게 도착할 수 있다.
5. 요청을 처리했지만 응답이 지연되다가 나중에 전송될 수 있다.
- 요청이 손실되었는지, 혹은 단순히 늦게 도착한 것인지 구분할 방법이 없기 때문에 **“전송 실패인가, 지연인가?”** 는 영원한 미스터리로 남는다.
- 이런 문제를 다루는 흔한 방법은 **타임 아웃**이다. But, 지연이 풀리고 전송 측은 요청을 포기했더라도 메시지가 수신 측에 도착할 수도 있다.

<img width="803" height="218" alt="image" src="https://github.com/user-attachments/assets/4072c4c0-4c90-4cf2-b83c-67c0a9fecd9b" />

### 3.2 현실의 네트워크 결함

- 데이터센터 내부조차 완벽하지 않다.
- 한 연구에서는 12개월 동안 **네트워크 결함이 매달 평균 12번** 발생했다고 보고했다.
- 이 결함들은 대부분 스위치, 라우터, 케이블 등 하드웨어 문제였다.
- 대규모 클라우드 환경에서는 이런 장애가 빈번하며, **네트워크는 절대 신뢰할 수 없다는 사실**을 명심해야 하며 소프트웨어가 이를 처리할 수 있어야 한다.

## 4. 네트워크 분단 (Network Partition

- **네트워크 분단(network partition)** 은 일부 노드 집합이 서로 통신할 수 없게 되는 상황이다.
- 이때 시스템은 두 가지 중 하나를 선택해야 한다. -> **CAP 정리**
1. **일관성을 유지**: 분단된 일부 요청을 거부하고, 데이터 모순을 막는다.
2. **가용성을 유지**: 분단 중에도 요청을 처리하지만, 데이터 불일치 가능성을 감수한다.
- 분산 시스템은 네트워크 분단을 **감내(tolerate)** 해야 하며, 그 과정에서 무언가를 반드시 포기해야 한다.
- 사례: 넷플릭스의 카오스몽키(Chaos Monkey)는 일부 서버를 무작위로 끄는 실험을 통해 시스템이 분단 상황에서도 견딜 수 있는지 테스트한다.

## 5. 타임아웃과 지연의 모호함

- 분산 시스템에서 가장 까다로운 문제는 **응답이 늦을 때의 판단**이다.
- 응답이 단순히 지연된 것인지, 실패했는지 알 수 없다.
- 그래서 타임아웃을 설정하지만, “적절한 타임아웃”이라는 것은 존재하지 않는다.
    - 너무 짧으면 정상 요청이 실패로 오판된다.
    - 너무 길면 장애 복구가 지연된다.
- 그래서, 성급하게 노드가 죽었다고 선언하면 문제가 된다.

## 6. 신뢰성 없는 시계

### 6.1 물리 시계와 논리 시계

- 각 노드는 자체 시계를 가지며, 이 시계는 NTP를 통해 동기화되지만 항상 일정 오차(수백 밀리초)가 존재한다.
- 그 결과, “A 이벤트가 B보다 먼저인가?”라는 질문에 명확히 답하기 어렵다. (순서 판단 어려움)
- 이를 해결하기 위해 **논리적 시계(Logical Clock)** 가 도입된다.
- **램포트 타임스탬프(Lamport Timestamp)**: 인과 관계를 반영하지만 시간 차이는 알 수 없음.
- **벡터 클록(Vector Clock)**: 병렬적 사건의 순서를 추적 가능하지만 오버헤드가 큼.

### **6.2 시계 오차의 위험**

- 현실의 NTP는 패킷 손실, 지연 등으로 인해 오차가 누적될 수 있다.
- 일부 서버의 시계가 느려지면, “마지막 쓰기 승리(LWW)” 정책에서 데이터 손실이 발생한다.
- 예를 들어, 시계가 뒤처진 서버가 더 오래된 값을 “최신”으로 잘못 판단해 덮어쓸 수 있다.

<img width="719" height="331" alt="image" src="https://github.com/user-attachments/assets/b6e1abba-bbee-4adf-a7f0-da59fd02955f" />

## 7. 프로세스 중단과 스톱-더-월드 (Stop-the-world)

### 7.1 GC, 디스크, 커널 스케줄링

- 자바나 JVM 기반 환경에서 **가비지 컬렉션(GC)**, 디스크 I/O, 스레드 스위칭은 수 밀리초~수 초간 프로세스를 완전히 멈춘다.
- 이 중단 동안 네트워크 응답은 멈추며, 다른 노드들은 해당 노드가 “죽었다”고 판단한다.
- 이것이 **잘못된 장애 감지(false failure)** 의 주된 원인이다.
- 예시: 한 노드가 GC 중이라 응답이 늦었는데, 다른 노드가 새 리더로 선출됨 → 깨어난 노드는 자신이 여전히 리더라 착각하고 데이터 충돌 발생. → 이 문제를 막기 위해 **펜싱 토큰(Fencing Token)** 을 사용한다.

## 8. 응답 시간 보장과 실시간 제약

- 일부 시스템(항공, 의료, 로봇 등)은 시간 제약을 어기면 치명적이다.
- 이런 시스템을 **엄격한 실시간 시스템(hard real-time)** 이라 한다.
- 반면 대부분의 분산 시스템은 **소프트 실시간(soft real-time)** 또는 비실시간 환경이다.
- 분산 환경에서는 GC, 네트워크 혼잡, 스케줄러 지연 때문에 정확한 시간 보장이 사실상 불가능하다.
- 따라서 “항상 일정 시간 내 응답”을 보장하려는 시도는 현실적으로 불가능하다.

## 9. 지식, 진실, 그리고 거짓말

- 분산 시스템에서는 “진실”이 하나가 아니다.
- 각 노드는 자신이 본 세상만 알고 있으며, 전체 상태를 완전히 알 수 없다.
- 따라서 **진실은 다수결(quorum)로 결정**된다.
- 예시:
    - “노드 A가 죽었는가?”
    - → 세 개 노드 중 둘 이상이 “그렇다”고 응답하면 죽은 것으로 간주.
    - 그러나 네트워크 분단 시, 서로 다른 그룹이 상반된 판단을 내릴 수도 있다.
- 이처럼 분산 시스템에서는 **진실이 상대적이며, 항상 추정의 결과**이다.
- 따라서 “확정적 사실”이 아닌 “대다수의 합의(consensus)”가 신뢰의 근간이 된다.

## 10. 리더, 잠금, 그리고 펜싱 토큰

- 리더 선출은 필수적이지만, GC나 네트워크 지연으로 인해 이전 리더가 “죽은 척”을 할 수 있다.
- 이때 새 리더가 선출되고, 이전 리더가 나중에 복귀하면 두 리더가 동시에 존재하게 된다. (스플릿 브레인)

<img width="744" height="265" alt="image" src="https://github.com/user-attachments/assets/0b70f8a1-10be-445f-9cdd-df4412973317" />

- 이를 방지하기 위해 사용하는 방법이 **펜싱 토큰(Fencing Token)** 이다.
- 리더가 선출될 때마다 증가하는 고유한 번호(토큰)를 발급.
- 모든 쓰기 요청은 해당 토큰을 포함해야 유효.
- 이전 리더가 복귀해도 오래된 토큰이므로 거부됨.

<img width="573" height="266" alt="image" src="https://github.com/user-attachments/assets/9a06225b-1530-4b69-b8e4-b1467e93e7cf" />

- 그림 8-5: 리더가 중복 선출되는 상황을 펜싱 토큰으로 방지하는 예.

## 11. 비잔틴 결함 (Byzantine Fault)

- 지금까지의 장애는 비의도적 오류였다면, **비잔틴 결함**은 의도적인 악의적 행동을 의미한다.
- 예를 들어, 노드가 거짓 데이터를 전송하거나, 프로토콜을 고의로 위반하는 경우다.
- 신뢰할 수 없는 환경에서 합의에 도달하는 문제를 **비잔틴 장군 문제(Byzantine Generals Problem)** 라고 한다.
    - 노드들이 서로 신뢰할 수 없을 때 합의에 도달할 수 있는가?
    - 일부가 악의적이라면 어떻게 대응할 것인가?
- 이를 해결하는 **비잔틴 내결함성(Byzantine Fault Tolerance, BFT)** 알고리즘이 존재하지만, 매우 비싸고 복잡하기 때문에 대부분의 상용 시스템은 **단순 크래시 내결함성**까지만 지원한다.

## 12. 시스템 모델 (System Model)

- 분산 시스템의 행동을 이해하기 위해 여러 결함 모델(failure model)이 사용된다.
- 대부분의 분산 알고리즘은 “부분 동기”와 “죽으면 복구 모델”을 가정한다.

| **모델** | **설명** |
| --- | --- |
| **동기 시스템** | 모든 메시지 지연(네트워크 지연, 프로세스 중단)에 상한이 있고, 시계가 동기화됨. (현실엔 없음) |
| **부분 동기 시스템** | 대부분의 상황에서는 동기적이지만, 일시적으로 비동기 상태 가능. (현실적 모델) |
| **비동기 시스템** | 지연에 상한이 없고, 시계 불일치 허용. (인터넷 현실) |

| **모델** | **설명** |
| --- | --- |
| **죽으면 중단(crash-stop)** | 노드가 한 번 장애 나면 영구적으로 멈추고 다시 돌아오지 않는다고 가정. |
| **죽으면 복구(crash-recovery)** | 노드가 장애 후 재시작할 수 있음. 메모리는 잃을 수 있으나 디스크 같은 안정 저장소는 보존된다고 가정. |
| **비잔틴(Byzantine)** | 노드가 거짓말·프로토콜 위반 등 임의/악의적 행동을 할 수 있다고 가정(신뢰 불가). |

## 13. 알고리즘의 정합성과 안전성

- 분산 알고리즘은 두 가지 속성을 만족해야 한다.
1. **안전성(Safety)**: 잘못된 일이 절대 발생하지 않는다. (예: 두 리더 존재 불가)
2. **활동성(Liveness)**: 언젠가(eventually) 좋은 일이 일어난다. (예: 리더는 반드시 선출된다). 최종적 일관성(eventual consistency)은 활동성 속성이다.
- 하지만 네트워크 분단이나 지연이 있을 때, 이 둘을 동시에 보장할 수 없다.
- 대부분의 시스템은 **안전성 우선** 원칙을 택한다. (잘못된 상태로 가용성을 높이기보다, 잠시 멈추더라도 일관성을 유지한다.)

## 14. 정리

- **네트워크는 신뢰할 수 없다.** 요청이 손실, 중복, 지연, 재전송될 수 있다.
- **시계는 불완전하다.** NTP 동기화에도 불구하고 오차는 존재하며, 시간 순서 판단은 모호하다.
- **프로세스는 언제든 멈출 수 있다.** GC, 디스크 I/O, 스케줄링 등은 일시적 중단을 유발한다.
- **진실은 하나가 아니다.** 각 노드는 부분 정보만 가지고 있고, 합의는 근사치다.
- **부분 장애는 피할 수 없다.** 따라서 시스템은 항상 고장나 있는 상태에서도 안정적으로 동작해야 한다.
