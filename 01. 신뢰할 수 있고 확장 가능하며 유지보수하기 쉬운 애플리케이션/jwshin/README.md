# 1장 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

- 현대 애플리케이션은 크게 계산 중심(compute-intensive) 과 데이터 중심(data-intensive) 으로 나뉜다.
- 데이터 중심 애플리케이션의 핵심은 방대한 양의 데이터, 데이터의 복잡도, 변화 속도를 효율적으로 다루는 것이다.
- 이를 위해 대부분의 애플리케이션은 공통적으로 다음과 같은 표준 구성 요소를 필요로 한다:
  - 데이터 저장소(데이터베이스)
  - 캐시
  - 검색 색인
  - 스트림 처리
  - 배치 처리

## 데이터 시스템에 대한 생각

- 데이터베이스, 큐, 캐시 등은 전통적으로 별도의 범주로 구분되었으나, 실제로는 경계가 흐려지고 있다.
-	새로운 도구(예: Redis, Kafka)는 전통적 분류에 속하지 않고 다양한 활용 사례에 맞게 사용된다.
-	애플리케이션은 단일 도구로 모든 요구사항을 충족하기 어렵기 때문에 여러 도구를 결합해 사용한다.
- 예: 데이터베이스 + 캐시(Memcached), 검색 서버(Elasticsearch, Solr), 메시지 큐 등.

<img width="705" height="521" alt="image" src="https://github.com/user-attachments/assets/647f2c25-ac2e-4ee7-81f6-37c0391b751e" />

## 시스템 설계의 세 가지 핵심 관심사

-	신뢰성 (Reliability): 시스템이 올바르게 동작하며, 하드웨어/소프트웨어 오류나 인간의 실수에도 견딜 수 있어야 한다.
-	확장성 (Scalability): 데이터 양과 트래픽 증가에도 성능 저하 없이 처리할 수 있는 능력.
-	유지보수성 (Maintainability): 시간이 지나도 여러 사람이 시스템을 이해하고 효율적으로 운영 및 확장할 수 있어야 한다.

## 신뢰성 (Reliability)

- 신뢰성이란 “무언가 잘못되더라도 올바르게 동작할 수 있음” 을 의미한다.
-	애플리케이션이 사용자 요구 기능을 수행한다.
- 시스템이 예측하지 못한 오류 상황에서도 동작한다.
- 허가되지 않은 접근과 오남용을 방지한다.

### 신뢰성 관련 주요 개념

-	결함(Fault): 잘못될 수 있는 일.
-	장애(Failure): 결함이 실제로 발생하여 시스템 전체 동작이 멈추는 것.
-	내결함성(Fault-tolerance), 탄력성(Resilience): 결함이 있어도 시스템이 계속 동작할 수 있는 능력.

### 결함의 원인

- 하드웨어 결함: 디스크 고장, 램 오류, 네트워크 케이블 문제 등. 평균 장애 시간(MTTF)은 10~50년이지만 대규모 시스템에서는 매일 발생할 수 있음.
- 소프트웨어 오류: 시스템적 버그, 리눅스 커널 오류, 메모리 누수 등. 예) 잘못된 요청을 반복적으로 반환하는 서비스, 연쇄 장애(cascading failure).
- 인적 오류: 잘못된 설정, 운영 실수, 보안 허점 등. 예방책) 안전한 인터페이스 설계, 테스트 자동화, 모니터링, 롤백 절차, 샌드박스 환경 제공.

## 확장성 (Scalability)

-	성능 저하의 주요 원인은 부하 증가(load growth).
-	동시 사용자 수, 데이터 처리량, 요청 수가 급격히 늘어날 수 있음.
-	확장성은 단순히 “있다/없다”가 아니라, 부하 증가에 어떻게 대응할 수 있는가를 의미한다.
-	질문: “특정 부하가 커졌을 때 어떤 선택을 할 것인가?”, “추가 자원을 얼마나 투입해야 하는가?”

## 부하 기술하기

- 부하를 나타내는 부하 매개변수(load parameter) 예시:
	-	초당 요청 수
	-	데이터베이스 읽기/쓰기 비율
	-	활성 사용자 수(active user)
	-	캐시 적중률
-	평균 수치뿐 아니라 피크(peak) 상황도 중요하다.

### 트위터 사례 (2012년 공개 데이터 기준)

- 주요 동작
  - 트윗 작성 (초당 수천 건)
  - 홈 타임라인 표시 (초당 30만 건 이상)
- 문제
  - 트윗 작성 자체는 간단하나, 팔로워에게 전파하는 fan-out 부하가 크다.
  - 특정 사용자가 수백만 팔로워를 가질 경우, 단일 트윗이 엄청난 부하로 이어짐.
- 접근 방식
  - 접근 방식 1: 요청 시 모든 팔로워의 타임라인을 실시간 계산. → 읽기 부하 증가.
  - 접근 방식 2: 트윗 작성 시 각 팔로워 타임라인에 삽입. → 쓰기 부하 증가.
  - 트위터는 두 방식을 혼합(hybrid) 하여 사용.

## 성능 기술하기

- 부하 증가에 따라 성능이 어떻게 변하는지 살펴봐야 한다.
- 두 가지 주요 질문
  - 부하 매개변수를 늘렸을 때 시스템 성능(CPU, 메모리 등 자원 고정 시)은 어떻게 변하는가?
  - 원하는 성능을 유지하려면 자원을 얼마나 추가해야 하는가?
 
### 성능 지표

-	처리량(Throughput): 단위 시간당 처리 가능한 작업 수.
- 응답 시간(Response time): 요청~응답 사이의 시간.
- 온라인 서비스에서는 응답 시간이 특히 중요.

### 지연 시간과 응답 시간

-	지연 시간(latency): 요청이 처리되기까지 대기하는 시간.
- 응답 시간(response time): 실제 처리 시간 + 네트워크 지연, 큐 대기 시간 등 포함.
- 응답 시간은 항상 동일하지 않고 분포(distribution) 로 나타나며, 특이값(outlier)이 존재한다.

### 응답 시간 측정

-	단순 평균값은 부적절.
-	일반적으로 백분위(percentile) 를 사용:
-	p95, p99, p999 → 전체 요청 중 상위 5%, 1%, 0.1%의 느린 응답 시간을 의미.
-	꼬리 지연 시간(tail latency)은 사용자 경험에 큰 영향을 미침. 예) 아마존은 응답 시간이 100ms 늘어날 때 매출이 1% 감소하는 현상을 관찰.

<img width="691" height="246" alt="image" src="https://github.com/user-attachments/assets/455b9f9f-069b-40d3-9449-d256ebc37722" />


### 꼬리 지연 시간(Tail Latency)

-	서비스 품질에 직접적인 영향을 주는 중요한 지표.
- 최상위 백분위(예: p99.99)를 줄이는 것은 매우 비용이 크고 어려움.
- 대신 서비스 수준 목표(SLO) 와 서비스 수준 협약(SLA) 을 통해 현실적인 기준을 정의.
- 예: “응답 시간 중앙값 200ms 이하, p99 < 1초, 가용성 99.9% 이상”.

## 부하 대응 접근 방식

- 확장을 위한 두 가지 방법
  - 수직 확장(Vertical scaling, Scale up): 더 강력한 하드웨어 사용. 단일 노드에 의존하므로 한계가 명확함.
  - 수평 확장(Horizontal scaling, Scale out): 많은 저비용 장비로 부하를 분산. 분산 시스템, 공유 없음(shared-nothing) 아키텍처. 실용적으로 가장 널리 사용됨.
 
### 탄력성 (Elasticity)

-	자동으로 자원을 늘리거나 줄이는 기능.
- 예: 클라우드 환경의 자동 확장(auto-scaling).
- 하지만 모든 시스템이 탄력적으로 확장할 수 있는 것은 아님.

## 확장성 아키텍처의 특징

- Stateless 서비스는 확장하기 쉽다.
-	Stateful 서비스의 확장은 복잡하고 비용이 큼.
- 애플리케이션별로 요구사항과 부하 특성에 따라 적절한 아키텍처 선택 필요.
- 범용적인 “완벽한 확장 소스”는 존재하지 않음.
- 아키텍처 설계 시 고려할 요소: 데이터 양, 복잡도, 응답 시간, 접근 패턴, 예상 부하 조합 등

## 유지보수성 (Maintainability)

- 유지보수 범위: 버그 수정, 시스템 운영 유지, 장애 조사, 새로운 플랫폼 적용, 기술 부채(technical debt) 해소, 새로운 기능 추가
- 소프트웨어 설계 원칙: 유지보수성을 위해 지켜야 할 세 가지 원칙은 운용성, 단순성, 발전성

### 운용성(Operability)

- 시스템이 원활하게 운영될 수 있도록 설계.
- 예: 장애 복구, 문제 추적, 보안 패치 유지, 설정 관리 자동화.
- 시스템 상태 모니터링 및 빠른 복구, 성능 저하 원인 추적, 최신 소프트웨어/플랫폼 유지, 변경 영향 분석 및 사전 차단, 미래 문제 예측 및 대비, 배포/설정 관리 자동화, 플랫폼 마이그레이션 지원, 안정적 서비스 환경 유지, 조직 내 지식 보존

### 단순성(Simplicity)

- 불필요한 복잡성 제거.
- 복잡한 시스템은 이해하기 어렵고 유지보수 비용이 높음.
- 목표: “빅볼 오브 머드(Big Ball of Mud)” 상태를 피하고 단순한 구조 유지.
- 우발적 복잡성(accidental complexity)을 줄이기 위해 추상화(abstraction) 적극 활용.
- 복잡성 증가 요인:	강한 결합(tight coupling), 불명확한 네이밍, 중복 코드, 특수 사례 처리(special-casing)
- 해결 방법: 복잡도를 줄이기 위한 추상화, 재사용 가능한 단순한 구성 요소 활용, 표준화된 도구와 명확한 모델 사용
	
### 발전성(Evolvability)

- 엔지니어가 쉽게 시스템을 변경할 수 있어야 함.
- 요구사항 변경, 새로운 기능 추가, 플랫폼 교체 등에 유연하게 대응.
-	관련 개념: 확장성(extensibility), 수정 가능성(modifiability), 적응성(plasticity).
-	변화에 대응하는 방법: 애자일(Agile) 접근법, 테스트 주도 개발(TDD), 리팩토링(Refactoring)

## 1장 정리

- 신뢰성: 시스템이 결함에도 불구하고 올바르게 동작할 수 있는 능력.
- 확장성: 부하 증가에도 좋은 성능을 유지할 수 있는 전략.
- 유지보수성: 시스템을 쉽게 운영, 단순화, 변경할 수 있는 특성.
- 이 세 가지는 데이터 중심 애플리케이션 설계의 핵심 축이며, 이후 장에서는 이를 뒷받침하는 구체적 기술과 패턴을 다룬다.
