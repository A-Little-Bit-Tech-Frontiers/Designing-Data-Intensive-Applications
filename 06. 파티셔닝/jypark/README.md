# 6장 파티션

## 서론

- 데이터 셋이 너무 크거나 필요 처리량 높다면 복제만으로 커버가 힘듦
- 데이터를 파티션으로 쪼갤 필요가 있는데 이를 샤딩 이라고 함
- 파티셔닝을 하는 주 목적 → **확장성**
- 단일 파티션 기준 각 노드를 추가함으로 인해 처리량을 늘릴 수 있음
    - 크고 복잡한 경우 여러 노드에서 병렬 실행

## 파티셔닝과 복제

- 일반적으로 복제와 파티셔닝을 함께 적용함
    - 각 파티션의 복사본을 여러 노드에 저장
    - → 내결함성 보장
    - 한 노드에 여러 파티션 저장도 가능

### 리더 팔로워 복제 모델

![스크린샷 2025-09-23 오후 3.11.13.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.11.13.png)

- 파티션 리더는 하나의 노드에 할당되고, 팔로워들은 다른 노드에 할당됨

## 키-값 데이터 파티셔닝

- 파티셔닝의 목적 → 데이터와 질의 **부하 분산**
- **skewed**
    - 파티셔닝이 고르게 이뤄지지 않아 데이터가 많거나 질의를 많은 파티션이 있는 경우
    - 쏠렸다 라고 표현함
- **핫스팟**
    - 극단적인 케이스
    - 모든 부하가 하나의 노드에 몰려 불균형하게 부하가 높은 파티션
- 핫스팟을 피하는 가장 단순한 방법
    - 레코드를 무작위 노드에 할당한다
    - 조회시 병렬 모든 노드에 병렬 적으로 질의해야 한다 (어느 노드에 할당된지 모름)
- **키 범위 기준 파티셔닝**
    - 백과사전 처럼 각 파티션에 **연속된 범위의 키 할당**
    - 키 범위 크기가 반드시 동일할 필요는 없음
    - 이런 전략은 빅테이블, HBase, 리싱크 DB, 2.4 이전 몽고DB 에서 사용
    - 시간 기준 인 경우 범위 스캔이 유용하지만, **키 범위 기준은 특정 접근 패턴이 핫스팟**을 유발

![스크린샷 2025-09-23 오후 3.17.12.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.17.12.png)

- **키 해시 기준 파티셔닝**
    - **쏠림과 핫스팟 방지**를 위해 해시 함수 사용
    - 파티셔닝용 해시 함수는 암호적으로 강력할 필요는 없음
        - 카산드라, 몽고는 MD5, 볼드모트는 파울러 놀보 함수 사용
    - 키를 파티션 사이에 균일하게 분산할 수 있다
        - 이를 **일관성 해싱** 이라고 함
        - CDN 같은 대규모 캐시 시스템에서 부하를 균등하게 분산시키는 방법
    - 범위 질의에서 얻는 이점을 잃어버림
    - **카산드라의 파티셔닝 전략**
        - 여러 칼럼을 포함하는 복합 기본키 지정
        - **키의 첫 부분에만 해싱을 해, 파티션을 결정**하고 나머지는 SS 테이블 데이터 정렬에 사용

![스크린샷 2025-09-23 오후 3.28.10.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.28.10.png)

- **쏠린 작업부하와 핫스팟 완화**
    - 대부분 애플리케이션에서 쏠림을 완화해야함
    - 요청이 매우 쏠리는 키를 발견했을 경우 각 키의 시작/끝에 임의의 숫자를 붙이는 것
    - 한 키에 대한 작업이 여러 키로 균등하게 분산 (파티션 분산)
    - 쪼개서 쓰기 때문에 읽기 시에도 추가 작업이 필요하다
    - 요청이 몰리는 소수의 키에만 적용하는게 좋음

## 파티셔닝과 보조 색인

- 보조색인 → 레코드 유일 식별이 아닌 검색 수단
    - 관계형 데이터베이스의 핵심
    - 파티션에 깔끔하게 대응되지 않는 문제점
- **보조색인 파티셔닝 방법 두가지**
    - 문서 기반 파티셔닝
    - 용어 기반 파티셔닝

### 문서 기반 파티셔닝

- 차를 검색할때 색상/제조사로 필터할 수 있게 하려면 color, make 필드에 대해 보조 색인이 필요

![스크린샷 2025-09-23 오후 3.53.59.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.53.59.png)

- 빨간색 자동차가 추가되면, color:red 항목에 문서 ID 를 추가한다
- 각 파티션은 자신의 보조 색인을 유지하며, 파티션에 속하는 문서만 담당
    - 이 방식은 각 파티션이 완전히 독립적으로 동작
- 문서 파티셔닝 색인은 **지역 색인 (local index)** 라고 함
- **스캐터/개더**
    - scatter/gather
    - 여러 파티션에 대해 질의 를 보내는 방법
    - 꼬리 지연 시간 증폭이 발생하기 쉬움

### 용어 기반 파티셔닝

![스크린샷 2025-09-23 오후 3.57.34.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.57.34.png)

- 모든 파티션의 데이터를 담당하는 전역 색인
- a-r 로 시작하는 색인 파티션0, s-z 로 시작하는 색인 파티션은 1
- 용어 자체를 쓸수도 있고, 해시 값을 사용할 수도 있다
- 문서 파티셔닝에 비해 읽기가 효율적
    - 쓰기가 느려짐
    - 비동기 색인

## 파티션 재균형화

- 클러스터에서 한 노드가 담당하는 부하를 다른 노드로 옮기는 과정
- **최소 요구사항**
    - 재균형화 후, 부하（데이터 저장소. 읽기 쓰기 요청）가 클러스터 내에 있는 노드들 사이에 균등하게 분배돼야 한다.
    - 재균형화 도중에도 데이터베이스는 읽기 쓰기 요청을 받아들여야 한다.
    - 재균형화가 빨리 실행되고 네트워크와 디스크 I/O 부하를 최소화할 수 있도록 노드들 사이에 데이터가 필요 이상으로 옮겨져서는 안된다.

### 재균형화 전략

- **해시값에 모드 N 연산 수행**
    - 노드의 개수 N 기 변경되면 대부분의 키가 옮겨져야 함
- **파티션 개수 고정**
    - 파티션을 노드 대수보다 많이 만들고, 각 노드에 여러 파티션  할당
    - 파티션은 노드 사이에서 통째로 이동하기만 한다
- **동적 파티셔닝**
    - 파티션 크기가 설정된 값을 넘으면 파티션을 두 개로 쪼갠다
    - 크기가 임계값 아래로 떨어지면 파티션을 합친다
    - 파티션 개수가 전체 데이터 용량에 비례해 조정된다
    - 키 범위 / 해시 에 동일하게 사용됨
- **노드 비례 파티셔닝**
    - 파티션 개수가 노드 대수에 비례
    - 데이터가 많을수록 노드도 많이 필요하고, 파티션 크기도 안정적으로 유지됨

### 자동 재균형화와 수동 재균형화

- 완전 자동 재균형화는 유지보수에 손이 덜가 편리하지만 예측하기 어려움
    - 서비스 중인 시스템에서 심각하면 장애 상황으로 이어질 수도 있음
- 재균형화 과정에는 사람이 개입하는게 좋음
    - 완전 자동화 보다는 느리지만, 예기치 못한 일을 방지

## 요청 라우팅

- 여러 노드에 파티셔닝 되어있을 경우, 어느 노드로 접속 해야 하는지 알 방법이 없다
    - 재균형화 이후라면 노드에 할당된 파티션이 변경될 수 있음
- **핵심 문제**
    - 라우팅 결정을 내리는 구성 요소가 노드에 할당된 파티션 변경을 감지하는 방법
- 대부분의 경우 메타데이터 추적을 위해 주키퍼 같은 코디네이터를 사용

![스크린샷 2025-09-23 오후 4.24.38.png](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-09-23_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.24.38.png)

- HBase, 솔라클라우드, 카프카
- 몽고 DB 는 mongos 데몬을 라우팅 계층으로 사용
- 카산드라 / 리악 → **가십 프로토콜**로 상태 변화를 전파함
- 카우치베이스 → 목시 (moxi) 라우팅 계층 설정

### 병렬 질의 실행

- 데이터 분석용으로 자주 사용되는 대규모 병렬 처리 (MPP) 관계형 데ㅣ터베이스는 복잡한 종류의 질의를 지원
- MPP 질의 최적화기는 복잡한 질의를 여러 단계와 파티션으로 분해하여, 클러스터 내의 서로 다른 노드에서 병렬적으로 실행될 수 있다

## 정리

- 파티셔닝의 목적 → 핫스팟 발생 방지 및 질의 부하를 균일하게 분배하는 것
- 주요 파티셔닝 기법
    - 키 범위 파티셔닝
        - 정렬된 키로 파티션
        - 범위 질의가 효과적
    - 해시 파티셔닝
        - 각 키에 해시 함수 적용값으로 파티션
        - 범위 질의가 비효율적
        - 부하가 균일하게 분산
    - 키의 일부를 파티션 식별용, 나머지를 정렬용으로 만든 복합키 파티셔닝도 가능함
        - 위 두 방법을 섞은 방법
- 보조 색인 파티셔닝 기법
    - 문서 파티셔닝
        - 지역 색인
        - 보조 색인을 기본 키와 저장된 파티션에 저장
        - 파티션 하나만 갱신 하지만 조회시 모든 파티션에 걸쳐 실행되어야 함
    - 용어 파티셔닝
        - 전역 색인
        - 색인된 값으로 보조 색인을 별도 파티셔닝
        - 전역에 걸쳐 갱신하지만, 단일 파티션에서 조회가 수행됨
