데이터 파티셔닝을 하는 주된 이유는 확장성이다. **비공유 클러스터(shared-nothing cluster)**에서 다른 파티션은 다른 노드에 저장될 수 있다. ⇒ 따라서 대용량 데이터셋이 여러 디스크에 분산될 수 있고 질의 부하는 여러 프로세서에 분산될 수 있다.

# 1. 파티셔닝과 복제

보통 복제와 파티셔닝을 함께 적용해 **각 파티션의 복사본을 여러 노드에 저장**한다.

한 노드에 여러 파티션을 저장할 수도 있다. 리더-팔로워 복제 모델을 사용한다면 파티셔닝과 복제의 조합은 아래와 같은 형태가 된다. → 각 파티션의 리더는 하나의 노드에 할당되고, 팔로워들은 다른 노드에 할당되는 형식이다.

<img width="578" height="302" alt="image" src="https://github.com/user-attachments/assets/db3da550-7202-43ae-ba41-cea685aa60f1" />


→ 복제와 파티셔닝의 조합: 각 노드는 어떤 파티션에게는 리더로, 어떤 파티션에게는 팔로워로 동작한다.

# 2. 키-값 데이터 파티셔닝

**파티셔닝의 목적**은 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것이다. 만약, 특정 파티션에 데이터가 몰리거나 질의가 많아 쏠림현상이 일어날 수 있는데, 당연히 이런 경우에 파티셔닝 효과가 매우 떨어진다. ⇒ **이런 파티션은 핫스팟이라고 부름.**

핫스팟 회피 방법 중 가장 단순한 것은 무작위로 레코드 할당 노드를 선택하는 것이다. 하지만, 데이터 질의 시에 모든 노드에서 병렬적으로 조회해야 하는 큰 단점이 존재함. ⇒ 이보다 좋은 방법 중 하나는 **키-값 데이터 모델을 사용한다고 가정**하는 것이다.

## 2.1 키 범위 기준 파티셔닝

각 파티션에 연속된 범위의 키를 할당하는 방법이다. 각 범위들 간의 경계를 알면, 어떤 키가 어느 파티션에 속해있는지 손쉽게 알 수 있다. 저장도 마찬가지.

데이터가 키 범위만큼 고르게 분포되지 않을 수 있으므로, 키 범위 크기가 동일할 필요가 전혀 없다.
(⇒ A~Z까지를 키로 가정한다면, A~B까지의 데이터 양과 B~Z까지 데이터 양이 비슷할 수도 있는 셈)

**키가 기준이 아니라 데이터의 양을 기준으로 파티션 경계를 잡아야 한다.**

키를 정렬된 순서로 저장하면 범위 스캔이 쉬워지는 이점이 있고, 키를 연쇄된 색인으로 간주해서 질의 하나로 관련 레코드 여러 개를 읽어오는 데 사용할 수도 있다.

→ 근데, 이런 키 범위 기준의 파티셔닝은 특정한 접근 패턴이 핫스팟을 유발할 수 있음. 예를 들어, 타임스탬프 등

## 2.2 키의 해시값 기준 파티셔닝

핫스팟의 위험 때문에 분산 저장소는 키의 파티션을 정하는 데 해시함수를 사용한다.
(좋은 해시 함수는 쏠린 데이터를 입력으로 받아 균일하게 분산되도록 한다.)

파티셔닝용 해시 함수는 암호적으로 강력할 필요는 없다.

- 카산드라, 몽고DB: MD5
- 볼드모트: 파울러 놀 보(Fowler-Noll-Vo)

<img width="517" height="187" alt="image" src="https://github.com/user-attachments/assets/29094bea-ceaf-46cf-81be-1173b5e4882b" />


키에 적합한 해시 함수를 구했다면 **각 파티션에** 키 범위 대신에 **해시값 범위를 할당**하고 해시값이 파티션의 범위에 속하는 모든 키를 그 파티션에 할당하면 된다. (위 예시에서는 32비트 해시 함수로 가정)

이 기법은 키를 파티션 사이에 균일하게 분산시키는 데 좋다. 파티션 경계는 크기가 동일하도록 나눌 수도 있고, 무작위에 가깝게 선택할 수도 있다.

그러나 이런 해시 파티셔닝 기법은 키 범위 파티셔닝의 장점을 잃어버린다. 정렬이 유지되지 않으므로 범위 기반의 질의에 더 이상 효율적이지 않다. → 몽고 DB에서는 해시 기반 샤딩 모드를 활성화 하면, 범의 질의가 모든 파티션에 전송되어야 한다고 함.

카산드라는 두 가지 파티셔닝 전략 사이에서 타협.

- 카산드라의 파티셔닝 전략
    
    테이블 선언 시 여러 칼럼을 포함하는 **복합 기본키**를 지정할 수 있다. 첫 번째 칼럼은 파티션 결정에 사용되며, 나머지 칼럼은 데이터를 정렬하는 **클러스터링 키** 역할을 한다.
    
    → 첫 번째 칼럼으로는 범위 검색이 불가능하지만, 이후 칼럼들에 대해서는 범위 스캔을 효율적으로 수행할 수 있다.
    
- ss테이블에서 데이터를 정렬하는 색인
    
    클러스터링 키를 사용하면 일대다 관계를 표현하는 **효율적인 데이터 모델**을 구성할 수 있다.
    
    예: 소셜 미디어에서 사용자가 여러 문서를 수정하는 경우, 기본키를 `(user_id, update_timestamp)`로 설정하면 특정 사용자가 수정한 문서를 **시간 순서대로 정렬**해서 조회 가능하다.
    
- 저장 구조
    
    한 사용자가 수정한 정보는 같은 파티션에 타임스탬프 순으로 저장된다.
    

## 2.3 쏠린 작업부하와 핫스팟 완화

위와 같이 한다 한들,, 동일한 키에 대한 i/o가 엄청나면 어차피 동일한 파티션으로 쏠리게 된다.

책에서는 아래와 같은 해결책과 그에 따른 단점을 제시함.

**해결책**: 애플리케이션 단에서 키에 **임의의 접미사/접두사**를 붙여 여러 파티션으로 분산.

**부작용**:

- 분산된 키를 다시 모아 읽으려면 추가 작업이 필요.
- 저장해야 할 메타데이터가 늘어남.
- 잘못 적용 시 오히려 불필요한 오버헤드 발생 가능.

결국, 현재는 애플리케이션에서 직접 트레이드오프를 고려해야 한다.

# 3. 파티셔닝과 보조 색인

보조 색인은 (기본키와 같이 레코드 식별용이 아닌) 보통 검색을 하기 위한 수단이다. 

보조 색인은 파티션에 깔끔하게 대응되지 않는 문제점이 있다. 보조 색인이 있는 데이터베이스를 파티셔닝하는 데 널리 쓰이는 방법이 두 가지 존재함.

- 문서 기반 파티셔닝
- 용어 기반 파티셔닝

## 3.1 문서 기준 보조 색인 파티셔닝

아래 중고차 예시 참고

<img width="629" height="302" alt="image" src="https://github.com/user-attachments/assets/4e1945fe-74b7-493c-90ba-f985bfea8394" />


- 각 항목에는 **문서(Document) ID**라고 부르는 고유 ID가 있고 **데이터베이스를 문서 ID 기준으로 파티셔닝**한다. 
(0~499 → 0, 500 ~ 999 → 1)
- 차를 검색할 때, 색상과 제조사를 기준으로 필터링하기 위해, `color`와 `make`에 보조 색인르 추가함.
    
    예를 들어, 빨간색 자동차가 데이터베이스에 추가되면 **파티션은 자동으로 color:make 색인 항목에 해당하는 문서 ID 목록에 추가함.**
    

문제는 각 파티션은 자기들이 가지고 있는 문서만 담당해 보조 색인을 유지한다. 다른 파티션 데이터는 알 바가 아니라는 뜻.

⇒ 이러한 특성 때문에 **문서 파티셔닝 색인은 지역 색인(local index)이라고도 한다.**

때문에, 빨간색 자동차를 찾고 싶다면 모든 파티션에 질의를 보내서 얻은 결과를 조합해야 한다.

⇒ **파티셔닝된 데이터베이스에 이런 식으로 질의를 보내는 방법을 scatter/gather** 라고 한다

이 방식에서 보조 색인을 써서 읽는 질의는 큰 비용이 들 수 있다고 한다.

⇒ 병렬 실행으로 인해 지연과 비용이 커질 수 있음.
⇒ 때문에, 보통 벤더사에선 보조 색인 질의가 **단일 파티션 내에서만 수행되도록 파티셔닝 설계**할 것을 권장한다고 한다.

결론)
파티션 키 기반으로 질의하는게 아닌, 분산되어 있는 데이터베이스에 특정 인덱스를 통해서 조회를 하다보니,,, 병렬 조회를 해야하는 상황 → 여기서 꼬리 지연 시간 증폭이 발생할 수 있는거임.

## 3.2 용어 기준 보조 색인 파티셔닝

<img width="626" height="265" alt="image" src="https://github.com/user-attachments/assets/100f7f47-ff48-41d0-81a9-1aa9f5b0c97f" />


이는 모든 파티션의 데이터를 담당하는 전역 색인(global index)로 만들 수 있다. 하지만 한 노드에만 색인을 저장하면 병목 지점이기 때문에, 모든 데이터를 기준으로 전역 색인도 파티셔닝을 해야 한다. (기본키 색인과는 별개로, 용어 기준으로)

위 그림을 기반으로 예시를 들면,

- 색깔 색인:  a~r → 파티션 0, s~z → 파티션 1
- 제조사 색인: a~f → 파티션 0, g~z → 파티션 1

**찾고자 하는 용어에 따라 색인의 파티션이 결정**되므로 **용어 기준으로 파티셔닝 됐다**고 한다. 여기서는 `color:red`가 용어의 예다.

용어를 색인으로 파티셔닝할 때에도 역시 용어의 해시값을 사용할 수 있다. 
용어 자체로 파티셔닝 하면 범위 스캔에 유리하고, 해시 값으로 파티셔닝하면 부하가 분산된다는 특징은 동일하다.

문서 파티셔닝에 비해 **용어 파티셔닝이 읽기가 효율**적이다.
⇒ 모든 파티션에 대해 scatter/gather 과정 없이, 찾고자 하는 용어의 파티션으로 요청을 보내면 되기 때문이다. 

하지만, 그에 비해 쓰기 성능은 더 느리고 복잡하다.
⇒ 단일 문서를 쓸 때, 여러 파티션에 영향을 줄 수 있기 때문이다.

**전역 보조 색인**은 이상적으로 항상 최신 상태여야 하지만, 분산 트랜잭션 한계 때문에 **현실에서는 비동기로 갱신**된다.
→ 즉 변경이 즉시 반영되지 않을 수 있으며, 다이나모DB 같은 시스템은 보통 1초 이내에 반영되지만 상황에 따라 지연이 길어질 수 있다.

# 4. 파티션 재균형화(Rebalancing)

시간이 지나면 데이터베이스에 변화가 생기기 마련임.

- 질의 처리량 증가 → CPU 추가
- 데이터셋 크기 증가 → 디스크와 램 추가
- 장비 장애 대비 → 다른 장비가 넘겨 받아야 함

이런 변화에 따른 데이터와 요청이 다른 노드로 옮겨져야 하는데, 이 과정을 **rebalancing**이라고 함.

재균형화 이후 아래 조건을 만족해야 함.

- 부하가 클러스터 내에 있는 노드들 사이에 균등하게 분배되어야 함.
- 재균형화 도중에도 데이터베이스는 읽기/쓰기 요청을 다 처리해야 함.
- 네트워크 및 디스크 i/o 부하를 최소화할 수 있도록 노드들 사이에 데이터가 필요 이상으로 옮겨져서는 안됨.

## 4.1 재균형화 전략

### 4.1.1 쓰면 안되는 방법: mod 연산으로 파티션 할당하기

`hash(key) % n` (n은 노드 개수)을 통해 나온 값으로 노드에 할당하면 간단하지만, 문제가 있다.

→ 노드 개수인 N이 바뀌면 같은 해시값이어도 결과가 달라지기 때문이다.

예시) hash(key) = 123456

- N == 10 → 노드 6에 할당
- N == 11 → 노드 3에 할당
- …

데이터를 필요 이상으로 이동시키는 방법이다.

### 4.1.2 파티션 개수 고정

<img width="589" height="327" alt="image" src="https://github.com/user-attachments/assets/68dc5e06-996b-47df-b3dd-c4b4b0cbcd77" />


노드에 여러 파티션을 미리 할당하면 쉽게 해결이 되긴 한다.

위 그림처럼, 클러스터에 노드가 추가되면 새 노드는 파티션이 다시 균일하게 분배될 때까지 기존 노드에서 파티션 몇 개를 뺏어온다. → 만약, 클러스터에 노드가 제거되면 반대로 수행.

이 방법은 파티션 개수도 바뀌지 않고, 파티션에 할당된 키도 변경되지 않는다. 

또한, 파티션 할당 변경은 즉시 반영되진 않는다.
→ 네트워크를 통해 대량의 데이터를 전송해야 하므로 시간이 걸림.
→ 따라서 데이터 전송이 진행중인 동안에 읽기/쓰기 요청은 기존에 할당된 파티션을 사용한다.

위 방식의 장점과 한계를 정리하면, 아래와 같음.

- **장점**: 관리가 단순하고, 처음 설정한 파티션 개수가 노드 증가에 대응할 수 있음.
- **한계**:
    - 파티션 개수가 고정되므로 이후 분할/병합이 불가능 → 미래 확장성을 고려해 충분히 큰 값으로 설정해야 함.
    - 파티션이 지나치게 많으면 관리 오버헤드 발생, 너무 적으면 부하 불균형 및 장애 복구 비용 커짐.
    - 데이터셋 크기가 변동이 크면 적절한 파티션 개수를 정하기 어려움.

### 4.1.3 동적 파티셔닝

- **개념**: 파티션의 크기가 일정 기준을 넘으면 자동으로 분할(split), 너무 작으면 병합(merge)하는 방식.
- **특징**: 데이터 양에 맞춰 파티션 개수가 자동 조절됨. → 데이터가 많아지면 파티션이 늘어나고, 적으면 줄어듦.
- **장점**: 관리가 자동화되어 유연함.
- **단점**:
    - 파티션 경계를 어디서 자를지 사전 지식이 필요. (초기 데이터가 작을 땐 한 파티션에 쏠림 현상 발생)
    - 그래서 HBase, 몽고DB 같은 시스템은 **사전 분할(pre-splitting)** 기능을 제공해 처음부터 여러 파티션으로 시작 가능.

### 4.1.4 노드 비례 파티셔닝

- **개념**: 파티션 개수를 노드 대수에 비례하게 설정하는 방식. (ex: 노드당 256개 파티션)
- **특징**:
    - 노드 수가 늘어나면 전체 파티션 수도 자동으로 증가.
    - 각 노드는 평균적으로 비슷한 부하를 나눠 가짐.
- **장점**:
    - 데이터셋이 커져도 파티션 크기가 안정적으로 유지.
    - 확장성 좋고 관리가 단순.
- **구현 방식**: 해시 기반 파티셔닝과 결합해, 파티션 경계를 무작위로 정하고 분산 → 메타데이터 오버헤드 최소화.
- **사례**: 카산드라, 케타마(Ketama). 카산드라는 노드당 파티션 개수를 기준으로 데이터 분산 및 재균형화 알고리즘 제공.

# 5. 요청 라우팅

클라이언트에서 요청을 보낼 때, 어느 노드로 접속해야 하는지 알 수 있어야 함.

⇒ 서비스 디스커버리

<img width="554" height="261" alt="image" src="https://github.com/user-attachments/assets/fa5a7a11-038a-4491-a552-8da2b511bf35" />


상위 수준에서 보면, 위 그림과 같이 세 가지 접근 방식이 있을 수 있다. (1번이 가십 프로토콜(gossip protocol))
핵심은 라우팅 결정을 내리는 컴포넌트가 노드에 할당된 파티션의 변경 사항을 어떻게 아느냐다.
→ 이 문제는 참여하는 모든 곳에서 정보가 일치해야 하므로 다루기 어려움.

<img width="577" height="255" alt="image" src="https://github.com/user-attachments/assets/8099400d-e146-477d-9829-d61af25e9437" />


위와 같이 별도의 코디네이터를 사용한다. 각 노드는 주키퍼에 자신을 등록하고, 주키퍼는 파티션과 노드 사이의 정보를 관리한다.

각 노드에 변경사항이 생기면 주키퍼에 알려서 최신 정보를 유지한다.
