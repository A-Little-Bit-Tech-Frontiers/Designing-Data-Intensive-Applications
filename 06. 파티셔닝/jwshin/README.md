# 6장. 파티셔닝

## 1. 파티셔닝의 필요성

- **확장성**: 복제만으로는 읽기/장애 대응은 좋아지지만, 데이터셋·트래픽이 충분히 커지면 **쓰기·저장 자체를 분산**해야 함 → 파티셔닝.
- **비공유Shared-nothing)** 아키텍처에서 각 노드가 서로 다른 **파티션**을 담당. 복제 규칙(리더/팔로워 등)은 5장에서 본 원리와 동일하게 각 파티션 단위로 적용됨.
- 목표: 대용량 데이터셋이 여러 디스크에 분산될 수 있고 질의 부하는 여러 프로세서에 분산될 수 있다.

## 2. 파티셔닝과 복제

- 보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다. 각 레코드는 정확히 한 파티션에 속하더라도 여러 노드에 저장해서 내결함성을 보장한다.
- 한 노드에 여러 파티션을 가질 수 있으며, 각 **파티션**은 독립적으로 **복제 세트(리더 1 + 팔로워 N)** 를 가진다. → 각 노드는 어떤 파티션에게는 리더이면서 다른 파티션에게는 팔로워가 될 수 있다.

<img width="655" height="377" alt="image" src="https://github.com/user-attachments/assets/98c21406-2c5f-46e6-843b-1ff9591b4ce6" />

- 주의: 파티션 재배치/스플릿 시 **복제본 전체**가 움직이므로 **네트워크/디스크 비용**이 큼 → 재균형 전략이 중요.

## 3. 파티션을 나누는 핵심 기준(파티션 키 설계)

파티셔닝의 목적은 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것이기 때문에 어떤 레코드를 어느 노드에 저장할지 결정하는 문제는 매우 중요하다.

파티셔닝이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션이 있다면 **쏠렸다(skewed)** 고 말한다. 불균형하게 부하가 높은 파티션을 **핫스팟**이라고 한다.

### 3-1. 키 범위 기준 파티셔닝 (Range)

- 종이 백과사전처럼 각 파티션에 연속된 범위(어떤 최솟값에서 최댓값까지)의 키를 할당하는 방법이다. 각 범위들 사이의 경계를 알면 어떤 키가 어느 파티션에 속하는지 쉽게 찾을 수 있다. 데이터가 고르게 분포하지 않을 수 있기 때문에 키 범위가 반드시 동일할 필요는 없다.
- 각 파티션 내에서는 키를 정렬된 순서로 저장할 수 있다. → **범위 스캔**(날짜 구간, 가나다/알파벳 구간)이 쉬워진다.
- 반면, 특정 구간(최근 날짜, 인기 prefix)에 **핫스팟**이 생기기 쉽다.
- 보완 팁
    - **복합키**로 분산(예: (user_id, update_timestamp)), 또는 **접두사 무작위화/역순 타임스탬프** 등으로 **쓰기 분산**.
    - 균형이 크게 틀어지면 **스플릿/머지**로 파티션 경계를 재조정(동적 파티셔닝).

### 3-2. 키 해시값 기준 파티셔닝 (Hash)

- 쏠림과 핫스팟의 위험 때문에 많은 분산 데이터스토어는 파티션을 정하는데 해시 함수를 사용한다.
- 해시 함수를 통해 쏠린 데이터를 균일하게 분산되게 한다.
- 각 파티션에 해시값 범위를 할당하고, 키의 해시값이 파티션의 범위에 속하는 모든 데이터를 해당 파티션에 할당한다.
- 장점
    - **핫스팟 완화**(값이 고르게 섞임), 키 공간 전체에 쓰기가 분산.
- 단점
    - 범위/정렬 스캔이 **비효율**(정렬 정보가 사라짐. 몽고DB에서는 해시 기반 샤딩 모드를 활성화하면 범위 질의가 모든 파티션에 전송돼야 한다.
- 구현 팁
    - 해시 함수는 **안정적이고 충돌이 적은 것**(예: Murmur/MD5 등) 사용.
    - 애플리케이션 레벨에서 Object.hashCode() 같은 **불안정 해시**는 지양(버전/언어에 따라 달라질 수 있음).

## 4. 핫스팟(Hotspot)과 쏠림 방지

- 키를 해싱해서 파티션을 줄이면 핫스팟을 줄이는 데 도움이 되지만, 완벽히 제거할 수는 없다.
- 예를 들면, SNS 팔로워가 많은 유명인의 키는 동일하므로 해싱해도 동일한 키를 갖게되어 하나의 파티션에 요청이 몰리게 된다.
- **시간 키 단독 사용**(순증 타임스탬프)은 최신 파티션에 모든 쓰기가 몰림 → **항상 금물**.
- 회피 방법:
    - 키의 시작이나 끝에 임의의 숫자를 붙인다. 임의의 10진수 두 개만 붙이더라도 한 키에 대한 쓰기 작업이 100개의 다른 키로 균등하게 분산되고 그 키들은 다른 파티션으로 분산될 수 있다. 그러나 읽기를 실행할 때 추가적인 작업이 필요해진다. 100개의 키에 해당하는 데이터를 읽어서 조합해야하기 때문이다. 이 방법은 요청이 몰리는 소수의 키에만 적용해야 한다.

## 5. 파티셔닝과 보조 색인(Secondary Index)

- 지금까지 설명한 파티셔닝 방식은 키-값 데이터 모델에 의존한다. 레코드를 기본키를 통해서만 접근한다면 키로부터 파티션을 결정하고, 해당 키를 담당하는 파티션으로 읽기 쓰기 요청을 전달한다.
- 보조 색인은 보통 레코드를 유일하게 식별하는 용도가 아니라 특정한 값이 발생한 항목을 검색하는 수단이다.
- 보조 색인은 솔라나 엘라스틱서치 같은 검색 서버에게는 존재의 이유다.
- 보조 색인이 있는 데이터베이스를 파티셔닝하는 데 널리 쓰이는  두 가지 방법이 있다. 문서 기반 파티셔닝과 용어 기반 파티셔닝이다.

### 5-1. 문서(레코드) 기준 보조 색인 (Local/Global Index with Document Shard)

- **기본 파티셔닝은 문서 ID**로 결정. 문서가 속한 파티션에서 **해당 문서의 색인 항목**만 유지
- 이런 색인 방법을 사용하면 각 파티션이 완전히 독립적으로 동작한다. 각 파티션은 자신의 보조 색인을 유지하며 그 파티션에 속하는 문서만 담당한다. 다른 파티션에 어떤 데이터가 저장되는지는 신경쓰지 않는다.
- 데이터베이스에 문서 추가, 삭제, 갱신 등의 쓰기 작업을 할 때 쓰려고하는 문서 ID를 포함하는 파티션만 다루면 된다.
- → 이런 이유로 문서 파티셔닝 색인은 **지역 색인(local index)** 이라고도 한다.

<img width="660" height="354" alt="image" src="https://github.com/user-attachments/assets/70e373e5-d4c6-4665-86ed-64356803b027" />

- 장점: 쓰기가 빠르고 지역적(문서와 인덱스가 함께 이동).
- 단점: **검색 시 여러 파티션을 스캐터/개더**해야 함(응답 지연, 비용 증가). 즉, 보조 색인을 사용해서 검색하려면 모든 파티션으로 질의를 보내서 얻은 결과를 모두 모아야 한다.
    
    → 검색 시스템(Elastic 등)과 **전용 인덱스 클러스터**를 따로 두는 패턴이 흔함.
    
### **5-2. 용어(필드 값/Term) 기준 보조 색인 (Term-Partitioned/Global)**

- 각 파티션이 자신만의 보조 색인(지역 색인)을 갖게 하는 대신, 모든 파티션의 데이터를 담당하는 **전역 색인**을 만들 수도 있다.
- 색인 자체를 **용어(예: color=red)** 를 키로 **별도 파티셔닝**. 한 용어에 해당하는 모든 문서 ID를 그 파티션이 소유.
- 그러나 한 노드에만 색인을 저장할 수는 없다. 해당 노드가 병목이 되어 파티셔닝의 목적을 해치기 때문이다. 전역 색인도 파티셔닝해야 하지만 기본키 색인과는 다른 식으로 할 수 있다. (그림 6-5)

<img width="662" height="318" alt="image" src="https://github.com/user-attachments/assets/86145445-47a9-4b66-8231-7dbb32422b5d" />

- 모든 파티션에 있는 빨간색 자동차 정보는 색인에서 colodr:red 항목에 저장되지만, a-r까지의 색깔 색인은 파티션 0에, s-z까지의 색깔 색인은 파티션1에 저장되도록 파티셔닝 된다.
- 장점: **질의가 특정 용어 중심**일 때 매우 빠름(한 파티션에 다 모여 있음). 읽기 작업을 할 때 모든 파티션에 스캐터/개더를 실행할 필요 없이 원하는 용어를 포함하는 파티션으로만 요청을 보내면 된다.
- 단점: 문서 1개의 쓰기가 다수의 색인 파티션에 반영되므로 쓰기 작업이 느리다. 대부분의 데이터베이스에서 전역 보조 색인은 비동기로 갱신되므로 쓰기를 실행한 후 바로 색인을 읽으면 변경사항이 색인에 반영되지 않았을 수도 있다.

## 6. 파티션 재균형화(Rebalancing)

### **6-1. 언제 필요한가**

- 데이터·트래픽 증가로 **파티션이 과도하게 커질 때**(디스크/CPU/IO 압박).
- 노드 증설/감축, 성능 이질 노드 혼재, 특정 키 인기 급증(스큐) 등.
- 이런 변화가 생기면 데이터와 요청이 한 노드에서 다른 노드로 옮겨져야 한다. 클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 **재균형화(rebalancing)** 라고 한다.

### 6-2. 대표 전략

1. **쓰면 안되는 방법: 해시값에 mod N 연산을 수행**
    - 왜 모드(mod) 연산을 쓰면 안되는가? 예를 들어, hash(key) mod 10은 0과 9 사이의 숫자를 반환한다. (해시값으로 십진수를 쓴다면 hash mod 10은 마지막 자릿수가 된다.) 노드가 10대 있고 각각 0부터 9까지 숫자를 배정하면 각 키를 노드에 할당하는 것은 쉬워 보인다. mod N 방식의 문제는 노드 갯수 N이 바뀌면 대부분의 키가 노드 사이에서 재배치 되어야 한다는 것이다.
    - 예를 들어 hash(key) = 123456이라고 했을 때, 처음에 노드가 10대라면 이 키는 노드 6에 할당된다. 노드가 11대로 늘어나면 이 키는 노드 3으로 옮겨져야 하고, 노드가 12대로 늘어나면 노드 0으로 옮겨져야 한다.
    - 즉, 노드 수가 바뀔 때 **거의 모든 키가 재배치** → 재균형화 비용 폭증.
2. **파티션 개수 고정**
    - 미리 **작은 파티션 수백~수천 개**를 만들어 두고, 노드 수와 무관하게 **파티션→노드 매핑**만 재배정.
    - 예를 들어, 노드 10대로 구성된 클러스터에서 실행되는 데이터베이스는 처음부터 파티션을 1,000개로 쪼개서 각 노드마다 약 100개의 파티션을 할당할 수 있다.
    - 클러스터에 노드가 추가되면 새 노드는 파티션이 다시 균일하게 분배될 때까지 기존 노드에서 파티션 몇 개를 뺏어올 수 있다. 노드가 제거되면 이 과정이 반대로 실행된다.
    - 파티션은 노드 사이에서 통째로 이동하기만 한다. 파티션 갯수는 바뀌지 않고 파티션에 할당된 키도 변경되지 않는다. 유일한 변화는 노드에 어떤 파티션이 할당되는가이다.
    - 장점: 재균형 시 **이동량 최소화**, 운영 단순.
    - 대부분의 시스템이 **vnode**로 이 패턴을 구현.
    
    <img width="669" height="387" alt="image" src="https://github.com/user-attachments/assets/47ca4514-3d82-4c8e-a897-f3516fb4a093" />
    
3. **동적 파티셔닝 (Split/Merge)**
    - **Range 기반**에서 많이 사용. 핫 파티션을 **스플릿(**파티션 크기가 설정된 값을 넘어서면 분할**)**, 한산한 파티션은 **머지**(파티션 크키가 설정된 값 아래로 떨어지면 병합)
    - 시작 시 **프리-스플릿**(선분할)로 초기 핫스팟 방지.
4. **노드 비례 파티셔닝 (Ketama/Consistent Hashing + vnodes)**
    - 카산드라와 케타마에서 사용되는 방법은 파티션 개수가 노드 대수에 비례하게 하는 것이다. 다시 말해 노드당 할당되는 파티션 개수를 고정한다.

### 6-3. 운영: 자동 재균형화와 수동 재균형화

- **자동**: 운영 편하지만 **스톰/진동(thrashing)**, 예기치 않은 **중복 이동/과부하** 위험.
- **수동(반자동)**: 변화 감지는 자동, **실제 이동은 승인·윈도 제어**(야간/저부하 시간) — 실무 선호.

## 7. 요청 라우팅(Request Routing)

클라이언트가 “특정 키(=파티션 키)에 대한 요청을 **어느 노드**로 보낼지”를 아는 문제.

1. **아무 노드 진입(랜덤 진입) + 내부 포워딩**
    - 진입한 노드가 **내부에서 올바른 노드로 포워딩**.
    - 장점: 설정 단순.
    - 단점: **두 번 점프**로 지연↑.
2. **라우팅 계층(코디네이터/프록시)**
    - 모든 요청을 **프론트 노드(코디네이터)** 가 받아 **올바른 노드**로 전달.
    - 장점: 클라이언트 단순.
    - 단점: **추가 홉/병목** 가능, 계층의 **고가용성** 필요.
3. **클라이언트 라우팅(Partition-aware Client)**
    - 클라이언트가 **파티션→노드 맵**을 캐시(주키퍼/헬릭스/컨피그 서버에서 구독)하고 **직접 해당 노드**로 요청.
    - 장점: 추가 홉 없음(지연↓).
    - 단점: **맵 동기화** 필요, 다언어/다클라이언트 관리가 까다로울 수 있음.

<img width="654" height="338" alt="image" src="https://github.com/user-attachments/assets/793f0222-f01b-4d95-9699-50192925b8b1" />

모든 경우에 핵심 문제는 라우팅 결정을 내리는 구성요소(노드 중 하나일 수도, 라우팅 계층일 수도, 클라이언트일 수도 있다.)가 노드에 할당된 파티션의 변경 사항을 어떻게 아느냐다.

이 문제는 참여하는 모든 곳에서 정보가 일치해야 하므로 다루기 어렵다.

많은 분산 데이터 시스템은 클러스터 메타데이터를 추적하기 위해 주키퍼(ZooKeeper) 같은 별도의 코디네이션 서비스를 사용한다. 각 노드는 주키퍼에 자신을 등록하고 주키퍼는 파티션과 노드 사이의 신뢰성 있는 할당 정보를 관리한다.

파티션 소유자가 바뀌든지, 노드가 추가되거나 삭제되면 주키퍼는 라우팅 계층에 이를 알려서 라우팅 정보를 최신으로 유지할 수 있게 한다.

<img width="653" height="332" alt="image" src="https://github.com/user-attachments/assets/7effc8ea-515b-40dc-9c3e-7c0b0e487f05" />

링크드인의 에스프레소는 헬릭스(Helix)를 써서 클러스터를 관리한다.

HBase, 솔라클라우드, 카프카도 파티션 할당을 추적하는 데 주키퍼를 사용한다.

몽고DB도 아키텍처는 비슷하지만 자체적인 설정 서버(config server) 구현에 의존하고 몽고스(mongos) 데몬을 라우팅 계층으로 사용한다.

카산드라와 리악은 가십 프로토콜(gossip protocol)을 사용해서 클러스터 상태 변화를 노드 사이에 퍼뜨린다.

## 8. 병렬 질의 실행

- 분석용으로 자주 사용되는 대규모 병렬 처리(massively parallel processing, MPP) 관계형 데이터베이스 제품은 복잡한 종류의 질의를 지원한다.
- 전형적인 데이터 웨어하우스 질의는 **조인(join), 필터링(filtering), 그룹화(grouping), 집계(aggregation) 연산을 몇 개 포함한다.**
- MPP 질의 최적화기는 복잡한 질의를 여러 실행 단계와 파티션으로 분해하여 클러스터 내의 서로 다른 노드에서 병렬적으로 실행될 수 있다.

## 9. 6장 정리

- 6장은 대용량을 복제만으로는 감당 못할 때 데이터를 노드들로 나눠 담아 처리량·용량을 수평 확장하는 방법인 파티셔닝을 다룬다.
- 핵심은 파티션 키 선택과 불균형 대응: 범위 기반은 정렬·범위스캔에 유리하지만 단조 증가 키로 핫스팟이 생기고, 해시 기반은 균등 분산에 강하지만 스캐터/개더가 늘어난다.
- 파티션 위에 얹는 보조 색인은 파티션마다 유지하는 지역 인덱스(쓰기 유리, 조회 시 팬아웃)와 값 기준으로 별도 파티션에 두는 글로벌/용어 인덱스(조회 유리, 쓰기 비용·일관성 관리)로 나뉜다.
- 재균형은 vNode 재배치, 핫 파티션 split/콜드 merge로 이동량을 줄이고, 자동 탐지+수동 승인 방식이 안전하다(단, mod N 해싱·너무 작은 파티션 남발은 금물).
- 라우팅은 클라이언트-사이드, 코디네이터/프록시, 아무 노드 진입 후 내부 포워딩 중 하나를 쓰며, 파티션 맵은 ZK/가십으로 일관성 있게 배포한다.
- 결론적으로, 주요 질의 경로에 맞춘 키 설계와 핫스팟 모니터링·점진적 재균형이 파티셔닝 시스템의 성패를 가르고, 목표는 언제나 균등 분산과 데이터 지역성의 균형이다.
