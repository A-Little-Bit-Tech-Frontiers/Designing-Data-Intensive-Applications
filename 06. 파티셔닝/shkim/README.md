# 파티셔닝

5장에서 우리는 복제(replication)에 대해 논의했습니다. 즉, 동일한 데이터를 여러 노드에 여러 복사본으로 저장하는 것입니다. <br>
하지만 매우 큰 데이터셋이나 매우 높은 쿼리 처리량이 필요한 경우, 이것만으로는 충분하지 않습니다. 데이터를 파티션(partition) 또는 샤딩(sharding)이라고도 하는 방식으로 분할해야 합니다.

일반적으로 파티션은 각 데이터(레코드, 행, 문서)가 정확히 하나의 파티션에 속하도록 정의됩니다. <br>
사실상 각 파티션은 자체적으로 작은 데이터베이스와 같으며, 데이터베이스는 여러 파티션에 걸친 작업도 지원할 수 있습니다.

데이터를 파티션하는 주된 이유는 확장성(scalability)입니다. 서로 다른 파티션을 공유하지 않는 클러스터(shared-nothing cluster)의 서로 다른 노드에 배치할 수 있습니다. <br>
따라서 대용량 데이터셋을 여러 디스크에 분산시킬 수 있고, 쿼리 부하도 여러 프로세서에 분산시킬 수 있습니다. <br>
단일 파티션에서 동작하는 쿼리의 경우, 각 노드는 자신의 파티션에 대한 쿼리를 독립적으로 실행할 수 있으므로, 노드를 추가함으로써 쿼리 처리량을 확장할 수 있습니다. <br>
대규모, 복잡한 쿼리는 여러 노드에 걸쳐 병렬화할 수 있지만, 이는 훨씬 더 어려워집니다.

## 파티셔닝과 복제

파티셔닝은 일반적으로 복제와 결합되어 각 파티션의 복사본을 여러 노드에 저장합니다. <br>
즉, 각 레코드는 정확히 하나의 파티션에 속하지만, 장애 허용(fault tolerance)을 위해 여러 노드에 저장될 수 있습니다. <br>
5장에서 논의한 데이터베이스 복제에 관한 모든 내용은 파티션 복제에도 동일하게 적용됩니다. 파티셔닝 방식의 선택은 복제 방식의 선택과 대부분 독립적입니다.

## 키-값 데이터의 파티셔닝

파티셔닝의 목표는 데이터와 쿼리 부하를 노드에 고르게 분산시키는 것입니다. <br>
파티셔닝이 불공정하게 이루어져 일부 파티션에 데이터나 쿼리가 몰리면 이를 skewed(편향됨)라고 합니다. <br>
skew가 있으면 파티셔닝의 효과가 크게 떨어집니다. 극단적인 경우, 모든 부하가 하나의 파티션에 집중되어 10개 중 9개 노드는 유휴 상태가 되고, 병목은 바쁜 한 노드가 됩니다. <br>
부하가 지나치게 높은 파티션을 hot spot(핫스팟)이라고 합니다.

핫스팟을 피하는 가장 간단한 방법은 레코드를 노드에 무작위로 할당하는 것입니다. <br>
이렇게 하면 데이터가 노드에 고르게 분산되지만, 특정 항목을 읽으려 할 때 어느 노드에 있는지 알 수 없어 모든 노드에 병렬로 쿼리해야 하는 단점이 있습니다. <br>
더 나은 방법이 있습니다. 여기서는 항상 기본 키(primary key)로 레코드에 접근하는 단순 키-값 데이터 모델을 가정합니다.

<img width="659" height="398" alt="Image" src="https://github.com/user-attachments/assets/8040d48b-e3ff-4cb9-a08e-d310ca5b0acb" />

### 키 범위에 의한 파티셔닝

파티셔닝의 한 방법은 연속된 키 범위를 각 파티션에 할당하는 것입니다. <br>
범위의 경계를 알면 특정 키가 어느 파티션에 속하는지 쉽게 알 수 있습니다. 또한 각 파티션이 어느 노드에 할당되어 있는지 알면, 해당 노드에 직접 요청을 보낼 수 있습니다.

<img width="536" height="286" alt="Image" src="https://github.com/user-attachments/assets/d340d731-0927-446d-ab2b-823ca491bf18" />

키 범위는 반드시 균등하게 분포되어 있지 않습니다. 데이터가 고르게 분포되어 있지 않을 수 있기 때문입니다. <br>
데이터를 고르게 분산시키려면 파티션 경계가 데이터에 맞게 조정되어야 합니다. 파티션 경계는 관리자가 수동으로 정할 수도 있고, 데이터베이스가 자동으로 선택할 수도 있습니다.

각 파티션 내에서는 키를 정렬된 순서로 유지할 수 있습니다. <br>
이렇게 하면 범위 스캔이 쉽고, 키를 연결된 인덱스로 취급해 여러 관련 레코드를 한 번에 조회할 수 있습니다. <br>
하지만 키 범위 파티셔닝의 단점은 특정 접근 패턴이 핫스팟을 유발할 수 있다는 점입니다.

### 키 해시(Hash)에 의한 파티셔닝

skew와 핫스팟의 위험 때문에, 많은 분산 데이터 저장소는 키에 해시 함수를 적용해 파티션을 결정합니다. 좋은 해시 함수는 편향된 데이터를 균등하게 분산시켜줍니다. <br>
적절한 해시 함수가 있으면, 각 파티션에 해시 범위를 할당하고, 해당 범위에 속하는 키의 해시값을 가진 모든 키를 그 파티션에 저장합니다.

이 방식은 키를 파티션에 고르게 분산시키는 데 효과적입니다. <br>
파티션 경계는 균등하게 배치할 수도 있고, 의사난수(pseudorandom)로 선택할 수도 있는데, 이 경우 일관성 해싱(consistent hashing)이라고도 합니다.

<img width="674" height="280" alt="Image" src="https://github.com/user-attachments/assets/36ff1d38-e184-496e-8434-efb40df45220" />

하지만 키 해시를 이용한 파티셔닝은 키 범위 파티셔닝의 장점인 효율적인 범위 쿼리 기능을 잃게 됩니다. <br>
인접한 키들이 모든 파티션에 흩어져 정렬 순서가 사라집니다. <br>
여러 컬럼을 연결한 복합 기본 키를 선언하는 것이 한 가지 해결책이 될 수 있습니다. 연결된 인덱스 방식은 일대다(one-to-many) 관계에 우아한 데이터 모델을 제공합니다.

### 편향된 워크로드와 핫스팟 완화

키 해시를 이용해 파티션을 결정하면 핫스팟을 줄일 수 있지만, 완전히 피할 수는 없습니다. <br>
극단적으로 모든 읽기/쓰기 요청이 동일한 키에 집중되면, 모든 요청이 동일한 파티션으로 라우팅됩니다. 해시를 써도 동일한 ID의 해시는 항상 같습니다.

현재 대부분의 데이터 시스템은 이런 극도로 편향된 워크로드를 자동으로 보상하지 못하므로, 애플리케이션이 skew를 줄여야 합니다. <br>
예를 들어, 특정 키가 매우 핫한 경우, 키 앞이나 뒤에 난수를 추가하는 간단한 방법이 있습니다. <br>
두 자리 난수를 추가하면 쓰기 요청이 100개의 서로 다른 키로 분산되어, 각 키가 다른 파티션에 할당될 수 있습니다.

하지만 이렇게 쓰기를 분산시키면, 읽기 시에는 100개의 키에서 데이터를 읽어와 합쳐야 하므로 추가 작업이 필요합니다. <br>
이 방법은 추가적인 관리가 필요합니다. 핫한 소수의 키에만 난수를 추가하는 것이므로, 대부분의 키에는 불필요한 오버헤드가 됩니다. <br>
따라서 어떤 키가 분할되고 있는지 추적하는 방법이 필요합니다.

앞으로는 데이터 시스템이 편향된 워크로드를 자동으로 감지하고 보상할 수 있을지도 모르지만, 현재로서는 애플리케이션에서 트레이드오프를 잘 고려해야 합니다.

## 파티셔닝과 보조 인덱스(Secondary Indexes)

지금까지 논의한 파티셔닝 방식은 키-값 데이터 모델에 의존합니다. <br>
레코드를 항상 기본 키로만 접근한다면, 해당 키로 파티션을 결정해 읽기/쓰기 요청을 해당 파티션으로 라우팅할 수 있습니다.

하지만 보조 인덱스가 있으면 상황이 더 복잡해집니다. 보조 인덱스는 일반적으로 레코드를 고유하게 식별하지 않고, 특정 값의 발생을 검색하는 방법입니다.
보조 인덱스는 관계형 데이터베이스의 핵심이며, 문서 데이터베이스에서도 흔히 사용됩니다. <br>
많은 키-값 저장소는 구현 복잡성 때문에 보조 인덱스를 피했지만, 데이터 모델링에 매우 유용하기 때문에 일부는 추가하기 시작했습니다. <br>
그리고 보조 인덱스는 Solr, Elasticsearch 같은 검색 서버의 존재 이유입니다.

보조 인덱스의 문제는 파티션에 깔끔하게 매핑되지 않는다는 점입니다. <br>
보조 인덱스가 있는 데이터베이스를 파티셔닝하는 방법에는 두 가지가 있습니다: **문서 기반 파티셔닝(document-based partitioning)** 과 **용어 기반 파티셔닝(term-based partitioning)** 입니다.

### 문서 기반 파티셔닝

인덱스를 선언하면 데이터베이스가 자동으로 인덱싱을 수행할 수 있습니다. <br>
이 방식에서는 각 파티션이 완전히 분리되어, 각 파티션은 해당 파티션의 문서만을 대상으로 보조 인덱스를 유지합니다. <br>
다른 파티션에 어떤 데이터가 있는지는 신경 쓰지 않습니다. 그래서 문서 기반 인덱스를 로컬 인덱스(local index)라고도 합니다.

하지만 문서 기반 인덱스에서 읽으려면 주의가 필요합니다. 모든 파티션에 쿼리를 보내고, 받은 결과를 합쳐야 합니다. <br>
이런 방식의 쿼리를 scatter/gather라고 하며, 보조 인덱스에 대한 읽기 쿼리를 매우 비싸게 만듭니다. <br>
파티션에 병렬로 쿼리하더라도, scatter/gather는 tail latency amplification(꼬리 지연 증폭)에 취약합니다. 그럼에도 불구하고 Elasticsearch 등에서 널리 사용됩니다.

### 용어 기반 파티셔닝

각 파티션이 자체 보조 인덱스(로컬 인덱스)를 가지는 대신, 모든 파티션의 데이터를 아우르는 글로벌 인덱스(global index)를 만들 수 있습니다. <br>
하지만 이 인덱스를 한 노드에만 저장하면 병목이 되어 파티셔닝의 목적이 사라집니다. 글로벌 인덱스도 파티셔닝해야 하며, 기본 키 인덱스와는 다르게 파티셔닝할 수 있습니다.

이런 인덱스를 용어 기반(term-partitioned) 인덱스라고 하며, 찾고자 하는 용어가 인덱스의 파티션을 결정합니다. 예를 들어, color:red 같은 용어가 해당됩니다.
글로벌(용어 기반) 인덱스의 장점은 읽기가 더 효율적이라는 점입니다. <br>
모든 파티션에 scatter/gather를 할 필요 없이, 원하는 용어가 있는 파티션에만 요청을 보내면 됩니다. <br>
하지만 단점은 쓰기가 더 느리고 복잡해진다는 점입니다. 한 문서에 대한 쓰기가 인덱스의 여러 파티션에 영향을 줄 수 있기 때문입니다.

## 파티션 재조정(Rebalancing)

시간이 지나면서 데이터베이스에는 변화가 생깁니다.

- 쿼리 처리량이 증가해 더 많은 CPU가 필요해집니다.
- 데이터셋 크기가 증가해 더 많은 디스크와 RAM이 필요해집니다.
- 머신이 장애를 일으키면, 다른 머신이 해당 역할을 대신해야 합니다.

이런 변화는 데이터와 요청을 한 노드에서 다른 노드로 옮겨야 함을 의미합니다. 클러스터 내에서 부하를 옮기는 과정을 **재조정(rebalancing)** 이라고 합니다.

파티셔닝 방식에 관계없이, 재조정은 일반적으로 다음과 같은 최소 요구사항을 충족해야 합니다.

- 재조정 후에는 클러스터 내 노드 간에 부하(데이터 저장, 읽기/쓰기 요청)가 공평하게 분산되어야 합니다.
- 재조정 중에도 데이터베이스는 읽기/쓰기를 계속 받아들여야 합니다.
- 불필요한 데이터 이동은 최소화해, 재조정이 빠르고 네트워크 및 디스크 I/O 부하를 줄여야 합니다.

## 재조정 전략

파티션을 노드에 할당하는 방법에는 몇 가지가 있습니다.

### 고정된 파티션 수

<img width="658" height="420" alt="Image" src="https://github.com/user-attachments/assets/1dd06138-37ef-4f99-b7e6-4afa672ad54a" />

해시와 mod N 방식을 사용하면, 노드 수 N이 변경될 때 대부분의 키를 다른 노드로 옮겨야 합니다. 이런 잦은 이동은 재조정 비용을 지나치게 높입니다. 데이터 이동을 최소화하는 방법이 필요합니다. <br>
간단한 해결책은 노드 수보다 훨씬 많은 파티션을 만들고, 각 노드에 여러 파티션을 할당하는 것입니다. <br>
이 방식에서는 전체 파티션만 노드 간에 이동합니다. 파티션 수는 변하지 않고, 키의 파티션 할당도 변하지 않습니다. 변하는 것은 파티션의 노드 할당뿐입니다. <br>

이 구성에서는 데이터베이스를 처음 설정할 때 파티션 수를 고정하고 이후에는 변경하지 않는 것이 일반적입니다.
데이터셋의 전체 크기가 크게 변동된다면 적절한 파티션 수를 선택하기 어렵습니다. <br>
파티션 크기가 너무 크거나 너무 작지 않은 "적당한" 상태일 때 성능이 가장 좋지만, 파티션 수가 고정되어 있으면 이를 달성하기 어렵습니다.

### 동적 파티셔닝

키 범위 파티셔닝을 사용하는 데이터베이스에서, 고정된 파티션 수와 경계는 매우 불편합니다. <br>
경계를 잘못 정하면 모든 데이터가 한 파티션에 몰리고, 나머지 파티션은 비게 됩니다. 경계를 수동으로 재설정하는 것은 매우 번거롭습니다.

그래서 키 범위 파티셔닝 데이터베이스는 파티션을 동적으로 만듭니다. <br>
파티션이 설정된 크기를 초과하면 두 개의 파티션으로 분할해, 데이터가 대략 반씩 나뉘게 합니다. <br>
동적 파티셔닝의 장점은 파티션 수가 전체 데이터 양에 맞게 조정된다는 점입니다. <br>
단점은 빈 데이터베이스는 처음에 하나의 파티션만 있다는 점입니다. 어디에 경계를 둘지 사전에 알 수 없기 때문입니다. <br>
동적 파티셔닝은 키 범위뿐 아니라 해시 파티셔닝에도 사용할 수 있습니다.

### 노드 수에 비례한 파티셔닝

동적 파티셔닝에서는 파티션 수가 데이터셋 크기에 비례합니다. <br>
분할/병합 과정이 각 파티션의 크기를 일정 범위 내로 유지하기 때문입니다. <br>
반면, 고정된 파티션 수에서는 각 파티션의 크기가 데이터셋 크기에 비례합니다. 두 경우 모두 파티션 수는 노드 수와 독립적입니다. <br>
세 번째 방법은 파티션 수를 노드 수에 비례하게 하는 것입니다. 즉, 노드당 고정된 파티션 수를 갖는 방식입니다.

## 운영: 자동 또는 수동 재조정

재조정은 비용이 많이 드는 작업입니다. 요청을 재라우팅하고, 많은 데이터를 한 노드에서 다른 노드로 옮겨야 하기 때문입니다. <br>
신중하게 처리하지 않으면 네트워크나 노드가 과부하되어, 재조정 중 다른 요청의 성능이 저하될 수 있습니다.

완전 자동 재조정은 유지보수에 편리하지만, 예측이 어렵습니다. <br>
그래서 재조정에 사람이 개입하는 것이 좋은 경우도 있습니다. 완전 자동보다 느리지만, 운영상 예기치 않은 상황을 방지할 수 있습니다.

## 요청 라우팅

이제 데이터셋을 여러 노드, 여러 머신에 걸쳐 파티셔닝했습니다. 하지만 남은 문제는, 클라이언트가 요청을 보낼 때 어느 노드에 연결해야 하는지입니다. <br>
이것은 서비스 디스커버리(service discovery)라는 더 일반적인 문제의 한 예입니다. 데이터베이스에만 국한되지 않습니다.

많은 분산 데이터 시스템은 ZooKeeper 같은 별도의 조정 서비스(coordination service)를 사용해 클러스터 메타데이터를 관리합니다. <br>
각 노드는 ZooKeeper에 자신을 등록하고, ZooKeeper는 파티션과 노드의 매핑을 권위 있게 유지합니다. <br>
라우팅 계층이나 파티셔닝을 인식하는 클라이언트 등 다른 주체는 ZooKeeper의 정보를 구독할 수 있습니다. <br>
파티션 소유권이 변경되거나 노드가 추가/제거되면, ZooKeeper가 라우팅 계층에 알림을 보내 라우팅 정보를 최신 상태로 유지합니다.

라우팅 계층을 사용하거나 임의의 노드에 요청을 보낼 때, 클라이언트는 연결할 IP 주소를 알아야 합니다. <br>
파티션-노드 할당만큼 자주 바뀌지 않으므로, 이 경우에는 DNS를 사용하는 것으로 충분한 경우가 많습니다.

<img width="663" height="351" alt="Image" src="https://github.com/user-attachments/assets/9595913d-66f0-426a-84d7-48f08298f41f" /> <br>
<img width="649" height="363" alt="Image" src="https://github.com/user-attachments/assets/76eab01c-d3e4-4eea-a2f9-b87f61c9d791" />

## 병렬 쿼리 실행

지금까지는 단일 키를 읽거나 쓰는 매우 단순한 쿼리(문서 기반 보조 인덱스의 scatter/gather 쿼리 포함)에 집중했습니다. 이는 대부분의 NoSQL 분산 데이터 저장소가 지원하는 접근 수준입니다.

하지만 MPP(massively parallel processing) 관계형 데이터베이스 제품은 훨씬 더 복잡한 쿼리를 지원합니다. <br>
일반적인 데이터 웨어하우스 쿼리는 여러 조인, 필터링, 그룹화, 집계 연산을 포함합니다. <br>
MPP 쿼리 옵티마이저는 이 복잡한 쿼리를 여러 실행 단계와 파티션으로 나누고, 많은 단계를 데이터베이스 클러스터의 여러 노드에서 병렬로 실행할 수 있습니다. <br>
데이터셋의 큰 부분을 스캔하는 쿼리는 병렬 실행의 이점을 크게 누릴 수 있습니다.

데이터 웨어하우스 쿼리의 빠른 병렬 실행은 전문적인 주제이며, 분석의 비즈니스적 중요성 때문에 많은 상업적 관심을 받고 있습니다.
